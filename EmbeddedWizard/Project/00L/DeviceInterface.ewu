$version 11.00

$rect <20,10,220,50>
inline Inline
{
  #include <stddef.h>
  #include <stdlib.h>
  #include "ew_priv.h"
  #include "display_support.h"
  #include "EEPM_pub.h"
  #include "PERIPHERAL_pub.h"
  #include "VI_pub.h"
  #include "MM_pub_ams_type.h"
  #include "BTM_pub.h"
  #include "BC_motocon_pub.h"
  #include "BC_motocon_pub_type.h"
  #include "BC_ams_pub.h"
  #include "NTF_pub.h"
  #include "TEST_pub.h"
  #include "NAVI_pub.h"
  #include "Enum.h"
}

$rect <20,70,220,110>
$output false
class SystemDeviceClass : Templates::DeviceClass
{
  // Interface to get system info
  note group Note1
  {
    attr Bounds = <10,10,1160,280>;
  }

  $rect <250,70,450,110>
  property string SoftwareVersion;

  $rect <470,70,670,110>
  property bool IsDebugBuild;

  $rect <470,120,670,160>
  onget IsDebugBuild
  {
    $if( !$prototyper )
      var bool is_debug_build;
      native( is_debug_build )
      {
        is_debug_build = ew_is_debug_build();
      }
      return is_debug_build;
    $else
      return true;
    $endif
  }

  // Interfaces for factory test
  note group Note3
  {
    attr Bounds = <10,300,740,460>;
  }

  $rect <40,390,240,430>
  $output true
  method void QuitTest()
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Quit;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <490,390,710,430>
  object Core::SystemEvent FactoryTestSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,340,240,380>
  $output true
  method void TestDisplayPattern( arg int32 aIdx )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Display;
    TestContext.Data = aIdx - 1;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <30,220,230,260>
  $output true
  method void NotifyEsnRead( arg string aESN )
  {
    ESN = aESN;
  }

  $rect <30,70,230,110>
  property string ESN;

  $rect <30,120,230,160>
  onset ESN
  {
    if( pure ESN != value )
    {
      pure ESN = value;
      notifyobservers ^ESN;
    }

  }

  $rect <30,170,230,210>
  onget ESN
  {
    $if( !$prototyper )
      if( "" == pure ESN )
      {
        native
        {
           ew_get_esn();
        }
      }
    $endif

    return pure ESN;
  }

  $rect <250,120,450,160>
  onget SoftwareVersion
  {
    $if !$prototyper
      var string software_version = "";

      if( "" == pure SoftwareVersion )
      {
        native( software_version )
        {
           char version[8];
           ew_get_software_version( version );
           software_version = EwNewStringAnsi( version );
        }

        pure SoftwareVersion = software_version;
      }
    $endif

    return pure SoftwareVersion;
  }

  $rect <30,520,250,560>
  method void ResetToFactoryDefault()
  {
    IsRunningReset = true;
    $if !$prototyper
      native
      {
        EW_reset_to_factory_default();
      }
    $endif
    FactoryResetTimer.Enabled = true;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,570,270,610>
  $output true
  method void NotifyFactoryResetComplete()
  {
    FactoryResetTimer.Enabled = false;
    FactoryResetCompletedSystemEvent.Trigger( null, false );
  }

  // Device Interface for Factory Reset
  note group Note4
  {
    attr Bounds = <10,480,550,720>;
  }

  $rect <290,520,530,560>
  object Core::Timer FactoryResetTimer
  {
    preset OnTrigger = OnFactoryResetTimeoutSlot;
    preset Period = 0;
    preset Begin = 2000;
    preset Enabled = false;
  }

  $rect <290,570,530,610>
  slot OnFactoryResetTimeoutSlot
  {
    trace "all reset timeout";
    NotifyFactoryResetComplete();
  }

  $rect <330,620,530,660>
  method void RebootSystem()
  {
    $if !$prototyper
      native
      {
        ew_reboot_system();
      }
    $endif
  }

  $rect <1010,320,1210,360>
  method void SetTFTDutyCycle( arg int32 aDutyCycle )
  {
    $if !$prototyper
      native( aDutyCycle )
      {
        PERIPHERAL_pwm_set_display_dutycycle( aDutyCycle );
      }
    $else
    // suppress warning
    if( 0 == aDutyCycle )
    {
      // empty body
    }
    $endif
  }

  $rect <1010,370,1210,410>
  property int32 BrightnessLevel = 7;

  $rect <250,170,450,210>
  property string BtSoftwareVersion;

  $rect <250,220,450,260>
  onget BtSoftwareVersion
  {
    $if !$prototyper
      var string bt_sw_version = "";

      native( bt_sw_version )
      {
         char version[8];
         ew_get_bt_software_version( version );
         bt_sw_version = EwNewStringAnsi( version );
      }

      pure BtSoftwareVersion = bt_sw_version;
    $endif

    return pure BtSoftwareVersion;
  }

  $rect <250,340,470,380>
  $output true
  method void StartBurnInTest()
  {
    trace "StartBurnInTest";
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInStart;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <250,390,470,430>
  $output true
  method void UpdateBurnInTestTime( arg uint32 aTimeSec )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInTimeUpdate;
    TestContext.Data = ( int32 )aTimeSec;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <499,340,709,380>
  $output true
  method void ShowBurnInTestResult( arg bool aResult )
  {
    trace "ShowBurnInTestResult: ", aResult;
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInResult;
    if( aResult )
    {
      TestContext.Data = 1;
    }
    else
    {
      TestContext.Data = 0;
    }
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <470,170,670,210>
  var bool IsHopperTestMode = false;

  // Device Interface for QR code
  note group Note5
  {
    attr Bounds = <610,530,1120,720>;
  }

  $rect <870,570,1070,610>
  object Core::SystemEvent QrCodeSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <650,570,850,610>
  $output true
  method void NotifyQrCodeReady()
  {
    QrCodeSystemEvent.Trigger( null, false );
  }

  $rect <650,670,850,710>
  method void GetQrCode()
  {
    $if !$prototyper
      native
      {
        ew_request_qrcode();
      }
    $endif
  }

  $rect <680,120,930,160>
  method DeviceInterface::RtcTime GetLocalTime()
  {
    var DeviceInterface::RtcTime CurrentLocalTime = new DeviceInterface::RtcTime;

    $if !$prototyper
      var uint16 RtcYear;
      var uint8 RtcMonth;
      var uint8 RtcDay;
      var uint8 RtcHour;
      var uint8 RtcMinute;
      var uint8 RtcSecond;

      native( RtcYear, RtcMonth, RtcDay, RtcHour, RtcMinute, RtcSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        ew_get_rtc_time( &srtc_time );

        RtcYear = srtc_time.year;
        RtcMonth = srtc_time.month;
        RtcDay = srtc_time.day;
        RtcHour = srtc_time.hour;
        RtcMinute = srtc_time.minute;
        RtcSecond = srtc_time.second;
      }

      CurrentLocalTime.Year = RtcYear;
      CurrentLocalTime.Month = RtcMonth;
      CurrentLocalTime.Day = RtcDay;
      CurrentLocalTime.Hour = RtcHour;
      CurrentLocalTime.Minute = RtcMinute;
      CurrentLocalTime.Second = RtcSecond;
    $else
      // for screenshot
      CurrentLocalTime.Hour = 12;
      CurrentLocalTime.Minute = 40;
    $endif

    return CurrentLocalTime;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <681,70,930,110>
  $output true
  method void NotifyUpdateLocalTime()
  {
    UpdateLocalTimeSystemEvent.Trigger( null, false );
  }

  $rect <680,170,930,210>
  object Core::SystemEvent UpdateLocalTimeSystemEvent;

  // Opening Flow Control
  note group Note6
  {
    attr Bounds = <450,740,1130,950>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <465,786,675,826>
  $output true
  method void StartOpening()
  {
    OpeningSystemEvent.Trigger( null, false );
  }

  $rect <465,836,675,876>
  object Core::SystemEvent OpeningSystemEvent;

  $rect <770,350,970,390>
  method bool IsKeyStateValid()
  {
    var bool IsValid = true;
    $if !$prototyper
      native( IsValid )
      {
        IsValid = VI_is_key_state_valid();
      }
    $endif
    return IsValid;
  }

  $rect <685,786,895,826>
  method bool IsTFTBacklightOn()
  {
    var bool IsBacklightOn = false;
    $if !$prototyper
      native( IsBacklightOn )
      {
        IsBacklightOn = display_is_tft_backlight_on();
      }
    $else
      IsBacklightOn = true;
    $endif
    return IsBacklightOn;
  }

  $rect <910,787,1110,827>
  property Enum::OperationMode OperationMode;

  $rect <910,837,1110,877>
  onset OperationMode
  {
    if( pure OperationMode != value )
    {
      pure OperationMode = value;
      $if !$prototyper
        native( value )
        {
          ew_set_operation_mode( value );
        }
      $endif
    }
  }

  $rect <909,887,1109,927>
  onget OperationMode
  {
    $if !$prototyper
      var Enum::OperationMode Mode = Enum::OperationMode.NORMAL;
      native( Mode )
      {
        EnumOperationMode op_mode;
        if( EW_get_operation_mode( &op_mode ) )
        {
          Mode = op_mode;
        }
      }
      pure OperationMode = Mode;
    $endif

    return pure OperationMode;
  }

  $rect <685,836,895,876>
  method bool IsOperationModeReady()
  {
    var bool IsOperationModeReady;
    $if !$prototyper
      native( IsOperationModeReady )
      {
        IsOperationModeReady = ew_is_operation_mode_ready();
      }
    $else
      IsOperationModeReady = true;
    $endif
    return IsOperationModeReady;
  }

  // Inspection Mode
  note group Note7
  {
    attr Bounds = <10,740,310,1200>;
  }

  $rect <30,1080,290,1120>
  object Core::SystemEvent InspectionDisplaySystemEvent;

  $rect <30,930,290,970>
  object Core::SystemEvent InspectionModeSystemEvent;

  // Notifiy the inspection display pattern to test
  $rect <30,780,290,820>
  $output true
  method void NotifyInspectionRequest( arg Enum::InspectionMode aMode, arg Enum::InspectionDisplay aDisplayPattern )
  {
    InspectionDisplayPattern = aDisplayPattern;
    InspectionMode = aMode;
  }

  $rect <30,830,230,870>
  property Enum::InspectionMode InspectionMode = Enum::InspectionMode.NONE;

  $rect <30,880,230,920>
  onset InspectionMode
  {
    pure InspectionMode = value;
    InspectionModeSystemEvent.Trigger( null, false );
  }

  $rect <30,980,260,1020>
  property Enum::InspectionDisplay InspectionDisplayPattern;

  $rect <30,1030,290,1070>
  onset InspectionDisplayPattern
  {
    if ( pure InspectionDisplayPattern != value )
    {
      pure InspectionDisplayPattern = value;
      InspectionDisplaySystemEvent.Trigger( null, false );
    }
  }

  $rect <30,1130,250,1170>
  method void SendInspectionResponse( arg Enum::InspectionMode aMode, arg uint8 aRes )
  {
    $if !$prototyper
      native( aMode, aRes )
      {
        VI_send_inspection_response( aMode, aRes );
      }
    $endif
  }

  // Get current home type from UI
  $rect <941,70,1140,110>
  $output true
  method void NotifyLastPageRead()
  {
    $if !$prototyper
      var Enum::HomeGroup HomeGroup;
      var Enum::MeterDisplay MeterDisplaySetting;
      var Enum::NavigationView NavigationViewSetting;
      native( HomeGroup, MeterDisplaySetting, NavigationViewSetting )
      {
        HomeGroup = ew_get_last_home_group();
        MeterDisplaySetting = ew_get_meter_display_setting();
        NavigationViewSetting = ew_get_navigation_view_setting();
      }

      DeviceInterface::VehicleDevice.CurrentMeterDisplay = MeterDisplaySetting;
      switch( NavigationViewSetting )
      {
        case Enum::NavigationView.DEFAULT_VIEW: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;
        case Enum::NavigationView.TURN_BY_TURN: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_TURN_BY_TURN;
        case Enum::NavigationView.NEXT_TURN: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_NEXT_TURN;
        default: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;
      }

      switch( HomeGroup )
      {
        case Enum::HomeGroup.METER:
        {
          switch( MeterDisplaySetting )
          {
            case Enum::MeterDisplay.TACHOMETER: pure HomeType = Enum::HomeType.TACHO_VISUALIZER;
            case Enum::MeterDisplay.ECHO_METER: pure HomeType = Enum::HomeType.ECO_VISUALIZER;
            case Enum::MeterDisplay.SPEED_METER: pure HomeType = Enum::HomeType.SPEED_VISUALIZER;
            default: pure HomeType = Enum::HomeType.TACHO_VISUALIZER;
          }
        }
        case Enum::HomeGroup.NAVIGATION: pure HomeType = DeviceInterface::NavigationDevice.CurrentHome;
        case Enum::HomeGroup.VEHICLE_INFO: pure HomeType = Enum::HomeType.VEHICLE_INFO;
        default:;
      }
    $endif
  }

  // Get current home type from UI
  $rect <941,120,1140,160>
  $output true
  method void UpdateLastPage()
  {
    var Enum::HomeGroup HomeGroup;
    switch( DeviceInterface::SystemDevice.HomeType )
    {
      case Enum::HomeType.TACHO_VISUALIZER,
           Enum::HomeType.ECO_VISUALIZER,
           Enum::HomeType.SPEED_VISUALIZER: HomeGroup = Enum::HomeGroup.METER;
      case Enum::HomeType.NAVI_DEFAULT_VIEW,
           Enum::HomeType.NAVI_TURN_BY_TURN,
           Enum::HomeType.NAVI_NEXT_TURN: HomeGroup = Enum::HomeGroup.NAVIGATION;
      case Enum::HomeType.VEHICLE_INFO: HomeGroup = Enum::HomeGroup.VEHICLE_INFO;
      default: HomeGroup = Enum::HomeGroup.METER;
    }

    var Enum::NavigationView NavigationViewSetting;
    switch( DeviceInterface::NavigationDevice.CurrentHome )
    {
      case Enum::HomeType.NAVI_DEFAULT_VIEW: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
      case Enum::HomeType.NAVI_TURN_BY_TURN: NavigationViewSetting = Enum::NavigationView.TURN_BY_TURN;
      case Enum::HomeType.NAVI_NEXT_TURN: NavigationViewSetting = Enum::NavigationView.NEXT_TURN;
      default: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
    }

    var Enum::MeterDisplay MeterDisplaySetting = DeviceInterface::VehicleDevice.CurrentMeterDisplay;

    $if !$prototyper
      native( HomeGroup, NavigationViewSetting, MeterDisplaySetting )
      {
        ew_set_last_page( HomeGroup, MeterDisplaySetting, NavigationViewSetting );
      }
    $endif
  }

  $rect <940,170,1140,210>
  property Enum::HomeType HomeType;

  $rect <940,220,1140,260>
  onset HomeType
  {
    if( pure HomeType != value )
    {
      pure HomeType = value;

      var Enum::HomeGroup HomeGroup;
      switch( value )
      {
        case Enum::HomeType.TACHO_VISUALIZER,
             Enum::HomeType.ECO_VISUALIZER,
             Enum::HomeType.SPEED_VISUALIZER: HomeGroup = Enum::HomeGroup.METER;
        case Enum::HomeType.NAVI_DEFAULT_VIEW,
             Enum::HomeType.NAVI_TURN_BY_TURN,
             Enum::HomeType.NAVI_NEXT_TURN: HomeGroup = Enum::HomeGroup.NAVIGATION;
        case Enum::HomeType.VEHICLE_INFO: HomeGroup = Enum::HomeGroup.VEHICLE_INFO;
        default: HomeGroup = Enum::HomeGroup.METER;
      }

      var Enum::NavigationView NavigationViewSetting;
      switch( DeviceInterface::NavigationDevice.CurrentHome )
      {
        case Enum::HomeType.NAVI_DEFAULT_VIEW: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
        case Enum::HomeType.NAVI_TURN_BY_TURN: NavigationViewSetting = Enum::NavigationView.TURN_BY_TURN;
        case Enum::HomeType.NAVI_NEXT_TURN: NavigationViewSetting = Enum::NavigationView.NEXT_TURN;
        default: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
      }

      var Enum::MeterDisplay MeterDisplaySetting = DeviceInterface::VehicleDevice.CurrentMeterDisplay;

      $if !$prototyper
        native( HomeGroup, NavigationViewSetting, MeterDisplaySetting )
        {
          ew_set_last_page( HomeGroup, MeterDisplaySetting, NavigationViewSetting );
        }
      $endif
    }
  }

  $rect <30,620,320,660>
  object Core::SystemEvent FactoryResetCompletedSystemEvent;

  $rect <30,670,230,710>
  var bool IsRunningReset;

  $rect <770,400,970,440>
  method void SetKeyTriggerMode( arg Core::KeyCode aKey, arg Enum::KeyTriggerMode aMode )
  {
    $if !$prototyper
      native( aKey, aMode )
      {
        VI_key_set_trigger_mode( aKey, aMode );
      }
    $else
    // suppress warning
    aKey;
    aMode;
    $endif
  }

  // Interfaces for factory test
  note group Note8
  {
    attr Bounds = <750,300,990,520>;
  }

  $rect <770,450,970,490>
  method void SetMagicKeyEnabled( arg bool aEnabled )
  {
    $if !$prototyper
      native( aEnabled )
      {
        VI_key_set_magic_key_enabled( aEnabled );
      }
    $else
    aEnabled; // suppress warning
    $endif
  }

  $rect <650,620,850,660>
  method bool IsQrCodeReady()
  {
    var bool IsQrCodeReady = false;
    $if !$prototyper
      native( IsQrCodeReady )
      {
        IsQrCodeReady = ew_is_qrcode_ready();
      }
    $else
      IsQrCodeReady = true;
    $endif
    return IsQrCodeReady;
  }

  // Clock Setting
  note group Note9
  {
    attr Bounds = <450,980,1130,1200>;
  }

  $rect <460,1020,660,1060>
  method void NotifyTimeRequest()
  {
    $if !$prototyper
      native
      {
        BC_motocon_set_request_from_clock();
        BC_motocon_send_vehicle_setting_request();
      }
    $endif
  }

  $rect <670,1070,870,1110>
  var DeviceInterface::RtcTime CurrentAdjustTime;

  $rect <670,1020,870,1060>
  method void SetRtcTime( arg DeviceInterface::RtcTime aNewTime )
  {
    $if !$prototyper
      var uint16 NewTimeYear = aNewTime.Year;
      var uint8 NewTimeMonth = aNewTime.Month;
      var uint8 NewTimeDay = aNewTime.Day;
      var uint8 NewTimeHour = aNewTime.Hour;
      var uint8 NewTimeMinute = aNewTime.Minute;
      var uint8 NewTimeSecond = aNewTime.Second;

      native( NewTimeYear, NewTimeMonth, NewTimeDay, NewTimeHour, NewTimeMinute, NewTimeSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        srtc_time.year = NewTimeYear;
        srtc_time.month = NewTimeMonth;
        srtc_time.day = NewTimeDay;
        srtc_time.hour = NewTimeHour;
        srtc_time.minute = NewTimeMinute;
        srtc_time.second = NewTimeSecond;
        ew_set_rtc_time( &srtc_time );
      }
    $else
      aNewTime;
    $endif
  }

  $rect <890,1020,1090,1060>
  method void SendManualAdjTimeToMeter()
  {
    $if !$prototyper
      native
      {
        VI_clock_send_rtc_time_to_meter();
      }
    $endif
  }

  $rect <460,1070,660,1110>
  property bool IsClockAutoAdj;

  $rect <460,1110,660,1150>
  onset IsClockAutoAdj
  {
    if( pure IsClockAutoAdj != value )
    {
      // Remember the property's new value.
      pure IsClockAutoAdj = value;

      $if !$prototyper
        var bool ClockAutoAdjStatus = value;
        native( ClockAutoAdjStatus )
        {
          ew_set_clk_auto_adj( ClockAutoAdjStatus );
        }
      $endif
    }
  }

  $rect <460,1150,660,1190>
  onget IsClockAutoAdj
  {
    $if !$prototyper
      var bool ClockAutoAdjStatus;
      native( ClockAutoAdjStatus )
      {
        ClockAutoAdjStatus = EW_get_clk_auto_adj();
      }
      pure IsClockAutoAdj = ClockAutoAdjStatus;
    $endif
    return pure IsClockAutoAdj;
  }
}

$rect <20,110,220,150>
autoobject DeviceInterface::SystemDeviceClass SystemDevice;

$rect <20,300,230,340>
$output false
class NavigationDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,90,220,130>
  object Core::SystemEvent MapUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,40,220,80>
  $output true
  method void NotifyMapUpdate()
  {
    MapUpdateEvent.Trigger( null, true );
  }

  $rect <250,40,450,80>
  method bool IsMapFrameReady()
  {
    $if( !$prototyper )
      var bool IsMapFrameReady = false;
      native( IsMapFrameReady )
      {
        IsMapFrameReady = ew_navi_is_map_frame_ready();
      }
      return IsMapFrameReady;
    $else
      return false;
    $endif
  }

  $rect <230,150,430,190>
  object Core::SystemEvent CurRdUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,150,220,190>
  $output true
  method void NotifyCurRdUpdate()
  {
    CurRdUpdateEvent.Trigger( null, false );
  }

  $rect <220,190,420,230>
  object Core::SystemEvent ETAUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,190,220,230>
  $output true
  method void NotifyETAUpdate()
  {
    ETAUpdateEvent.Trigger( null, false );
  }

  $rect <220,230,420,270>
  object Core::SystemEvent DayNightModeUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,220,270>
  $output true
  method void NotifyDayNightModeUpdate()
  {
    DayNightModeUpdateEvent.Trigger( null, false );
  }

  $rect <220,270,420,310>
  object Core::SystemEvent SpeedLimitUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,270,220,310>
  $output true
  method void NotifySpeedLimitUpdate()
  {
    SpeedLimitUpdateEvent.Trigger( null, false );
  }

  $rect <220,310,420,350>
  object Core::SystemEvent NaviIncidentUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,310,220,350>
  $output true
  method void NotifyNaviEventUpdate()
  {
    NaviIncidentUpdateEvent.Trigger( null, false );
  }

  $rect <460,150,660,190>
  method DeviceInterface::NaviDataClass GetNaviData( arg Enum::NaviDataType aDataType )
  {
    var DeviceInterface::NaviDataClass NaviData = new DeviceInterface::NaviDataClass;
    $if !$prototyper
    var int32 NaviDataType = ( int32 )aDataType;

    native( NaviDataType, NaviData )
    {
      navi_data_type* navi_obj = NULL;
      #if( !UNIT_TEST_NAVI )
        navi_obj = NAVI_get_navi_obj();
      #else
        navi_obj = TEST_get_navi_obj();
      #endif

      switch( NaviDataType )
      {
        case EnumNaviDataTypeCURRENT_ROAD:
          NaviData->CurrentRoad = EwNewStringUtf8( ( const unsigned char* )navi_obj->current_road, ( int )strlen( navi_obj->current_road ) );
          break;
        case EnumNaviDataTypeETA:
          NaviData->ETA = navi_obj->eta;
          break;
        case EnumNaviDataTypeSPEED_LIMIT:
          NaviData->SpeedLimit = navi_obj->speed_limit;
          break;
        case EnumNaviDataTypeDAYNIGHT:
          NaviData->DayNightMode = navi_obj->daynight;
          break;
        case EnumNaviDataTypeNAVI_EVENT:
          {
            navi_event_stat navi_event_obj;
            bool is_event_retrieved = NAVI_get_event( &navi_event_obj );
            if( is_event_retrieved )
            {
              NaviData->NaviEventType = navi_event_obj.event_type;
              NaviData->NaviCameraType = navi_event_obj.camera_type;
              NaviData->NaviEventDist = EwNewStringUtf8( ( const unsigned char* )navi_event_obj.dist, ( int )strlen( navi_event_obj.dist ) );
              NaviData->NaviEventSpeed = EwNewStringUtf8( ( const unsigned char* )navi_event_obj.speed, ( int )strlen( navi_event_obj.speed ) );
              NaviData->NaviEventVisibility = navi_event_obj.visibility;
            }
            else
            {
              NAVI_reset_event_buffer();
              NaviData = NULL;
            }
          }
          break;
        case EnumNaviDataTypeNAVI_ROUTE_CAL_PROGRESS:
          NaviData->RouteCalProgress = navi_obj->route_cal_progress; 
          break;
        default:
          break;
      }
    }
    $else
      aDataType; // suppress warning.
    $endif

    return NaviData;

  }

  $rect <250,90,450,130>
  method bool IsRouteGuidanceStarted()
  {
    $if( !$prototyper )
      var bool IsNavigating= false;
      native( IsNavigating )
      {
        IsNavigating = ew_navi_is_route_guidance_started();
      }
      return IsNavigating;
    $else
      return false;
    $endif
  }

  $rect <220,350,420,390>
  object Core::SystemEvent NavigatingStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,350,220,390>
  $output true
  method void NotifyNavigatingStatusUpdate()
  {
    NavigatingStatusUpdateEvent.Trigger( null, false );
  }

  $rect <220,400,420,440>
  object Core::SystemEvent TbtListUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,400,220,440>
  $output true
  method void NotifyTbtListUpdate( arg int32 aNewTbtListSize )
  {
    TbtListSize = aNewTbtListSize;
    TbtListUpdateEvent.Trigger( null, false );
  }

  $rect <220,450,420,490>
  object Core::SystemEvent ActiveTbtItemUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,450,220,490>
  $output true
  method void NotifyActiveTbtItemUpdate( arg int32 aNewActiveTbtItemIdx )
  {
    ActiveTbtItemIdx = aNewActiveTbtItemIdx;
    ActiveTbtItemUpdateEvent.Trigger( null, false );
  }

  $rect <460,210,660,250>
  method DeviceInterface::NaviTbtDataClass GetNaviTbtData( arg int32 aTbtItemIdx )
  {
    var DeviceInterface::NaviTbtDataClass NaviTbtData = new DeviceInterface::NaviTbtDataClass;

    $if !$prototyper
      native( NaviTbtData, aTbtItemIdx )
      {
        #if( UNIT_TEST_NAVI )
          uint32_t list_idx;
          uint32_t icon_idx;
          uint16_t distance;
          char* dist_unit;
          char* description;
          TEST_get_navi_tbt_data( aTbtItemIdx, &list_idx, &icon_idx, &distance, &dist_unit, &description );
          NaviTbtData->ListIdx = list_idx;
          NaviTbtData->IconIdx = icon_idx;
          NaviTbtData->Distance = distance;
          NaviTbtData->DistUnit = EwNewStringUtf8( ( const unsigned char* )dist_unit, ( int )strlen( dist_unit ) );
          NaviTbtData->TbtDescription = EwNewStringUtf8( ( const unsigned char* )description, ( int )strlen( description ) );
        #endif
      }
    $else
      aTbtItemIdx; // suppress warning.
    $endif

    return NaviTbtData;
  }

  $rect <480,40,680,80>
  var int32 ActiveTbtItemIdx;

  $rect <480,90,680,130>
  var int32 TbtListSize = 0;

  $rect <710,40,910,80>
  var Enum::HomeType CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;

  $rect <460,270,660,310>
  method void StopMapFrameRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_stop_map_update();
      }
    $endif
  }

  $rect <220,510,420,550>
  object Core::SystemEvent RouteCalProgressUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,510,220,550>
  $output true
  method void NotifyRouteCalProgressUpdate()
  {
    RouteCalProgressUpdateEvent.Trigger( null, false );
  }

  $rect <220,570,420,610>
  object Core::SystemEvent ZoomLevelUpdateEventHandler;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,570,220,610>
  $output true
  method void NotifyZoomLevelUpdate( arg bool aNewZoomLevelButtonStatus )
  {
    IsZoomLevelButtonEnabled = aNewZoomLevelButtonStatus;
    ZoomLevelUpdateEventHandler.Trigger( null, false );
  }

  $rect <710,90,910,130>
  var bool IsZoomLevelButtonEnabled = true;

  $rect <230,620,430,660>
  object Core::SystemEvent DialogEventUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,620,220,660>
  $output true
  method void NotifyDialogEventUpdate()
  {
    DialogEventUpdateEvent.Trigger( null, false );
  }

  $rect <460,330,660,370>
  method Enum::NaviDialogType GetNaviDialogType()
  {
    $if !$prototyper
      var Enum::NaviDialogType NaviDialog;
      native( NaviDialog )
      {
        #if( !UNIT_TEST_NAVI )
          NaviDialog = NAVI_get_dialog_type();
        #else
          NaviDialog = TEST_navi_get_dialog_type();
        #endif
      }
      return NaviDialog;
    $else
      return Enum::NaviDialogType.DIALOG_TOTAL;
    $endif
  }

  $rect <460,380,660,420>
  method string GetNaviDialogMessage()
  {
    $if !$prototyper
      var string NaviDialogMessage;
      native( NaviDialogMessage )
      {
        char* dialog_message;
         #if( !UNIT_TEST_NAVI )
          NAVI_get_dialog_message( &dialog_message );
        #else
          TEST_navi_get_dialog_message( &dialog_message );
        #endif
        NaviDialogMessage  = EwNewStringUtf8( ( const unsigned char* )dialog_message, ( int )strlen( dialog_message ) );
      }
      return NaviDialogMessage;
    $else
      return "";
    $endif
  }

  $rect <460,430,660,470>
  method void SendSelectedDialog( arg Enum::NaviButtonType aNewButtonType )
  {
    $if !$prototyper
      var Enum::NaviButtonType ButtonType = aNewButtonType;
      native( ButtonType )
      {
        NAVI_send_selected_dialog( ButtonType );
      }
    $else
      aNewButtonType; // suppress warning.
    $endif
  }

  $rect <650,520,850,560>
  object Core::SystemEvent ViaPointUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <450,520,650,560>
  $output true
  method void NotifyViaPointUpdate( arg int32 aNewViaPointNum )
  {
    ViaPointNum = aNewViaPointNum;
    ViaPointUpdateEvent.Trigger( null, false );
  }

  $rect <710,140,910,180>
  var int32 ViaPointNum;

  $rect <690,210,890,250>
  method bool GetNaviConnectStatus()
  {
    $if( !$prototyper )
      var bool IsNaviAppConnected= false;
      native( IsNaviAppConnected )
      {
        IsNaviAppConnected = NAVI_get_connect_status();
      }
      return IsNaviAppConnected;
    $else
      return false;
    $endif
  }

  $rect <690,260,890,300>
  method bool GetNaviAppInitSettingStatus()
  {
    $if( !$prototyper )
      var bool IsNaviAppInitSettingCompleted= false;
      native( IsNaviAppInitSettingCompleted )
      {
        IsNaviAppInitSettingCompleted = NAVI_get_navi_app_setup_status();
      }
      return IsNaviAppInitSettingCompleted;
    $else
      return false;
    $endif
  }

  $rect <690,310,890,350>
  method void StopRoute()
  {
    $if !$prototyper
      native
      {
        NAVI_send_stop_route_request();
      }
    $endif
  }

  $rect <690,360,890,400>
  method void SkipNextWaypoint()
  {
    $if !$prototyper
      native
      {
        NAVI_send_skip_next_waypoint_request();
      }
    $endif
  }

  $rect <690,410,890,450>
  method void GoHome()
  {
    $if !$prototyper
      native
      {
        NAVI_send_go_home_request();
      }
    $endif
  }

  $rect <690,460,890,500>
  method void GoOffice()
  {
    $if !$prototyper
      native
      {
        NAVI_send_go_office_request();
      }
    $endif
  }

  $rect <650,570,850,610>
  object Core::SystemEvent HomeSettingUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <450,570,650,610>
  $output true
  method void NotifyHomeSettingUpdate( arg bool aNewHomeSettingStatus )
  {
    IsHomeSet = aNewHomeSettingStatus;
    HomeSettingUpdateEvent.Trigger( null, false );
  }

  $rect <920,40,1120,80>
  var bool IsHomeSet;

  $rect <920,90,1120,130>
  var bool IsOfficeSet;

  $rect <660,620,860,660>
  object Core::SystemEvent OfficeSettingUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <460,620,660,660>
  $output true
  method void NotifyOfficeSettingUpdate( arg bool aNewOfficeSettingStatus )
  {
    IsOfficeSet = aNewOfficeSettingStatus;
    OfficeSettingUpdateEvent.Trigger( null, false );
  }

  $rect <920,210,1120,250>
  method void ZoomInRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_send_zoom_in_request();
      }
    $endif
  }

  $rect <920,260,1120,300>
  method void ZoomOutRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_send_zoom_out_request();
      }
    $endif
  }
}

$rect <20,340,230,380>
autoobject DeviceInterface::NavigationDeviceClass NavigationDevice;

$rect <260,300,500,340>
$output false
class MediaManagerDeviceClass : Templates::DeviceClass
{
  $rect <30,20,230,60>
  property string Title;

  $rect <30,60,230,100>
  onset Title
  {
    // Get song title when receiving from media manager or UI initialization.
    if( IsTitleReceived || IsInit )
    {
      // Remember the property's new value.
      pure Title = value;
    }
    else
    {
      // Fail to receive song title, show "---".
      pure Title = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Title;
  }

  $rect <250,20,450,60>
  property string Album;

  $rect <250,60,450,100>
  onset Album
  {
    // Get album when receiving from media manager or UI initialization.
    if( IsAlbumReceived || IsInit )
    {
      // Remember the property's new value.
      pure Album = value;
    }
    else
    {
      // Fail to receive album, show "---".
      pure Album = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Album;
  }

  $rect <480,20,680,60>
  property string Artist;

  $rect <480,60,680,100>
  onset Artist
  {
    // Get artist when receiving from media manager or UI initialization.
    if( IsArtistReceived || IsInit )
    {
      // Remember the property's new value.
      pure Artist = value;
    }
    else
    {
      // Fail to receive artist, show "---".
      pure Artist = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Artist;
  }

  $rect <720,60,920,100>
  property int32 DurationTimeSec = 0;

  $rect <720,470,940,510>
  method void SendRemoteCommand( arg Enum::MusicControlType MusicCommandType )
  {
    $if !$prototyper
    native( MusicCommandType )
    {
      ams_remote_command cmd = AMS_REMOTE_COMMAND_CNT;

      switch( MusicCommandType )
      {
        case EnumMusicControlTypePlay:
          cmd = AMS_REMOTE_COMMAND_PLAY;
          break;
        case EnumMusicControlTypePause:
          cmd = AMS_REMOTE_COMMAND_PAUSE;
          break;
        case EnumMusicControlTypeNextTrack:
          cmd = AMS_REMOTE_COMMAND_NEXT_TRACK;
          break;
        case EnumMusicControlTypePrevTrack:
          cmd = AMS_REMOTE_COMMAND_PREVIOUS_TRACK;
          break;
        case EnumMusicControlTypeVolumeUp:
          cmd = AMS_REMOTE_COMMAND_VOLUME_UP;
          break;
        case EnumMusicControlTypeVolumeDown:
          cmd = AMS_REMOTE_COMMAND_VOLUME_DOWN;
          break;
        default:
          break;
      }
      ew_send_command( cmd );
    }
    $endif
  }

  $rect <720,20,920,60>
  property int32 ElapsedTimeSec = 0;

  // An interface to set/get data from device
  note group Note1
  {
    attr Bounds = <10,430,1170,540>;
  }

  $rect <350,240,550,280>
  $output true
  method void NotifyTitleChanged( arg string aTitle )
  {
    trace "NotifyTitleChanged: " + aTitle;
    IsTitleReceived = true;
    Title = aTitle;
  }

  $rect <350,320,550,360>
  $output true
  method void NotifyArtistChanged( arg string aArtist )
  {
    trace "NotifyArtistChanged: " + aArtist;
    IsArtistReceived = true;
    Artist = aArtist;
  }

  $rect <350,280,550,320>
  $output true
  method void NotifyAlbumChanged( arg string aAlbum )
  {
    trace "NotifyAlbumChanged: " + aAlbum;
    IsAlbumReceived = true;
    Album = aAlbum;
  }

  $rect <50,470,250,510>
  method int32 GetPlayBackStateInfo()
  {
    var int32 PlayBackState = 0;
    $if !$prototyper
    native ( PlayBackState )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      PlayBackState = mp_state->playback_state;
    }
    $endif
    return PlayBackState;
  }

  $rect <270,470,470,510>
  method void GetPlaybackInfo()
  {
    var int32 ela_time = 0;
    var int32 dur = 0;
    $if !$prototyper
    native ( ela_time, dur )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      ela_time = mp_state->current_elapsed_time_sec;
      dur = mp_state->duration_sec;
    }
    $endif
    ElapsedTimeSec = ela_time;
    DurationTimeSec = dur;
  }

  $rect <500,470,700,510>
  method void GetTrackInfo()
  {
    var string media_artist = "";
    var string media_album = "";
    var string media_title = "";
    $if !$prototyper
    native ( media_artist, media_album, media_title )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      media_artist = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_artist, ( int )strlen( mp_state->str.track_artist ) );
      media_album = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_album, ( int )strlen( mp_state->str.track_album ) );
      media_title = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_title, ( int )strlen( mp_state->str.track_title ) );
    }
    $endif
    Artist = media_artist;
    Album = media_album;
    Title = media_title;
  }

  $rect <720,240,920,280>
  var bool IsInit = false;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,280,320,320>
  $output true
  method void NotifyPlayBackTimeChanged( arg int32 aElapsedTimeSec, arg int32 aDurationTimeSec )
  {
    trace "ElapsedTime: ", aElapsedTimeSec;
    trace "Duration: ", aDurationTimeSec;
    ElapsedTimeSec = aElapsedTimeSec;
    DurationTimeSec = aDurationTimeSec;

    NotifyPlayBackTimeChangedSystemEvent.Trigger( null, false );
  }

  $rect <30,240,320,280>
  object Core::SystemEvent NotifyPlayBackTimeChangedSystemEvent;

  $rect <720,280,920,320>
  var bool IsTitleReceived = false;

  $rect <720,320,920,360>
  var bool IsAlbumReceived = false;

  $rect <720,360,920,400>
  var bool IsArtistReceived = false;

  $rect <50,560,250,600>
  object Core::SystemEvent NotifyMotoConMusicUpdatedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,560,460,600>
  $output true
  method void NotfiyMotoConMusicInfoUpdated()
  {
    IsTitleReceived = true;
    IsAlbumReceived = true;
    IsArtistReceived = true;
    NotifyMotoConMusicUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <470,610,670,650>
  method bool IsAmsConnected()
  {
    $if !$prototyper
      var bool AmsConnected = false;
      native( AmsConnected )
      {
        AmsConnected = BC_ams_is_ams_connected();
      }
      return AmsConnected;
    $else
      return false;
    $endif
  }

  $rect <50,610,250,650>
  object Core::SystemEvent NotifyAmsBleConnectedStatusSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,610,460,650>
  $output true
  method void NotifyAmsBleConnectedStatusChanged()
  {
    NotifyAmsBleConnectedStatusSystemEvent.Trigger( null, false );
  }

  $rect <50,660,250,700>
  object Core::SystemEvent NotifyMediaVolumeUpdateSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,660,460,700>
  $output true
  method void NotifyMediaVolumeUpdated()
  {
    NotifyMediaVolumeUpdateSystemEvent.Trigger( null, false );
  }

  $rect <960,470,1160,510>
  method float GetVolume()
  {
    var float Volume;
    $if !$prototyper
    native ( Volume )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      Volume = mp_state->playback_volume;
    }
    $endif
    return Volume;

  }
}

$rect <261,344,461,384>
autoobject DeviceInterface::MediaManagerDeviceClass MediaManagerDevice;

$rect <750,70,950,110>
$output false
class BluetoothDeviceClass : Templates::DeviceClass
{
  // BT related properties
  note group Note1
  {
    attr Bounds = <10,10,1600,260>;
  }

  // Interfaces to react to BT system events
  note group Note2
  {
    attr Bounds = <9,280,1690,450>;
  }

  // Interfaces to perform BT operations on device
  note group Note3
  {
    attr Bounds = <10,470,840,690>;
  }

  $rect <290,510,503,550>
  method void GetPairedDeviceAtItem( arg int32 aItemNo )
  {
    $if !$prototyper
      var string DevName;
      var bool   IsConnected;

      native( aItemNo, DevName, IsConnected )
      {
        uint8_t* device_name;
        bool     is_connected;
        ew_bt_get_paired_device_at_index( aItemNo, &device_name, &is_connected );
        DevName = EwNewStringUtf8( (const unsigned char*)device_name, (int)strlen( (char*)device_name ) );
        IsConnected = is_connected;
      }
      PairedDeviceObj.DeviceName = DevName;
      PairedDeviceObj.IsConnected = IsConnected;
    $else
      if( aItemNo > 0 )
      {
        // empty body to suppress warning
      }
    $endif
  }

  $rect <30,380,290,420>
  object Core::SystemEvent BtcPairingChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,330,290,370>
  $output true
  method void NotifyBtcPairingStateChanged( arg Enum::BtcPairingState aState )
  {
    BtcPairingState = aState;
    BtcPairingChangedSystemEvent.Trigger( null, false );
  }

  $rect <302,330,502,370>
  property Enum::BtcPairingState BtcPairingState;

  $rect <250,50,450,90>
  property bool Discoverable = false;

  $rect <250,100,450,140>
  onset Discoverable
  {
    if( pure Discoverable != value )
    {
      pure Discoverable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_discoverable( ( bool )value );
        }
      $endif
    }
  }

  $rect <250,150,450,190>
  onget Discoverable
  {
    $if !$prototyper
      var bool IsDiscoverable = false;
      native( IsDiscoverable )
      {
        IsDiscoverable = ew_bt_get_discoverable();
      }
      return IsDiscoverable;
    $else
      return pure Discoverable;
    $endif
  }

  $rect <30,50,240,90>
  property bool BluetoothEnable = false;

  $rect <30,100,240,140>
  onset BluetoothEnable
  {
    trace "OnSetBluetoothEnable ", value;

    if( pure BluetoothEnable != value )
    {
      pure BluetoothEnable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_enable( ( bool )value );
        }
      $endif
    }

    notifyobservers ^BluetoothEnable;
  }

  $rect <30,150,240,190>
  onget BluetoothEnable
  {
    return pure BluetoothEnable;

  }

  $rect <460,50,660,90>
  property bool AutoConnect;

  $rect <460,100,660,140>
  onset AutoConnect
  {
    pure AutoConnect = value;
    $if !$prototyper
      native
      {
        ew_bt_set_autoconnect( ( bool )value );
      }
    $endif
  }

  $rect <460,150,660,190>
  onget AutoConnect
  {
    $if !$prototyper
      var bool IsAutoConnect = false;
      native( IsAutoConnect )
      {
        IsAutoConnect = ew_bt_get_autoconnect();
      }
      return IsAutoConnect;
    $else
      return pure AutoConnect;
    $endif
  }

  $rect <670,50,880,90>
  property int32 PairedDeviceNum;

  $rect <670,100,880,140>
  onget PairedDeviceNum
  {
    $if !$prototyper
      var int32 PairedDevNum = 0;
      native( PairedDevNum )
      {
        PairedDevNum = ew_bt_get_paired_device_num();
      }
      return PairedDevNum;
    $else
      return pure PairedDeviceNum;
    $endif

  }

  $rect <40,630,260,670>
  method void UnpairDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_unpair_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <290,570,503,610>
  object DeviceInterface::BluetoothPairedDeviceInfo PairedDeviceObj;

  $rect <30,200,240,240>
  method void GetBluetoothEnable()
  {
    $if !$prototyper
      var bool enable = false;
      native( enable )
      {
        enable = ew_bt_get_enable();
      }
      BluetoothEnable = enable;
    $endif
  }

  $rect <1108,50,1338,90>
  property string LocalDeviceName;

  $rect <1108,100,1338,140>
  onget LocalDeviceName
  {
    var string LocalDevName;
    $if !$prototyper
      native( LocalDevName )
      {
        uint8_t* device_name;
        ew_bt_get_local_device_name( &device_name );
        LocalDevName = EwNewStringUtf8( (const unsigned char*)device_name, (int)strlen( (char*)device_name ) );
      }
    $else
      LocalDevName = "Prototyper";
    $endif
    return LocalDevName;
  }

  $rect <1350,50,1580,90>
  property string LocalDeviceAddress;

  $rect <1350,100,1580,140>
  onget LocalDeviceAddress
  {
    $if !$prototyper
      var string DeviceAddr = "";
      native( DeviceAddr )
      {
        uint8_t dev_addr[BT_DEVICE_ADDRESS_LEN + 1];
        ew_bt_get_local_device_address( dev_addr );
        dev_addr[BT_DEVICE_ADDRESS_LEN + 1] = NULL;
        DeviceAddr = EwNewStringAnsi( dev_addr );
      }
      return DeviceAddr;
    $else
      return pure LocalDeviceAddress;
    $endif
  }

  $rect <40,510,260,550>
  method void ConnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_connect_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( aPairedDeviceIndex > 0 )
      {
        // empty body
      }
    $endif
  }

  $rect <290,630,490,670>
  method bool IsBlePairedDevice( arg int32 aPairedDeviceIndex )
  {
    var bool IsBlePairedDevice = false;
    $if !$prototyper
      native ( aPairedDeviceIndex, IsBlePairedDevice )
      {
        IsBlePairedDevice = ew_bt_is_ble_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( "" == aPairedDeviceIndex )
      {
        // empty body
      }
    $endif
    return IsBlePairedDevice;
  }

  $rect <40,570,260,610>
  method void DisconnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_disconnect_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <891,50,1091,90>
  property bool IsMaxPairedDevice;

  $rect <891,100,1091,140>
  onget IsMaxPairedDevice
  {
    $if !$prototyper
      var bool is_max_paired_device = false;
      native( is_max_paired_device )
      {
        is_max_paired_device = ew_bt_is_max_paired_device_num();
      }
      return is_max_paired_device;
    $else
      return pure IsMaxPairedDevice;
    $endif
  }

  $rect <40,806,240,846>
  property Enum::BtFwStatus BtFwStatus;

  $rect <40,860,240,900>
  onset BtFwStatus
  {
    if ( pure BtFwStatus != value )
    {
      pure BtFwStatus = value;
      notifyobservers ^BtFwStatus;
    }

  }

  $rect <40,750,240,790>
  $output true
  method void NotifyBtFwStatus( arg Enum::BtFwStatus status, arg string version )
  {
    trace "NotifyBtFWStatus: ", status;
    trace "BtFwVer: ", version;

    BtFwStatus = status;
  }

  // Interfaces to BT firmware update
  note group Note4
  {
    attr Bounds = <10,710,320,920>;
  }

  $rect <530,510,750,550>
  property bool RefreshPairedDeviceList;

  $rect <530,570,790,610>
  onset RefreshPairedDeviceList
  {
    pure RefreshPairedDeviceList = value;
    notifyobservers ^RefreshPairedDeviceList;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <760,330,1110,370>
  $output true
  method void NotifyPairedDeviceConnectionStatusUpdated()
  {
    RefreshPairedDeviceList = true;
    PairedDeviceUpdatedSystemEvent.Trigger( null, false );
  }

  // Interfaces of BLE
  note group Note5
  {
    attr Bounds = <860,470,1640,730>;
  }

  // MotoCon connection status
  note group Note6
  {
    attr Bounds = <350,710,660,920>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <881,520,1130,560>
  $output true
  method void NotifyBlePairingStateChanged()
  {
    BlePairingStateChangedEvent.Trigger( null, false );
  }

  $rect <880,570,1130,610>
  object Core::SystemEvent BlePairingStateChangedEvent;

  $rect <1150,620,1360,660>
  method void SetBleAdvertisement( arg bool aEnable )
  {
    $if !$prototyper
      native( aEnable )
      {
        BTM_set_ble_advertisement( aEnable );
      }
    $else
      trace "SetBleAdvertisement ", aEnable;
    $endif
  }

  $rect <670,150,870,190>
  method bool IsBtConnected()
  {
    var bool BtConnected = false;

    $if !$prototyper
      native( BtConnected )
      {
        BtConnected = BTM_is_bt_connected();
      }
    $endif

    return BtConnected;
  }

  $rect <1150,670,1360,710>
  method int32 GetBlePairingFailCount()
  {
    var int32 FailCount = 0;

    $if !$prototyper
    native( FailCount )
    {
      FailCount = BTM_get_ble_pairing_fail_count();
    }
    $endif

    return FailCount;
  }

  $rect <1370,520,1620,560>
  method bool IsMotoconConnected()
  {
    $if !$prototyper
      var bool MotoconConnected = false;
      native( MotoconConnected )
      {
        MotoconConnected = BC_motocon_is_connected();
      }
      return MotoconConnected;
    $else
      return false;
    $endif
  }

  $rect <1370,570,1620,610>
  method string GetBleConnectedDeviceName()
  {
    var string BleConnectedDeviceName = "";

    $if !$prototyper
      native( BleConnectedDeviceName )
      {
        uint8_t* ble_connected_device_name;
        bool has_ble_connected_device = BTM_get_ble_connected_device_name( &ble_connected_device_name );
        if( has_ble_connected_device )
        {
          BleConnectedDeviceName = EwNewStringUtf8( (const unsigned char*)ble_connected_device_name, (int)strlen( (char*)ble_connected_device_name ) );
        }
      }
    $endif

    return BleConnectedDeviceName;
  }

  $rect <880,620,1080,660>
  property Enum::BlePairingState BlePairingState;

  $rect <880,670,1080,710>
  onget BlePairingState
  {
    var Enum::BlePairingState State;

    $if !$prototyper
      native( State )
      {
        State = ew_get_ble_pairing_state();
      }
    $endif

    return State;
  }

  $rect <1150,520,1350,560>
  property uint32 BlePincode;

  $rect <1150,570,1350,610>
  onget BlePincode
  {
    $if !$prototyper
      var uint32 Pincode = 0;
      native( Pincode )
      {
        Pincode = ew_get_ble_pincode();
      }
      return Pincode;
    $else
      return pure BlePincode;
    $endif
  }

  $rect <380,760,630,800>
  $output true
  method void NotifyMotoConEventReceived( arg Enum::MotoConRxEvent aEvent )
  {
    var DeviceInterface::MotoConContext MotoConContext = new DeviceInterface::MotoConContext;
    MotoConContext.RxEvent = aEvent;
    MotoConSystemEvent.Trigger( MotoConContext, false );
  }

  $rect <380,810,630,850>
  object Core::SystemEvent MotoConSystemEvent;

  $rect <760,380,1110,420>
  object Core::SystemEvent PairedDeviceUpdatedSystemEvent;

  $rect <1130,380,1370,420>
  property Enum::BtDeviceConnectionResult ConnectPairedDeviceResult;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <1130,330,1370,370>
  $output true
  method void NotifyBtcConnectionResult( arg Enum::BtDeviceConnectionResult aResult )
  {
    ConnectPairedDeviceResult = aResult;
    BtcConnectionResultSystemEvent.Trigger( null, false );
  }

  $rect <1380,380,1670,420>
  object Core::SystemEvent BtcConnectionResultSystemEvent;

  $rect <300,380,500,420>
  method uint32 GetBtcPasskey()
  {
    var uint32 Passkey;
    $if !$prototyper
      native( Passkey )
      {
        Passkey = ew_get_btc_passkey();
      }
    $endif
    return Passkey;
  }

  $rect <510,330,740,370>
  method string GetBtcPairingDeviceName()
  {
    var string PairingDeviceName;
    $if !$prototyper
      native( PairingDeviceName )
      {
        uint8_t* btc_pairing_device_name;
        ew_bt_get_btc_connecting_device_name( &btc_pairing_device_name );
        PairingDeviceName = EwNewStringUtf8( (const unsigned char*)btc_pairing_device_name, (int)strlen( (char*)btc_pairing_device_name ) );
      }
    $else
      PairingDeviceName = "(Device name)";
    $endif
    return PairingDeviceName;
  }
}

$rect <750,110,950,150>
autoobject DeviceInterface::BluetoothDeviceClass BluetoothDevice;

$rect <750,150,950,190>
$output false
class BluetoothPairedDeviceInfo
{
  $rect <20,10,220,50>
  var string DeviceName;

  $rect <20,60,220,100>
  var bool IsConnected;
}

$rect <20,150,220,190>
$output false
class RtcTime
{
  $rect <20,10,220,50>
  var uint16 Year;

  $rect <20,50,220,90>
  var uint8 Month;

  $rect <20,90,220,130>
  var uint8 Day;

  $rect <20,130,220,170>
  var uint8 Hour;

  $rect <20,170,220,210>
  var uint8 Minute;

  $rect <20,210,220,250>
  var uint8 Second;
}

$rect <500,110,700,150>
$output false
class VehicleDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,100,310,140>
  object Core::SystemEvent DDModeStateChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,50,260,90>
  $output true
  method void NotifyDDModeStateChanged()
  {
    DDModeStateChangedSystemEvent.Trigger( null, false );
  }

  // Driver Distraction Mode System Event
  note group Note2
  {
    attr Bounds = <0,0,560,160>;
  }

  $rect <320,50,540,90>
  property bool DDModeActivated;

  $rect <320,100,540,140>
  onget DDModeActivated
  {
    $if !$prototyper
      var bool IsActivated = false;

      native( IsActivated )
      {
        IsActivated = VI_is_dd_mode_activated();
      }

      return IsActivated;
    $else
      return pure DDModeActivated;
    $endif
  }

  $rect <20,180,260,220>
  method bool IsVehicleFunctionSupported( arg Enum::VehicleSupportedFunction aVehicleFeature )
  {
    var bool IsSupported = false;

    $if !$prototyper
      var int32 FeatureId = (int32)aVehicleFeature;
      native( IsSupported, FeatureId )
      {
        IsSupported = VI_is_function_supported( FeatureId );
      }
    $else
      // enable pressure in the unit setting for screenshot
      if( Enum::VehicleSupportedFunction.TIRE_FRONT == aVehicleFeature )
      {
        IsSupported = true;
      }
    $endif

    return IsSupported;
  }

  $rect <280,180,480,220>
  method void SetData( arg Enum::VehicleTxType aVehicleTxType, arg uint32 aData )
  {
    $if !$prototyper
      var int32 TxTypeId = ( int32 )aVehicleTxType;
      native( aData, TxTypeId )
      {
        VI_set_tx_data( TxTypeId, aData );
      }
    $else
      trace "set vi tx data ", aVehicleTxType, " ", aData;
    $endif
  }

  $rect <280,230,480,270>
  method DeviceInterface::VehicleDataClass GetData( arg Enum::VehicleRxType aVehicleRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;

    $if !$prototyper
      if( Enum::VehicleRxType.FUEL_RATE_INSTANT == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_AVERAGE == aVehicleRxType ||
          Enum::VehicleRxType.ODOMETER_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP1_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP2_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_CONSUMPTION == aVehicleRxType ||
          Enum::VehicleRxType.AIR_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.COOLANT_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.BATTERY_VOLTAGE == aVehicleRxType ||
          Enum::VehicleRxType.F_TRIP == aVehicleRxType )
      {
        VehicleData.DataType = Enum::DataType.FLOAT;
      }

      var int32 RxTypeId = ( int32 )aVehicleRxType;
      var bool  Valid = false;

      if( Enum::DataType.FLOAT == VehicleData.DataType )
      {
        var float RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          float rx_data = 0;
          Valid = VI_get_rx_data_float( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataFloat = RxData;
      }
      else
      {
        var uint32 RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          uint32_t rx_data = 0;
          Valid = VI_get_rx_data_uint( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataUInt32 = RxData;
      }

      VehicleData.Valid = Valid;
    $else
      // suppress warning
      if( ( int32 )aVehicleRxType >= 0 )
      {
        // empty
      }
    $endif

    return VehicleData;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,260,270>
  $output true
  method void NotifyDataReceived( arg Enum::VehicleRxType aRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;
    VehicleData.RxType = aRxType;
    VehicleDataReceivedSystemEvent.Trigger( VehicleData, false );
  }

  // This object represents an individual system event.
  $rect <20,280,260,320>
  object Core::SystemEvent VehicleDataReceivedSystemEvent;

  $rect <20,330,220,370>
  var Enum::MeterDisplay CurrentMeterDisplay = Enum::MeterDisplay.TACHOMETER;

  $rect <20,380,220,420>
  var Enum::MileageSettingItem CurrentMileageSetting;

  $rect <20,430,220,470>
  var Enum::FuelSettingItem CurrentFuelSetting;

  $rect <20,480,220,520>
  var Enum::PressureSettingItem CurrentPressureSetting;

  $rect <20,530,220,570>
  var Enum::TemperatureSettingItem CurrentTempSetting;

  $rect <20,580,220,620>
  var Enum::VehicleSupportedFunction CurrentVehicleFunction;

  $rect <280,280,480,320>
  method uint32 ClampDataUInt32( arg uint32 aData, arg uint32 aMin, arg uint32 aMax )
  {
    if( aData < aMin )
    {
      aData = aMin;
    }
    else if( aData > aMax )
    {
      aData = aMax;
    }
    else
    {
      // empty
    }
    return aData;
  }

  $rect <280,330,480,370>
  method float ClampDataFloat( arg float aData, arg float aMin, arg float aMax )
  {
    if( aData < aMin )
    {
      aData = aMin;
    }
    else if( aData > aMax )
    {
      aData = aMax;
    }
    else
    {
      // empty
    }
    return aData;
  }

  $rect <280,380,480,420>
  method float RoundDownDataFloat( arg float aData, arg float aResolution )
  {
    return ( (int32)( aData / aResolution ) ) * aResolution;

  }

  $rect <600,40,800,80>
  property Enum::MileageSettingItem MileageUnit;

  $rect <600,80,800,120>
  onset MileageUnit
  {
    if( pure MileageUnit != value )
    {
      pure MileageUnit = value;
    }
  }

  $rect <600,120,800,160>
  onget MileageUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.MILEAGE_UNIT );
    if( Enum::MileageSettingItem.MILE == VehicleData.DataUInt32 )
    {
      pure MileageUnit = Enum::MileageSettingItem.MILE;
    }
    else
    {
      pure MileageUnit = Enum::MileageSettingItem.KM;
    }

    return pure MileageUnit;
  }

  $rect <830,40,1070,80>
  property Enum::MeterFuelConsumptionUnit FuelConsumptionUnit;

  $rect <830,80,1070,120>
  onset FuelConsumptionUnit
  {
    if ( pure FuelConsumptionUnit == value )
    {
      pure FuelConsumptionUnit = value;
    }
  }

  $rect <830,120,1070,160>
  onget FuelConsumptionUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_CONSUMPTION_UNIT );
    if( (uint32)Enum::MeterFuelConsumptionUnit.TOTAL > VehicleData.DataUInt32 )
    {
      pure FuelConsumptionUnit = (Enum::MeterFuelConsumptionUnit)VehicleData.DataUInt32;
    }
    return pure FuelConsumptionUnit;
  }

  $rect <610,250,830,290>
  property string AvgSpeedStr;

  $rect <610,290,830,330>
  onget AvgSpeedStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.AVERAGE_SPEED );
    if( VehicleData.Valid )
    {
      // convert unit from km to mile
      if( Enum::MileageSettingItem.MILE == MileageUnit )
      {
        VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
      }
      VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_AVERAGE_SPEED );
      pure AvgSpeedStr = string( VehicleData.DataUInt32, 0, 1 );
    }
    else
    {
      pure AvgSpeedStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure AvgSpeedStr;
  }

  $rect <610,350,830,390>
  property string AvgFuelRateStr;

  $rect <610,390,830,430>
  onget AvgFuelRateStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_AVERAGE );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelRate( VehicleData.DataFloat );

      switch( FuelConsumptionUnit )
      {
        case Enum::MeterFuelConsumptionUnit.KM_PER_LITER:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_RATE_KM_PER_LITER );
        }
        case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL,
             Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_AVERAGE_FUEL_MPG );
        }
        case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_FUEL_RATE_LITER_PER_100KM, Settings::MAX_FUEL_RATE_LITER_PER_100KM );
        }
        default:;
      }

      VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
      pure AvgFuelRateStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure AvgFuelRateStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure AvgFuelRateStr;
  }

  $rect <610,560,830,600>
  property string FuelConStr;

  $rect <610,600,830,640>
  onget FuelConStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_CONSUMPTION );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelCons( VehicleData.DataFloat );
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_CONSUMPTION );
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
      pure FuelConStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure FuelConStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure FuelConStr;
  }

  $rect <870,250,1080,290>
  property string TripTimeHourStr;

  $rect <870,290,1080,330>
  onget TripTimeHourStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TRIP_TIME );
    if( VehicleData.Valid )
    {
      var uint32 TripTimeHour = VehicleData.DataUInt32 / 3600;
      if( Settings::MAX_TRIP_TIME_HOUR < TripTimeHour )
      {
        TripTimeHour = Settings::MAX_TRIP_TIME_HOUR;
      }
      pure TripTimeHourStr = string( TripTimeHour );
    }
    else
    {
      pure TripTimeHourStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure TripTimeHourStr;
  }

  $rect <870,350,1090,390>
  property string TripTimeMinuteStr;

  $rect <870,390,1090,430>
  onget TripTimeMinuteStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TRIP_TIME );
    if( VehicleData.Valid )
    {
      var uint32 TripTimeHour = VehicleData.DataUInt32 / 3600;
      if( Settings::MAX_TRIP_TIME_HOUR < TripTimeHour )
      {
        TripTimeHour = Settings::MAX_TRIP_TIME_HOUR;
      }
      
      var uint32 TripTimeMinute = ( VehicleData.DataUInt32 / 60 ) - ( TripTimeHour ) * 60;
      if( Settings::MAX_TRIP_TIME_MINUTE < TripTimeMinute )
      {
        TripTimeMinute =  Settings::MAX_TRIP_TIME_MINUTE;
      }
      pure TripTimeMinuteStr = string( TripTimeMinute, 2 );
    }
    else
    {
      pure TripTimeMinuteStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure TripTimeMinuteStr;
  }

  // Unit Setting
  note group UnitSettingNote
  {
    attr Bounds = <580,0,1590,180>;
  }

  $rect <1090,40,1300,80>
  property Enum::TemperatureSettingItem TemperatureUnit;

  $rect <1090,80,1300,120>
  onset TemperatureUnit
  {
    if( pure TemperatureUnit != value )
    {
      pure TemperatureUnit = value;
    }
  }

  $rect <1090,120,1300,160>
  onget TemperatureUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TEMPERATURE_UNIT );
    pure TemperatureUnit = (Enum::TemperatureSettingItem)VehicleData.DataUInt32;
    return pure TemperatureUnit;
  }

  $rect <1130,250,1380,290>
  property string CoolantTemperatureStr;

  $rect <1130,290,1380,330>
  onget CoolantTemperatureStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.COOLANT_TEMPERATURE );
    if( VehicleData.Valid )
    {
      var float CoolantTemperature;
      if( Enum::TemperatureSettingItem.TEMP_F == TemperatureUnit )
      {
        CoolantTemperature = VehicleData.DataFloat * 1.8 + 32;
        CoolantTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( CoolantTemperature, Settings::MIN_TEMPERATURE_DEG_F, Settings::MAX_TEMPERATURE_DEG_F );
      }
      else
      {
        CoolantTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_TEMPERATURE_DEG_C, Settings::MAX_TEMPERATURE_DEG_C );
      }

      CoolantTemperature = math_floor( CoolantTemperature );
      pure CoolantTemperatureStr = string( CoolantTemperature, 0, 0 );
    }
    else
    {
      pure CoolantTemperatureStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure CoolantTemperatureStr;
  }

  $rect <610,450,830,490>
  property string InstantFuelRateStr;

  $rect <610,490,830,530>
  onget InstantFuelRateStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_INSTANT );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelRate( VehicleData.DataFloat );
      switch( FuelConsumptionUnit )
      {
        case Enum::MeterFuelConsumptionUnit.KM_PER_LITER:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_RATE_KM_PER_LITER );
        }
        case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL,
             Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_AVERAGE_FUEL_MPG );
        }
        case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_FUEL_RATE_LITER_PER_100KM, Settings::MAX_FUEL_RATE_LITER_PER_100KM );
        }
        default:;
      }
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
      pure InstantFuelRateStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure InstantFuelRateStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure InstantFuelRateStr;
  }

  $rect <610,710,830,750>
  method float ConvertFuelCons( arg float aFuelCons )
  {
    var float ConvertedFuelCons = aFuelCons;

    switch( FuelConsumptionUnit )
    {
      case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL: ConvertedFuelCons = aFuelCons * Unit::LITER_TO_USGAL_SCALE;
      case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL: ConvertedFuelCons = aFuelCons * Unit::LITER_TO_IMPERIAL_GAL_SCALE;
      default:;
    }

    return ConvertedFuelCons;
  }

  $rect <870,450,1090,490>
  property string RangeStr;

  $rect <870,490,1090,530>
  onget RangeStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.RANGE_DISTANCE );
    if( VehicleData.Valid )
    {
      // convert unit from km to mile
      if( Enum::MileageSettingItem.MILE == MileageUnit )
      {
        VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
      }
      VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_RANGE );
      pure RangeStr = string( VehicleData.DataUInt32, 0, 1 );
    }
    else
    {
      pure RangeStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure RangeStr;
  }

  $rect <870,560,1090,600>
  property string BatteryStr;

  $rect <870,600,1090,640>
  onget BatteryStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.BATTERY_VOLTAGE );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_BATTERY_VOLTAGE, Settings::MAX_BATTERY_VOLTAGE );
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
      pure BatteryStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure BatteryStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure BatteryStr;
  }

  $rect <1330,40,1530,80>
  property Enum::PressureSettingItem PressureUnit;

  $rect <1330,80,1530,120>
  onset PressureUnit
  {
    if( pure PressureUnit != value )
    {
      pure PressureUnit = value;
    }
  }

  $rect <1330,120,1530,160>
  onget PressureUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.PRESSURE_UNIT );
    pure PressureUnit = (Enum::PressureSettingItem)VehicleData.DataUInt32;
    return pure PressureUnit;
  }

  // Value String
  note group UnitSettingNote1
  {
    attr Bounds = <580,200,1590,780>;
  }

  $rect <610,660,830,700>
  method float ConvertFuelRate( arg float aFuelRate )
  {
    var float ConvertedFuelRate = aFuelRate;

    switch( FuelConsumptionUnit )
    {
      case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL: ConvertedFuelRate = aFuelRate * Unit::KM_L_TO_US_GALLON_SCALE;
      case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL: ConvertedFuelRate = aFuelRate * Unit::KM_L_TO_IMPERIAL_GALLON_SCALE;
      case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
      {
        if( 0.0 < aFuelRate )
        {
          ConvertedFuelRate = Unit::L_100KM_SCALE_TO_KM_L / aFuelRate;
        }
        else
        {
          ConvertedFuelRate = Settings::MAX_FUEL_CONSUMPTION;
        }
      }
      default:;
    }

    return ConvertedFuelRate;
  }

  $rect <1130,350,1380,390>
  property string AirTemperatureStr;

  $rect <1130,390,1380,430>
  onget AirTemperatureStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.AIR_TEMPERATURE );
    if( VehicleData.Valid )
    {
      var float AirTemperature;
      if( Enum::TemperatureSettingItem.TEMP_F == TemperatureUnit )
      {
        AirTemperature = VehicleData.DataFloat * 1.8 + 32;
        AirTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( AirTemperature, Settings::MIN_TEMPERATURE_DEG_F, Settings::MAX_TEMPERATURE_DEG_F );
      }
      else
      {
        AirTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_TEMPERATURE_DEG_C, Settings::MAX_TEMPERATURE_DEG_C );
      }

      AirTemperature = math_floor( AirTemperature );
      pure AirTemperatureStr = string( AirTemperature, 0, 0 );
    }
    else
    {
      pure AirTemperatureStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure AirTemperatureStr;
  }

  $rect <1130,450,1350,490>
  property string CruiseSpeedStr;

  $rect <1130,490,1350,530>
  onget CruiseSpeedStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.CRUISE_SPEED );
    if( VehicleData.Valid )
    {
      // convert unit from km to mile
      if( Enum::MileageSettingItem.MILE == MileageUnit )
      {
        VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
      }
      VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_CRUISE_SPEED );
      pure CruiseSpeedStr = string( VehicleData.DataUInt32, 0, 1 );
    }
    else
    {
      pure CruiseSpeedStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure CruiseSpeedStr;
  }
}

$rect <500,70,700,110>
autoobject DeviceInterface::VehicleDeviceClass VehicleDevice;

$rect <260,70,460,110>
$output false
class WeatherDeviceClass : Templates::DeviceClass
{
  $rect <110,180,310,220>
  method void GetWeatherInfo( arg int32 aWeaItemIdx )
  {
    $if !$prototyper
      var int32 WTime;
      var int32 WType;
      var int32 WTemp;
      var int32 TempMin;
      var int32 TempMax;
      var int32 RainProb;

      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TEMPERATURE_UNIT );
      var Enum::TemperatureSettingItem WeaTempType = ( Enum::TemperatureSettingItem )VehicleData.DataUInt32;

      native( aWeaItemIdx, WTime, WType, WTemp, TempMin, TempMax, RainProb )
      {
        bc_motocon_weather_info_t* w_obj = NULL;
        w_obj = ew_get_weather_info_obj( aWeaItemIdx );
        WTime = w_obj->time;
        WType = w_obj->type;
        WTemp = (int)w_obj->temperature;
        TempMin = (int)w_obj->temperature_min;
        TempMax = (int)w_obj->temperature_max;
        RainProb = w_obj->rain_probability;
      }
      WeatherTime = WTime;
      WeatherType = WType;
      Temperature = ConvertTemperature( WeaTempType, WTemp );
      MinTemperature = ConvertTemperature( WeaTempType, TempMin );
      MaxTemperature = ConvertTemperature( WeaTempType, TempMax );
      RainProbability = RainProb;
    $else
      if( aWeaItemIdx > 0 )
      {
      // suppress warning
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <110,300,330,340>
  $output true
  method void NotifyWeatherInfoUpdated()
  {
    IsWeatherInfoReceived = true;
  }

  $rect <320,180,520,220>
  method void GetWeatherLoc()
  {
    $if !$prototyper
      var string CurrentLoc;

      native( CurrentLoc )
      {
        char* cur_loc;
        ew_get_weather_loc( &cur_loc );
        CurrentLoc = EwNewStringUtf8( (const unsigned char*) cur_loc, (int)strlen( cur_loc ) );
      }
    WeatherLocation = CurrentLoc;
    $endif
  }

  $rect <100,-10,300,30>
  var int32 WeatherTime;

  $rect <100,30,300,70>
  var int32 Temperature;

  $rect <100,70,300,110>
  var int32 MaxTemperature;

  $rect <310,-10,510,30>
  var int32 WeatherType;

  $rect <310,30,510,70>
  var int32 MinTemperature;

  $rect <310,70,510,110>
  var int32 RainProbability;

  $rect <100,110,300,150>
  var string WeatherLocation;

  $rect <110,240,340,280>
  method void SendWeatherInfoRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_weather_info_req();
      }
    $endif
  }

  $rect <350,240,590,280>
  method void SendVehicleSettingRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_vehicle_setting_req();
      }
    $endif
  }

  $rect <310,110,510,150>
  var int32 WeekDay;

  $rect <540,180,740,220>
  method void GetWeekDay()
  {
    $if !$prototyper
      var int32 NewWeekDay;

      native( NewWeekDay )
      {
        int week_day = ew_get_weather_week_day();
        NewWeekDay = week_day;
      }
    WeekDay = NewWeekDay;
    $endif
  }

  $rect <530,-10,770,30>
  property bool IsWeatherInfoReceived = false;

  $rect <530,30,770,70>
  onset IsWeatherInfoReceived
  {
    // Remember the property's new value.
    pure IsWeatherInfoReceived = value;

    notifyobservers ^IsWeatherInfoReceived;

  }

  $rect <110,360,310,400>
  method int32 ConvertTemperature( arg Enum::TemperatureSettingItem aTempUnit, arg int32 aTemperature )
  {
    var int32 Temp = aTemperature;
    if( Enum::TemperatureSettingItem.TEMP_F == aTempUnit )
    {
      Temp = ( int32 )( ( aTemperature * 9 + 160 ) / 5 );
    }
    return Temp;
  }
}

$rect <260,110,460,150>
autoobject DeviceInterface::WeatherDeviceClass WeatherDevice;

$rect <500,150,700,190>
$output false
class VehicleDataClass
{
  $rect <10,110,210,150>
  var float DataFloat = 0;

  $rect <10,160,210,200>
  var uint32 DataUInt32 = 0;

  $rect <10,10,210,50>
  var bool Valid = false;

  $rect <10,60,210,100>
  var Enum::DataType DataType = Enum::DataType.UINT32;

  $rect <230,10,430,50>
  var Enum::VehicleRxType RxType;
}

$rect <21,380,221,420>
class NaviDataClass
{
  $rect <80,60,280,100>
  $output true
  var string CurrentRoad;

  $rect <80,100,280,140>
  $output true
  var int32 ETA;

  $rect <80,140,280,180>
  $output true
  var int32 DayNightMode;

  $rect <80,180,280,220>
  $output true
  var int32 SpeedLimit;

  $rect <280,60,480,100>
  $output true
  var Enum::NaviAlertType NaviEventType;

  $rect <280,100,480,140>
  $output true
  var string NaviEventDist;

  $rect <280,140,480,180>
  $output true
  var bool NaviEventVisibility;

  $rect <280,180,480,220>
  $output true
  var string NaviEventSpeed;

  $rect <490,60,690,100>
  $output true
  var Enum::NaviCameraType NaviCameraType;

  $rect <80,220,280,260>
  $output true
  var int32 RouteCalProgress;
}

$rect <751,190,951,230>
$output false
class MotoConContext
{
  $rect <10,10,210,50>
  var Enum::MotoConRxEvent RxEvent;
}

$rect <530,300,740,340>
$output false
class NotificationDeviceClass : Templates::DeviceClass
{
  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <30,220,240,260>
  $output true
  method bool IsPhoneCallStateActive()
  {
    return ( Enum::PhoneCallState.ACTIVE == GetPhoneCallState() );
  }

  // Phone Call
  note group Note1
  {
    attr Bounds = <10,10,970,280>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,60,280,100>
  $output true
  method void NotifyPhoneCallStateChanged()
  {
    trace "NotifyPhoneCallStateChanged";
    PhoneCallStateChangedSystemEvent.Trigger( null, false );
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,350,230,390>
  $output true
  method void NotifyListUpdated()
  {
    trace "NotifyListUpdated";
    NotificationListUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <30,400,320,440>
  object Core::SystemEvent NotificationListUpdatedSystemEvent;

  $rect <840,350,1050,390>
  method DeviceInterface::NotificationContext GetNotificationAtItem( arg uint32 aItemNo )
  {
    var DeviceInterface::NotificationContext NotificationItem = new DeviceInterface::NotificationContext;
    NotificationItem.ReceivedTime = new DeviceInterface::DateTime;

    $if !$prototyper
      var uint32 Uid;
      var uint16 CallRepetition;
      var uint32 Category;
      var string Title = "";
      var string Subtitle = "";
      var string Message = "";
      var string ReceivedHour = "";
      var string ReceivedMinute = "";

      native( aItemNo, Uid, CallRepetition, Title, Subtitle, Message, Category, ReceivedHour, ReceivedMinute )
      {
        uint32_t notification_uid;
        uint16_t call_repetition;
        uint8_t  notification_title[NOTIFICATION_TITLE_MAX_LEN];
        uint8_t  notification_subtitle[NOTIFICATION_SUBTITLE_MAX_LEN];
        uint8_t  notification_message[NOTIFICATION_MESSAGE_MAX_LEN];
        notification_time_t received_time;
        EnumNotificationCategory notification_category;

        NTF_get_notification_at_idx( aItemNo, &notification_uid, &call_repetition,
                                     notification_title, NOTIFICATION_TITLE_MAX_LEN,
                                     notification_subtitle, NOTIFICATION_SUBTITLE_MAX_LEN,
                                     notification_message, NOTIFICATION_MESSAGE_MAX_LEN,
                                     &notification_category, &received_time );

        Uid = notification_uid;
        CallRepetition = call_repetition;

        uint8_t *stuffed_str = NULL;
        int stuffed_str_len = ew_handle_special_characters( notification_title, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Title = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        stuffed_str_len = ew_handle_special_characters( notification_subtitle, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Subtitle = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        stuffed_str_len = ew_handle_special_characters( notification_message, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Message = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        Category = notification_category;
        ReceivedHour = EwNewStringUInt( received_time.hour, 1, 10 );
        ReceivedMinute = EwNewStringUInt( received_time.minute, 2, 10 );
      }

      NotificationItem.Uid = Uid;
      NotificationItem.CallRepetition = CallRepetition;
      NotificationItem.Title = Title;
      NotificationItem.Subtitle = Subtitle;
      NotificationItem.Message = Message;
      NotificationItem.Category = (Enum::NotificationCategory)Category;
      NotificationItem.ReceivedTime.Hour = ReceivedHour;
      NotificationItem.ReceivedTime.Minute = ReceivedMinute;
    $else
      aItemNo; // suppress warning
    $endif

    return NotificationItem;
  }

  $rect <337,350,547,390>
  property uint32 NotificationNum;

  $rect <337,400,547,440>
  onget NotificationNum
  {
    $if !$prototyper
      var uint32 Num = 0;
      native( Num )
      {
        Num = NTF_get_notification_num();
      }

      pure NotificationNum = Num;
    $endif
    return pure NotificationNum;
  }

  // Notification
  note group Note2
  {
    attr Bounds = <10,300,1070,460>;
  }

  $rect <840,400,1050,440>
  method void DeleteNotificationOfUid( arg uint32 Uid )
  {
    $if !$prototyper
      native( Uid )
      {
        NTF_delete_notification( Uid );
      }
    $endif
  }

  $rect <560,350,820,390>
  method int32 GetBufferIdxOfNotificationUID( arg uint32 Uid )
  {
    var int32 Index = -1;
    $if !$prototyper
      native( Uid, Index )
      {
        Index = NTF_get_idx_of_notification_uid( Uid );
      }
    $endif
    return Index;
  }

  $rect <30,110,330,150>
  object Core::SystemEvent PhoneCallStateChangedSystemEvent;

  $rect <250,170,460,210>
  method string GetIncomingCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t *stuffed_str = NULL;

        NTF_get_incoming_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }

  // Get active call duration in ms
  $rect <680,110,890,150>
  method uint32 GetActiveCallDuration()
  {
    var uint32 DurationMS;

    $if !$prototyper
      native( DurationMS )
      {
        DurationMS = NTF_get_active_call_duration();
      }
    $endif

    return DurationMS;
  }

  $rect <30,170,240,210>
  method Enum::PhoneCallState GetPhoneCallState()
  {
    var Enum::PhoneCallState PhoneCallState = Enum::PhoneCallState.IDLE;

    $if !$prototyper
      native( PhoneCallState )
      {
        int32_t phone_call_state = NTF_get_phonecall_state();
        PhoneCallState = (EnumPhoneCallState)phone_call_state;
      }
    $endif

    return PhoneCallState;
  }

  $rect <740,170,950,210>
  method void AnswerPhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_answer_call();
      }
    $endif
  }

  $rect <740,220,950,260>
  method void DeclinePhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_decline_call();
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <470,170,730,210>
  $output true
  method bool IsPhoneCallVolumeControllable()
  {
    var bool Controllable = false;

    $if !$prototyper
      native( Controllable )
      {
        Controllable = NTF_is_phonecall_volume_controllable();
      }
    $endif

    return Controllable;
  }

  $rect <470,220,730,260>
  method void PhoneCallVolumeControl( arg Enum::VolumeControl aControl )
  {
    $if !$prototyper
      native( aControl )
      {
        NTF_phonecall_volume_control( aControl );
      }
    $endif
  }

  $rect <340,110,650,150>
  object Core::SystemEvent PhoneCallVolumeChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <340,60,590,100>
  $output true
  method void NotifyPhoneCallVolumeChanged()
  {
    trace "NotifyPhoneCallVolumeChanged";
    PhoneCallVolumeChangedSystemEvent.Trigger( null, false );
  }

  $rect <680,60,890,100>
  method uint32 GetPhoneCallVolume()
  {
    var uint32 PhoneCallVolume = 0;

    $if !$prototyper
      native( PhoneCallVolume )
      {
        PhoneCallVolume = BC_motocon_get_phonecall_volume();
      }
    $endif

    return PhoneCallVolume;
  }

  $rect <560,400,820,440>
  method int32 GetNotificationNumOfCategory( arg Enum::NotificationCategory aCategory )
  {
    var int32 Num = 0;
    $if !$prototyper
      native( aCategory, Num )
      {
        Num = NTF_get_notification_num_of_category( aCategory );
      }
    $endif
    return Num;
  }

  $rect <250,220,460,260>
  method string GetActiveCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t* stuffed_str = NULL;

        NTF_get_active_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }
}

$rect <530,340,730,380>
autoobject DeviceInterface::NotificationDeviceClass NotificationDevice;

$rect <20,420,220,460>
$output false
class NaviTbtDataClass
{
  $rect <50,40,250,80>
  var int32 IconIdx;

  $rect <50,90,250,130>
  var string DistUnit;

  $rect <50,150,250,190>
  var string TbtDescription;

  $rect <50,210,250,250>
  var int32 ListIdx;

  $rect <50,260,250,300>
  var int32 Distance;
}

$rect <530,380,730,420>
$output false
class DateTime
{
  $rect <70,50,270,90>
  var string Year;

  $rect <70,100,270,140>
  var string Month;

  $rect <70,150,270,190>
  var string Date;

  $rect <70,200,270,240>
  var string Hour;

  $rect <70,250,270,290>
  var string Minute;

  $rect <70,300,270,340>
  var string Second;
}

$rect <530,420,730,460>
$output false
class NotificationContext
{
  $rect <10,10,210,50>
  var uint32 Uid;

  $rect <10,60,210,100>
  var uint16 CallRepetition;

  $rect <10,110,210,150>
  var string Title;

  $rect <10,210,210,250>
  var string Message;

  $rect <10,260,210,300>
  var Enum::NotificationCategory Category;

  $rect <10,310,210,350>
  var DeviceInterface::DateTime ReceivedTime;

  $rect <10,160,210,200>
  var string Subtitle;
}

$rect <20,190,300,230>
$output false
const uint8 INSPECTION_NEGATIVE_RESPONSE = 0xFF;
