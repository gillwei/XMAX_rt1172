$version 11.00

$rect <20,10,220,50>
inline Inline
{
  #include <stddef.h>
  #include <stdlib.h>
  #include <stdio.h>
  #include "ew_priv.h"
  #include "display_support.h"
  #include "EEPM_pub.h"
  #include "PERIPHERAL_pub.h"
  #include "VI_pub.h"
  #include "MM_pub_ams_type.h"
  #include "BT_pub.h"
  #include "CM_pub.h"
  #include "BC_motocon_pub.h"
  #include "BC_motocon_pub_type.h"
  #include "BC_ams_pub.h"
  #include "NTF_pub.h"
  #include "TEST_pub.h"
  #include "NAVI_pub.h"
  #include "Enum.h"
  #include "ew_tacho.h"
}

$rect <20,70,220,110>
$output false
class SystemDeviceClass : Templates::DeviceClass
{
  // Interface to get system info
  note group Note1
  {
    attr Bounds = <10,10,1160,380>;
  }

  $rect <250,70,450,110>
  property string SoftwareVersion;

  $rect <470,70,670,110>
  property bool IsDebugBuild;

  $rect <470,120,670,160>
  onget IsDebugBuild
  {
    $if( !$prototyper )
      var bool is_debug_build;
      native( is_debug_build )
      {
        is_debug_build = ew_is_debug_build();
      }
      return is_debug_build;
    $else
      return true;
    $endif
  }

  // Interfaces for factory test
  note group Note3
  {
    attr Bounds = <10,400,740,560>;
  }

  $rect <40,490,240,530>
  $output true
  method void QuitTest()
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Quit;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <490,490,710,530>
  object Core::SystemEvent FactoryTestSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,440,240,480>
  $output true
  method void TestDisplayPattern( arg int32 aIdx )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Display;
    TestContext.Data = aIdx - 1;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <30,220,230,260>
  $output true
  method void NotifyEsnRead( arg string aESN )
  {
    ESN = aESN;
  }

  $rect <30,70,230,110>
  property string ESN;

  $rect <30,120,230,160>
  onset ESN
  {
    if( pure ESN != value )
    {
      pure ESN = value;
      notifyobservers ^ESN;
    }

  }

  $rect <30,170,230,210>
  onget ESN
  {
    $if( !$prototyper )
      if( "" == pure ESN )
      {
        native
        {
           ew_get_esn();
        }
      }
    $endif

    return pure ESN;
  }

  $rect <250,120,450,160>
  onget SoftwareVersion
  {
    $if !$prototyper
      var string software_version = "";

      if( "" == pure SoftwareVersion )
      {
        native( software_version )
        {
           char version[8];
           ew_get_software_version( version );
           software_version = EwNewStringAnsi( version );
        }

        pure SoftwareVersion = software_version;
      }
    $endif

    return pure SoftwareVersion;
  }

  $rect <50,620,270,660>
  method void ResetToFactoryDefault()
  {
    IsRunningFactoryReset = true;
    $if !$prototyper
      native
      {
        EW_reset_to_factory_default();
      }
    $endif
  }

  // Device Interface for Factory Reset
  note group Note4
  {
    attr Bounds = <10,580,360,800>;
  }

  $rect <50,670,270,710>
  method void RebootSystem()
  {
    $if !$prototyper
      native
      {
        ew_reboot_system();
      }
    $endif
  }

  $rect <1010,420,1210,460>
  method void SetTFTDutyCycle( arg int32 aDutyCycle )
  {
    $if !$prototyper
      native( aDutyCycle )
      {
        PERIPHERAL_pwm_set_display_dutycycle( aDutyCycle );
      }
    $else
    // suppress warning
    if( 0 == aDutyCycle )
    {
      // empty body
    }
    $endif
  }

  $rect <1010,470,1210,510>
  property int32 BrightnessLevel = 7;

  $rect <250,440,470,480>
  $output true
  method void StartBurnInTest()
  {
    trace "StartBurnInTest";
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInStart;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <250,490,470,530>
  $output true
  method void UpdateBurnInTestTime( arg uint32 aTimeSec )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInTimeUpdate;
    TestContext.Data = ( int32 )aTimeSec;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <499,440,709,480>
  $output true
  method void ShowBurnInTestResult( arg bool aResult )
  {
    trace "ShowBurnInTestResult: ", aResult;
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInResult;
    if( aResult )
    {
      TestContext.Data = 1;
    }
    else
    {
      TestContext.Data = 0;
    }
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <470,170,670,210>
  var bool IsHopperTestMode = false;

  // Device Interface for QR code
  note group Note5
  {
    attr Bounds = <610,630,1120,820>;
  }

  $rect <870,670,1070,710>
  object Core::SystemEvent QrCodeSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <650,670,850,710>
  $output true
  method void NotifyQrCodeReady()
  {
    QrCodeSystemEvent.Trigger( null, false );
  }

  $rect <650,770,850,810>
  method void GetQrCode()
  {
    $if !$prototyper
      native
      {
        ew_request_qrcode();
      }
    $endif
  }

  $rect <680,120,930,160>
  method DeviceInterface::RtcTime GetLocalTime()
  {
    var DeviceInterface::RtcTime CurrentLocalTime = new DeviceInterface::RtcTime;

    $if !$prototyper
      var uint16 RtcYear;
      var uint8 RtcMonth;
      var uint8 RtcDay;
      var uint8 RtcHour;
      var uint8 RtcMinute;
      var uint8 RtcSecond;

      native( RtcYear, RtcMonth, RtcDay, RtcHour, RtcMinute, RtcSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        ew_get_rtc_time( &srtc_time );

        RtcYear = srtc_time.year;
        RtcMonth = srtc_time.month;
        RtcDay = srtc_time.day;
        RtcHour = srtc_time.hour;
        RtcMinute = srtc_time.minute;
        RtcSecond = srtc_time.second;
      }

      CurrentLocalTime.Year = RtcYear;
      CurrentLocalTime.Month = RtcMonth;
      CurrentLocalTime.Day = RtcDay;
      CurrentLocalTime.Hour = RtcHour;
      CurrentLocalTime.Minute = RtcMinute;
      CurrentLocalTime.Second = RtcSecond;
    $else
      // for screenshot
      CurrentLocalTime.Year = 2020;
      CurrentLocalTime.Month = 10;
      CurrentLocalTime.Day = 20;
      CurrentLocalTime.Hour = 12;
      CurrentLocalTime.Minute = 40;
    $endif

    return CurrentLocalTime;
  }

  // Opening Flow Control
  note group Note6
  {
    attr Bounds = <450,840,1130,1050>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <465,886,675,926>
  $output true
  method void StartOpening()
  {
    OpeningSystemEvent.Trigger( null, false );
  }

  $rect <465,936,675,976>
  object Core::SystemEvent OpeningSystemEvent;

  $rect <770,450,970,490>
  method bool IsKeyStateValid()
  {
    var bool IsValid = true;
    $if !$prototyper
      native( IsValid )
      {
        IsValid = VI_is_key_state_valid();
      }
    $endif
    return IsValid;
  }

  $rect <685,886,895,926>
  method bool IsTFTBacklightOn()
  {
    var bool IsBacklightOn = false;
    $if !$prototyper
      native( IsBacklightOn )
      {
        IsBacklightOn = display_is_tft_backlight_on();
      }
    $else
      IsBacklightOn = true;
    $endif
    return IsBacklightOn;
  }

  $rect <910,887,1110,927>
  property Enum::OperationMode OperationMode;

  $rect <910,937,1110,977>
  onset OperationMode
  {
    if( pure OperationMode != value )
    {
      pure OperationMode = value;
      $if !$prototyper
        native( value )
        {
          ew_set_operation_mode( value );
        }
      $endif
    }
  }

  $rect <909,987,1109,1027>
  onget OperationMode
  {
    $if !$prototyper
      var Enum::OperationMode Mode = Enum::OperationMode.NORMAL;
      native( Mode )
      {
        EnumOperationMode op_mode;
        if( EW_get_operation_mode( &op_mode ) )
        {
          Mode = op_mode;
        }
      }
      pure OperationMode = Mode;
    $endif

    return pure OperationMode;
  }

  $rect <685,936,895,976>
  method bool IsOperationModeReady()
  {
    var bool IsOperationModeReady;
    $if !$prototyper
      native( IsOperationModeReady )
      {
        IsOperationModeReady = ew_is_operation_mode_ready();
      }
    $else
      IsOperationModeReady = true;
    $endif
    return IsOperationModeReady;
  }

  // Inspection Mode
  note group Note7
  {
    attr Bounds = <10,840,310,1300>;
  }

  $rect <30,1180,290,1220>
  object Core::SystemEvent InspectionDisplaySystemEvent;

  $rect <30,1030,290,1070>
  object Core::SystemEvent InspectionModeSystemEvent;

  // Notifiy the inspection display pattern to test
  $rect <30,880,290,920>
  $output true
  method void NotifyInspectionRequest( arg Enum::InspectionMode aMode, arg Enum::InspectionDisplay aDisplayPattern )
  {
    InspectionDisplayPattern = aDisplayPattern;
    InspectionMode = aMode;
  }

  $rect <30,930,230,970>
  property Enum::InspectionMode InspectionMode = Enum::InspectionMode.NONE;

  $rect <30,980,230,1020>
  onset InspectionMode
  {
    pure InspectionMode = value;
    InspectionModeSystemEvent.Trigger( null, false );
  }

  $rect <30,1080,260,1120>
  property Enum::InspectionDisplay InspectionDisplayPattern;

  $rect <30,1130,290,1170>
  onset InspectionDisplayPattern
  {
    if ( pure InspectionDisplayPattern != value )
    {
      pure InspectionDisplayPattern = value;
      InspectionDisplaySystemEvent.Trigger( null, false );
    }
  }

  $rect <30,1230,250,1270>
  method void SendInspectionResponse( arg Enum::InspectionMode aMode, arg uint8 aRes )
  {
    $if !$prototyper
      native( aMode, aRes )
      {
        VI_send_inspection_response( aMode, aRes );
      }
    $endif
  }

  // Get current home type from UI
  $rect <941,70,1140,110>
  $output true
  method void NotifyLastPageRead()
  {
    $if !$prototyper
      var Enum::HomeGroup HomeGroup;
      var Enum::MeterDisplay MeterDisplaySetting;
      var Enum::NavigationView NavigationViewSetting;
      native( HomeGroup, MeterDisplaySetting, NavigationViewSetting )
      {
        HomeGroup = ew_get_last_home_group();
        MeterDisplaySetting = ew_get_meter_display_setting();
        NavigationViewSetting = ew_get_navigation_view_setting();
      }

      DeviceInterface::VehicleDevice.CurrentMeterDisplay = MeterDisplaySetting;
      switch( NavigationViewSetting )
      {
        case Enum::NavigationView.DEFAULT_VIEW: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;
        case Enum::NavigationView.TURN_BY_TURN: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_TURN_BY_TURN;
        case Enum::NavigationView.NEXT_TURN: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_NEXT_TURN;
        default: DeviceInterface::NavigationDevice.CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;
      }

      switch( HomeGroup )
      {
        case Enum::HomeGroup.METER:
        {
          switch( MeterDisplaySetting )
          {
            case Enum::MeterDisplay.TACHOMETER: pure HomeType = Enum::HomeType.TACHO_VISUALIZER;
            case Enum::MeterDisplay.ECHO_METER: pure HomeType = Enum::HomeType.ECO_VISUALIZER;
            case Enum::MeterDisplay.SPEED_METER: pure HomeType = Enum::HomeType.SPEED_VISUALIZER;
            default: pure HomeType = Enum::HomeType.TACHO_VISUALIZER;
          }
        }
        case Enum::HomeGroup.NAVIGATION: pure HomeType = DeviceInterface::NavigationDevice.CurrentHome;
        case Enum::HomeGroup.VEHICLE_INFO: pure HomeType = Enum::HomeType.VEHICLE_INFO;
        default:;
      }
    $endif
  }

  // Get current home type from UI
  $rect <941,120,1140,160>
  $output true
  method void UpdateLastPage()
  {
    var Enum::HomeGroup HomeGroup;
    switch( DeviceInterface::SystemDevice.HomeType )
    {
      case Enum::HomeType.TACHO_VISUALIZER,
           Enum::HomeType.ECO_VISUALIZER,
           Enum::HomeType.SPEED_VISUALIZER: HomeGroup = Enum::HomeGroup.METER;
      case Enum::HomeType.NAVI_DEFAULT_VIEW,
           Enum::HomeType.NAVI_TURN_BY_TURN,
           Enum::HomeType.NAVI_NEXT_TURN: HomeGroup = Enum::HomeGroup.NAVIGATION;
      case Enum::HomeType.VEHICLE_INFO: HomeGroup = Enum::HomeGroup.VEHICLE_INFO;
      default: HomeGroup = Enum::HomeGroup.METER;
    }

    var Enum::NavigationView NavigationViewSetting;
    switch( DeviceInterface::NavigationDevice.CurrentHome )
    {
      case Enum::HomeType.NAVI_DEFAULT_VIEW: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
      case Enum::HomeType.NAVI_TURN_BY_TURN: NavigationViewSetting = Enum::NavigationView.TURN_BY_TURN;
      case Enum::HomeType.NAVI_NEXT_TURN: NavigationViewSetting = Enum::NavigationView.NEXT_TURN;
      default: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
    }

    var Enum::MeterDisplay MeterDisplaySetting = DeviceInterface::VehicleDevice.CurrentMeterDisplay;

    $if !$prototyper
      native( HomeGroup, NavigationViewSetting, MeterDisplaySetting )
      {
        ew_set_last_page( HomeGroup, MeterDisplaySetting, NavigationViewSetting );
      }
    $endif
  }

  $rect <940,170,1140,210>
  property Enum::HomeType HomeType;

  $rect <940,220,1140,260>
  onset HomeType
  {
    if( pure HomeType != value )
    {
      pure HomeType = value;

      var Enum::HomeGroup HomeGroup;
      switch( value )
      {
        case Enum::HomeType.TACHO_VISUALIZER,
             Enum::HomeType.ECO_VISUALIZER,
             Enum::HomeType.SPEED_VISUALIZER: HomeGroup = Enum::HomeGroup.METER;
        case Enum::HomeType.NAVI_DEFAULT_VIEW,
             Enum::HomeType.NAVI_TURN_BY_TURN,
             Enum::HomeType.NAVI_NEXT_TURN: HomeGroup = Enum::HomeGroup.NAVIGATION;
        case Enum::HomeType.VEHICLE_INFO: HomeGroup = Enum::HomeGroup.VEHICLE_INFO;
        default: HomeGroup = Enum::HomeGroup.METER;
      }

      var Enum::NavigationView NavigationViewSetting;
      switch( DeviceInterface::NavigationDevice.CurrentHome )
      {
        case Enum::HomeType.NAVI_DEFAULT_VIEW: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
        case Enum::HomeType.NAVI_TURN_BY_TURN: NavigationViewSetting = Enum::NavigationView.TURN_BY_TURN;
        case Enum::HomeType.NAVI_NEXT_TURN: NavigationViewSetting = Enum::NavigationView.NEXT_TURN;
        default: NavigationViewSetting = Enum::NavigationView.DEFAULT_VIEW;
      }

      var Enum::MeterDisplay MeterDisplaySetting = DeviceInterface::VehicleDevice.CurrentMeterDisplay;

      $if !$prototyper
        native( HomeGroup, NavigationViewSetting, MeterDisplaySetting )
        {
          ew_set_last_page( HomeGroup, MeterDisplaySetting, NavigationViewSetting );
        }
      $endif
    }
  }

  $rect <770,500,970,540>
  method void SetKeyTriggerMode( arg Core::KeyCode aKey, arg Enum::KeyTriggerMode aMode )
  {
    $if !$prototyper
      native( aKey, aMode )
      {
        VI_key_set_trigger_mode( aKey, aMode );
      }
    $else
    // suppress warning
    aKey;
    aMode;
    $endif
  }

  // Interfaces for factory test
  note group Note8
  {
    attr Bounds = <750,400,990,620>;
  }

  $rect <770,550,970,590>
  method void SetMagicKeyEnabled( arg bool aEnabled )
  {
    $if !$prototyper
      native( aEnabled )
      {
        VI_key_set_magic_key_enabled( aEnabled );
      }
    $else
    aEnabled; // suppress warning
    $endif
  }

  $rect <650,720,850,760>
  method bool IsQrCodeReady()
  {
    var bool IsQrCodeReady = false;
    $if !$prototyper
      native( IsQrCodeReady )
      {
        IsQrCodeReady = ew_is_qrcode_ready();
      }
    $else
      IsQrCodeReady = true;
    $endif
    return IsQrCodeReady;
  }

  // Clock Setting
  note group Note9
  {
    attr Bounds = <450,1080,1130,1300>;
  }

  $rect <460,1120,660,1160>
  method void NotifyTimeRequest()
  {
    $if !$prototyper
      native
      {
        BC_motocon_set_request_from_clock();
        BC_motocon_send_vehicle_setting_request();
      }
    $endif
  }

  $rect <670,1170,870,1210>
  var DeviceInterface::RtcTime CurrentAdjustTime;

  $rect <670,1120,870,1160>
  method void SetRtcTime( arg DeviceInterface::RtcTime aNewTime )
  {
    $if !$prototyper
      var uint16 NewTimeYear = aNewTime.Year;
      var uint8 NewTimeMonth = aNewTime.Month;
      var uint8 NewTimeDay = aNewTime.Day;
      var uint8 NewTimeHour = aNewTime.Hour;
      var uint8 NewTimeMinute = aNewTime.Minute;
      var uint8 NewTimeSecond = aNewTime.Second;

      native( NewTimeYear, NewTimeMonth, NewTimeDay, NewTimeHour, NewTimeMinute, NewTimeSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        srtc_time.year = NewTimeYear;
        srtc_time.month = NewTimeMonth;
        srtc_time.day = NewTimeDay;
        srtc_time.hour = NewTimeHour;
        srtc_time.minute = NewTimeMinute;
        srtc_time.second = NewTimeSecond;
        ew_set_rtc_time( &srtc_time );
      }
    $else
      aNewTime;
    $endif
  }

  $rect <890,1120,1090,1160>
  method void SendManualAdjTimeToMeter()
  {
    $if !$prototyper
      native
      {
        VI_clock_send_rtc_time_to_meter();
      }
    $endif
  }

  $rect <460,1170,660,1210>
  property bool IsClockAutoAdj;

  $rect <460,1210,660,1250>
  onset IsClockAutoAdj
  {
    if( pure IsClockAutoAdj != value )
    {
      // Remember the property's new value.
      pure IsClockAutoAdj = value;

      $if !$prototyper
        var bool ClockAutoAdjStatus = value;
        native( ClockAutoAdjStatus )
        {
          ew_set_clk_auto_adj( ClockAutoAdjStatus );
        }
      $endif
    }
  }

  $rect <460,1250,660,1290>
  onget IsClockAutoAdj
  {
    $if !$prototyper
      var bool ClockAutoAdjStatus;
      native( ClockAutoAdjStatus )
      {
        ClockAutoAdjStatus = EW_get_clk_auto_adj();
      }
      pure IsClockAutoAdj = ClockAutoAdjStatus;
    $endif
    return pure IsClockAutoAdj;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,1320,300,1360>
  $output true
  method void NotifySystemEventReceived( arg Enum::SystemRxEvent aSystemRxEvent )
  {
    var DeviceInterface::SystemData SystemDataContext = new DeviceInterface::SystemData;
    SystemDataContext.RxEvent = aSystemRxEvent;
    SystemDataReceivedSystemEvent.Trigger( SystemDataContext, false );
  }

  // This object represents an individual system event.
  $rect <20,1370,300,1410>
  object Core::SystemEvent SystemDataReceivedSystemEvent;

  $rect <20,1520,220,1560>
  method void StartOTA()
  {
    $if !$prototyper
      native
      {
        ew_start_ota();
      }
    $endif
  }

  $rect <250,270,510,310>
  property bool IsSoftwareUpdateEnabled;

  $rect <250,320,520,360>
  onget IsSoftwareUpdateEnabled
  {
    $if !$prototyper
      var bool IsEnabled = false;
      native( IsEnabled )
      {
        bc_motocon_ota_update_info_t* ota_update_info = BC_motocon_get_ota_update_info();
        IsEnabled = ota_update_info->enable;
      }
      pure IsSoftwareUpdateEnabled = IsEnabled;
    $else
      pure IsSoftwareUpdateEnabled = true;
    $endif
    return pure IsSoftwareUpdateEnabled;
  }

  $rect <50,720,270,760>
  property bool IsRunningFactoryReset;

  $rect <26,270,230,310>
  method void SaveLastStatus()
  {
    $if !$prototyper
      native
      {
        ew_save_last_status();
      }
    $endif
  }

  $rect <20,1420,300,1460>
  method void SendSystemCommand( arg Enum::SystemTxCmd aCmd )
  {
    $if !$prototyper
      native( aCmd )
      {
        ew_send_system_command( aCmd );
      }
    $else
      // suppress warning
      aCmd;
    $endif
  }

  $rect <20,1470,300,1510>
  method int32 GetSystemStatus( arg Enum::SystemStatus aStatusType )
  {
    var int32 Status;
    $if !$prototyper
      native( aStatusType, Status )
      {
        Status = ew_system_get_status( aStatusType );
      }
    $else
      // suppress warning
      aStatusType;
    $endif
    return Status;
  }

  $rect <450,1330,650,1370>
  method void ChangeLanguage( arg Enum::Language aLanguage )
  {
    trace "ChangeLang: ", aLanguage;

    switch( aLanguage )
    {
      case Enum::Language.ENGLISH: language = Default;
      case Enum::Language.FRENCH: language = French;
      case Enum::Language.GERMAN: language = German;
      case Enum::Language.ITALIAN: language = Italian;
      case Enum::Language.JAPANESE: language = Japanese;
      case Enum::Language.SPANISH: language = Spanish;
      case Enum::Language.TRADITIONAL_CHINESE: language = TraditionalChinese;
      case Enum::Language.SIMPLIFIED_CHINESE: language = SimplifiedChinese;
      case Enum::Language.GREEK: language = Greek;
      case Enum::Language.FINNISH: language = Finnish;
      case Enum::Language.HINDI: language = Hindi;
      case Enum::Language.INDONESIAN: language = Indonesian;
      case Enum::Language.POLISH: language = Polish;
      case Enum::Language.PORTUGUESE_BRAZIL: language = PortugueseBrazil;
      case Enum::Language.THAI: language = Thai;
      case Enum::Language.VIETNAMESE: language = Vietnamese;
      case Enum::Language.KOREAN: language = Korean;
      case Enum::Language.MALAY: language = Malay;
      default: language = Default;
    }
  }
}

$rect <20,110,220,150>
autoobject DeviceInterface::SystemDeviceClass SystemDevice;

$rect <20,300,230,340>
$output false
class NavigationDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <240,560,440,600>
  object Core::SystemEvent MapUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,560,240,600>
  $output true
  method void NotifyMapUpdate()
  {
    MapUpdateEvent.Trigger( null, true );
  }

  $rect <410,870,610,910>
  method bool IsMapFrameReady()
  {
    $if( !$prototyper )
      var bool IsMapFrameReady = false;
      native( IsMapFrameReady )
      {
        IsMapFrameReady = ew_navi_is_map_frame_ready();
      }
      return IsMapFrameReady;
    $else
      return false;
    $endif
  }

  $rect <240,280,440,320>
  object Core::SystemEvent CurRdUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,280,240,320>
  $output true
  method void NotifyCurRdUpdate()
  {
    CurRdUpdateEvent.Trigger( null, false );
  }

  $rect <240,320,440,360>
  object Core::SystemEvent ETAUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,320,240,360>
  $output true
  method void NotifyETAUpdate()
  {
    ETAUpdateEvent.Trigger( null, false );
  }

  $rect <240,360,440,400>
  object Core::SystemEvent DayNightModeUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,360,240,400>
  $output true
  method void NotifyDayNightModeUpdate()
  {
    DayNightModeUpdateEvent.Trigger( null, false );
  }

  $rect <240,400,440,440>
  object Core::SystemEvent SpeedLimitUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,400,240,440>
  $output true
  method void NotifySpeedLimitUpdate()
  {
    SpeedLimitUpdateEvent.Trigger( null, false );
  }

  $rect <240,440,440,480>
  object Core::SystemEvent NavigationAlertUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,440,240,480>
  $output true
  method void NotifyNaviAlertUpdate()
  {
    NavigationAlertUpdateEvent.Trigger( null, false );
  }

  $rect <730,740,930,780>
  method DeviceInterface::NaviDataClass GetNaviData( arg Enum::NaviDataType aDataType )
  {
    var DeviceInterface::NaviDataClass NaviData = new DeviceInterface::NaviDataClass;
    $if !$prototyper
    var int32 NaviDataType = ( int32 )aDataType;

    native( NaviDataType, NaviData )
    {
      navi_data_type* navi_obj = NULL;
      #if( !UNIT_TEST_NAVI )
        navi_obj = NAVI_get_navi_obj();
      #else
        navi_obj = TEST_get_navi_obj();
      #endif

      switch( NaviDataType )
      {
        case EnumNaviDataTypeCURRENT_ROAD:
          NaviData->CurrentRoad = EwNewStringUtf8( ( const unsigned char* )navi_obj->current_road, ( int )strlen( navi_obj->current_road ) );
          break;
        case EnumNaviDataTypeETA:
          NaviData->ETA = navi_obj->eta;
          break;
        case EnumNaviDataTypeSPEED_LIMIT:
          NaviData->SpeedLimit = navi_obj->speed_limit;
          break;
        case EnumNaviDataTypeDAYNIGHT:
          NaviData->DayNightMode = navi_obj->daynight;
          break;
        case EnumNaviDataTypeNAVI_EVENT:
          {
            navi_event_type navi_event_obj;
            bool is_event_retrieved = NAVI_get_event( &navi_event_obj );
            if( is_event_retrieved )
            {
              NaviData->NaviEventType = navi_event_obj.event_type;
              NaviData->NaviCameraType = navi_event_obj.camera_type;
              NaviData->NaviEventDist = EwNewStringUtf8( ( const unsigned char* )navi_event_obj.dist, ( int )strlen( navi_event_obj.dist ) );
              NaviData->NaviEventSpeed = EwNewStringUtf8( ( const unsigned char* )navi_event_obj.speed, ( int )strlen( navi_event_obj.speed ) );
              NaviData->NaviEventDesc = EwNewStringUtf8( ( const unsigned char* )navi_event_obj.desc, ( int )strlen( navi_event_obj.desc ) );
              NaviData->NaviEventVisibility = navi_event_obj.visibility;
            }
            else
            {
              NaviData = NULL;
            }
          }
          break;
        case EnumNaviDataTypeNAVI_ROUTE_CAL_PROGRESS:
          NaviData->RouteCalProgress = navi_obj->route_cal_progress;
          break;
        case EnumNaviDataTypeVIA_POINT:
          NaviData->ViaPoints = navi_obj->via_points;
          break;
        case EnumNaviDataTypeHOME:
          NaviData->IsHomeSet = (bool)navi_obj->is_home_set;
          break;
        case EnumNaviDataTypeOFFICE:
          NaviData->IsOfficeSet = (bool)navi_obj->is_office_set;
          break;
        case EnumNaviDataTypeZOOM_LEVEL:
          NaviData->ZoomLevel = EwNewStringUtf8( ( const unsigned char* )navi_obj->zoom_level, ( int )strlen( navi_obj->zoom_level ) );
          break;
        default:
          break;
      }
    }
    $else
      aDataType; // suppress warning.
    $endif

    return NaviData;

  }

  $rect <410,910,610,950>
  method bool IsRouteGuidanceStarted()
  {
    $if( !$prototyper )
      var bool IsNavigating = false;
      native( IsNavigating )
      {
        IsNavigating = NAVI_get_navigation_status();
      }
      return IsNavigating;
    $else
      return false;
    $endif
  }

  $rect <240,480,440,520>
  object Core::SystemEvent NavigatingStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,480,240,520>
  $output true
  method void NotifyNavigatingStatusUpdate()
  {
    NavigatingStatusUpdateEvent.Trigger( null, false );
  }

  $rect <240,520,440,560>
  object Core::SystemEvent TbtListUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,520,240,560>
  $output true
  method void NotifyTbtListUpdate()
  {
    TbtListUpdateEvent.Trigger( null, false );
  }

  $rect <730,700,930,740>
  method DeviceInterface::NaviTbtDataClass GetNaviTbtData( arg int32 aTbtItemIdx )
  {
    var DeviceInterface::NaviTbtDataClass NaviTbtData = new DeviceInterface::NaviTbtDataClass;

    $if !$prototyper
      native( NaviTbtData, aTbtItemIdx )
      {
        uint32_t icon_idx;
        float distance;
        char* dist_unit;
        char* description;
        NAVI_get_tbt_item( aTbtItemIdx, &icon_idx, &distance, &dist_unit, &description );
        NaviTbtData->IconIdx = icon_idx;
        NaviTbtData->Distance = distance;
        NaviTbtData->DistUnit = EwNewStringUtf8( ( const unsigned char* )dist_unit, ( int )strlen( dist_unit ) );
        NaviTbtData->TbtDescription = EwNewStringUtf8( ( const unsigned char* )description, ( int )strlen( description ) );
      }
    $else
      aTbtItemIdx; // suppress warning.
    $endif

    return NaviTbtData;
  }

  $rect <50,40,250,80>
  var Enum::HomeType CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;

  $rect <80,870,280,910>
  method void StopMapFrameRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_stop_map_update();
      }
    $endif
  }

  $rect <720,280,920,320>
  object Core::SystemEvent RouteCalProgressUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,280,720,320>
  $output true
  method void NotifyRouteCalProgressUpdate()
  {
    RouteCalProgressUpdateEvent.Trigger( null, false );
  }

  $rect <720,320,920,360>
  object Core::SystemEvent ZoomLevelUpdateEventHandler;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,320,720,360>
  $output true
  method void NotifyZoomLevelUpdate()
  {
    IsZoomInOutStatusReceived = true;
    ZoomLevelUpdateEventHandler.Trigger( null, false );
  }

  $rect <720,360,920,400>
  object Core::SystemEvent DialogEventUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,360,720,400>
  $output true
  method void NotifyDialogEventUpdate()
  {
    DialogEventUpdateEvent.Trigger( null, false );
  }

  $rect <730,820,930,860>
  method Enum::NaviDialogType GetNaviDialogType()
  {
    $if !$prototyper
      var Enum::NaviDialogType NaviDialog;
      native( NaviDialog )
      {
        #if( !UNIT_TEST_NAVI )
          NaviDialog = NAVI_get_dialog_type();
        #else
          NaviDialog = TEST_navi_get_dialog_type();
        #endif
      }
      return NaviDialog;
    $else
      return Enum::NaviDialogType.DIALOG_TOTAL;
    $endif
  }

  $rect <730,860,930,900>
  method string GetNaviDialogMessage()
  {
    $if !$prototyper
      var string NaviDialogMessage;
      native( NaviDialogMessage )
      {
        navi_dialog_type* navi_dialog_obj = NULL;
        navi_dialog_obj = NAVI_get_navi_dialog_obj();
        NaviDialogMessage  = EwNewStringUtf8( ( const unsigned char* )navi_dialog_obj->dialog_message, ( int )strlen( navi_dialog_obj->dialog_message ) );
      }
      return NaviDialogMessage;
    $else
      return "";
    $endif
  }

  $rect <410,790,610,830>
  method void SendSelectedDialog( arg Enum::NaviButtonType aNewButtonType )
  {
    $if !$prototyper
      var Enum::NaviButtonType ButtonType = aNewButtonType;
      native( ButtonType )
      {
        NAVI_send_selected_dialog( ButtonType );
      }
    $else
      aNewButtonType; // suppress warning.
    $endif
  }

  $rect <720,400,920,440>
  object Core::SystemEvent ViaPointUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,400,720,440>
  $output true
  method void NotifyViaPointUpdate()
  {
    ViaPointUpdateEvent.Trigger( null, false );
  }

  $rect <730,900,930,940>
  method bool GetNaviConnectStatus()
  {
    $if( !$prototyper )
      var bool IsNaviAppConnected= false;
      native( IsNaviAppConnected )
      {
        IsNaviAppConnected = NAVI_get_connect_status();
      }
      return IsNaviAppConnected;
    $else
      return false;
    $endif
  }

  $rect <80,710,280,750>
  method void StopRoute()
  {
    $if !$prototyper
      native
      {
        NAVI_send_stop_route_request();
      }
    $endif
  }

  $rect <80,750,280,790>
  method void SkipNextStop()
  {
    $if !$prototyper
      native
      {
        NAVI_send_skip_next_waypoint_request();
      }
    $endif
  }

  $rect <80,790,280,830>
  method void GoHome( arg Enum::NaviRouteOptionType aRouteOption )
  {
    $if !$prototyper
      native( aRouteOption )
      {
        NAVI_send_go_home_request( aRouteOption );
      }
    $endif
  }

  $rect <80,830,280,870>
  method void GoOffice( arg Enum::NaviRouteOptionType aRouteOption )
  {
    $if !$prototyper
      native( aRouteOption )
      {
        NAVI_send_go_office_request( aRouteOption );
      }
    $endif
  }

  $rect <410,710,610,750>
  method void ZoomInRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_send_zoom_in_request();
      }
    $endif
  }

  $rect <410,750,610,790>
  method void ZoomOutRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_send_zoom_out_request();
      }
    $endif
  }

  $rect <730,980,930,1020>
  method Enum::NaviZoomInOutStatusType GetZoomInOutStatus()
  {
    $if !$prototyper
      var Enum::NaviZoomInOutStatusType ZoomInOutStatus;
      native( ZoomInOutStatus )
      {
        ZoomInOutStatus = NAVI_get_zoom_inout_status();
      }
      return ZoomInOutStatus;
    $else
      return Enum::NaviZoomInOutStatusType.NORMAL;
    $endif
  }

  $rect <50,100,250,140>
  var bool IsZoomInOutStatusReceived = true;

  $rect <720,440,920,480>
  object Core::SystemEvent AlertDistanceUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,440,720,480>
  $output true
  method void NotifyAlertDistanceUpdate()
  {
    AlertDistanceUpdateEvent.Trigger( null, false );
  }

  $rect <730,940,930,980>
  method string GetAlertDistance()
  {
    $if !$prototyper
      var string Dist;
      native( Dist )
      {
        char* dist;
        NAVI_get_alert_distance( &dist );
        Dist = EwNewStringUtf8( ( const unsigned char* )dist, ( int )strlen( dist ) );
      }
      return Dist;
    $endif
  }

  $rect <720,480,920,520>
  object Core::SystemEvent ConnectStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,480,720,520>
  $output true
  method void NotifyNaviConnectUpdate()
  {
    ConnectStatusUpdateEvent.Trigger( null, false );
  }

  $rect <720,520,920,560>
  object Core::SystemEvent DisconnectStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,520,720,560>
  $output true
  method void NotifyNaviDisconnectUpdate()
  {
    DisconnectStatusUpdateEvent.Trigger( null, false );
  }

  $rect <80,910,280,950>
  method void StartMapFrameRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_start_map_update();
      }
    $endif
  }

  $rect <410,830,610,870>
  method bool IsTbtMessageDisplayed()
  {
    $if( !$prototyper )
      var bool ShowTbtMessage = false;
      native( ShowTbtMessage )
      {
        ShowTbtMessage = NAVI_is_tbt_message_displayed();
      }
      return ShowTbtMessage;
    $else
      return false;
    $endif
  }

  $rect <730,780,930,820>
  method int32 GetTbtListSize()
  {
    $if( !$prototyper )
      var int32 TbtListSize;
      native( TbtListSize )
      {
        TbtListSize = NAVI_get_tbt_list_size();
      }
      return TbtListSize;
    $else
      return 0;
    $endif
  }

  // System Events
  note group Note
  {
    attr Bounds = <20,220,1010,650>;
  }

  // Methods
  note group Note1
  {
    attr Bounds = <20,670,1190,1240>;
  }

  // Variables
  note group Note2
  {
    attr Bounds = <20,10,1010,200>;
  }

  $rect <270,40,470,80>
  var bool IsNaviLoadingDialogDisplayed = false;

  $rect <720,560,920,600>
  object Core::SystemEvent PoiListUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <520,560,720,600>
  $output true
  method void NotifyPoiListUpdate()
  {
    PoiListUpdateEvent.Trigger( null, false );
  }

  $rect <80,990,280,1030>
  method int32 GetPoiListSize()
  {
    $if( !$prototyper )
      var int32 PoiListSize;
      native( PoiListSize )
      {
        PoiListSize = NAVI_get_poi_list_size();
      }
      return PoiListSize;
    $else
      return 0;
    $endif
  }

  $rect <80,950,280,990>
  method DeviceInterface::NaviPoiDataClass GetNaviPoiData( arg int32 aPoiItemIdx )
  {
    var DeviceInterface::NaviPoiDataClass NaviPoiData = new DeviceInterface::NaviPoiDataClass;

    $if !$prototyper
      native( NaviPoiData, aPoiItemIdx )
      {
        float distance;
        char* dist_unit;
        char* description;
        NAVI_get_poi_item( aPoiItemIdx, &distance, &dist_unit, &description );
        NaviPoiData->Distance = distance;
        NaviPoiData->DistUnit = EwNewStringUtf8( ( const unsigned char* )dist_unit, ( int )strlen( dist_unit ) );
        NaviPoiData->PoiTitle = EwNewStringUtf8( ( const unsigned char* )description, ( int )strlen( description ) );
      }
    $else
      aPoiItemIdx; // suppress warning.
    $endif

    return NaviPoiData;
  }

  $rect <410,950,610,990>
  method void PoiListRequest( arg Enum::NaviPoiListType PoiListType, arg bool aEnabled )
  {
    $if !$prototyper
      native( PoiListType, aEnabled )
      {
        NAVI_poi_list_request( PoiListType, aEnabled );
      }
    $endif
  }

  $rect <410,990,610,1030>
  method void StartRoute( arg int32 aPoiIdx, arg Enum::NaviRouteOptionType aRouteOptionType )
  {
    $if !$prototyper
      native( aPoiIdx, aRouteOptionType )
      {
        NAVI_send_start_route_request( aPoiIdx, aRouteOptionType );
      }
    $endif
  }

  $rect <270,100,470,140>
  var Enum::NaviPoiListType CurrentPoiListType;

  $rect <560,40,760,80>
  var Enum::NaviRouteOptionTriggerItem RouteOptionTriggerItem;

  $rect <560,100,760,140>
  var int32 CurrentSelectPoiIdx;

  $rect <730,1020,930,1060>
  method int32 GetNaviDialogTimeOut()
  {
    $if !$prototyper
      var int32 NaviDialogTimeOut;
      native( NaviDialogTimeOut )
      {
        navi_dialog_type* navi_dialog_obj = NULL;
        navi_dialog_obj = NAVI_get_navi_dialog_obj();
        NaviDialogTimeOut = navi_dialog_obj->timeout;
      }
      return NaviDialogTimeOut;
    $else
      return 0;
    $endif
  }

  $rect <730,1060,930,1100>
  method Enum::NaviButtonType GetNaviDialogDefaultButton()
  {
    $if !$prototyper
      var Enum::NaviButtonType DefaultButton;
      native( DefaultButton )
      {
        navi_dialog_type* navi_dialog_obj = NULL;
        navi_dialog_obj = NAVI_get_navi_dialog_obj();
        DefaultButton = navi_dialog_obj->default_selected_button;
      }
      return DefaultButton;
    $else
      return Enum::NaviButtonType.TOTAL;
    $endif
  }

  $rect <780,40,980,80>
  property bool NaviAppSppConnected;

  $rect <780,90,980,130>
  onget NaviAppSppConnected
  {
    $if !$prototyper
      var bool IsNaviAppSppConnected = false;
      native( IsNaviAppSppConnected )
      {
        IsNaviAppSppConnected = CM_get_spp_connection_status( CM_APP_NAVILITE );
      }
      return IsNaviAppSppConnected;
    $else
      return pure NaviAppSppConnected;
    $endif
  }

  $rect <240,600,440,640>
  object Core::SystemEvent BtThroughputStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,600,240,640>
  $output true
  method void NotifyBtThroughputStatusUpdate()
  {
    BtThroughputStatusUpdateEvent.Trigger( null, false );
  }

  $rect <80,1030,280,1070>
  method Enum::NaviBtThroughputUIMode GetBtThroughputUIMode()
  {
    $if !$prototyper
      var Enum::NaviBtThroughputUIMode BtThroughputUIMode;
      native( BtThroughputUIMode )
      {
        #if( !UNIT_TEST_NAVI )
          BtThroughputUIMode = NAVI_get_navi_bt_throughput_ui_mode();
        #else
          BtThroughputUIMode = TEST_get_bt_throughput_status();
        #endif
      }
      return BtThroughputUIMode;
    $else
      return 0;
    $endif
  }

  $rect <80,1070,280,1110>
  method void StopContentRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_stop_content_update();
      }
    $endif
  }

  $rect <80,1110,280,1150>
  method void StartContentRequest()
  {
    $if !$prototyper
      native
      {
        NAVI_start_content_update();
      }
    $endif
  }

  $rect <730,1100,930,1140>
  method bool IsJcvReceived()
  {
    $if !$prototyper
      var bool ShowJcv = false;
      native( ShowJcv )
      {
        ShowJcv = NAVI_is_Jcv_recevied();
      }
      return ShowJcv;
    $else
      return false;
    $endif
  }

  $rect <410,1030,610,1070>
  method bool IsReRouteAlertReceived()
  {
    $if !$prototyper
      var bool ReRouteEventStatus = false;
      native( ReRouteEventStatus )
      {
        ReRouteEventStatus = NAVI_is_specified_event_received( EnumNaviAlertTypeTRAFFIC, EnumNaviCameraTypeTYPE_UNDEFINED );
      }
      return ReRouteEventStatus;
    $else
      return false;
    $endif
  }

  $rect <410,1070,610,1110>
  method void RemoteReRouteAlert()
  {
    $if !$prototyper
      native
      {
        NAVI_remove_specified_event( EnumNaviAlertTypeTRAFFIC, EnumNaviCameraTypeTYPE_UNDEFINED );
      }
    $endif
  }

  $rect <410,1110,610,1150>
  method bool IsSpeedingAlertReceived()
  {
    $if !$prototyper
      var bool SpeedingEventStatus = false;
      native( SpeedingEventStatus )
      {
        SpeedingEventStatus = NAVI_is_specified_event_received( EnumNaviAlertTypeSPEED, EnumNaviCameraTypeTYPE_UNDEFINED );
      }
      return SpeedingEventStatus;
    $else
      return false;
    $endif
  }

  $rect <970,710,1170,750>
  method string GetRerouteAlertMessage()
  {
    $if !$prototyper
      var string Message;
      native( Message )
      {
        char* reroute_message;
        NAVI_get_reroute_alert_message( &reroute_message );
        Message = EwNewStringUtf8( ( const unsigned char* )reroute_message, ( int )strlen( reroute_message ) );
      }
      return Message;
    $endif
  }

  $rect <970,750,1170,790>
  method bool GetAlertDisplayStatus()
  {
    $if !$prototyper
      var bool AlertDisplayStatus = false;
      native( AlertDisplayStatus )
      {
        AlertDisplayStatus = NAVI_get_alert_display_status();
      }
      return AlertDisplayStatus;
    $else
      return false;
    $endif
  }

  $rect <970,790,1170,830>
  method void EnableAlertDisplayFlag()
  {
    $if !$prototyper
      native
      {
        NAVI_enable_alert_display_flag();
      }
    $endif
  }

  $rect <50,150,250,190>
  var bool IsBtThoughputModeActivateFromMap = false;

  $rect <970,830,1170,870>
  method void RemoveSpeedingAlert()
  {
    $if !$prototyper
      native
      {
        NAVI_remove_specified_event( EnumNaviAlertTypeSPEED, EnumNaviCameraTypeTYPE_UNDEFINED );
      }
    $endif
  }

  $rect <970,870,1170,910>
  method bool GetAppInitStatus()
  {
    $if !$prototyper
      var bool IsNaviAppInit= false;
      native( IsNaviAppInit )
      {
        IsNaviAppInit = NAVI_get_app_init_status();
      }
      return IsNaviAppInit;
    $else
      return false;
    $endif
  }

  $rect <970,910,1170,950>
  method void ResetDialogObject()
  {
    $if !$prototyper
      native
      {
        NAVI_reset_dialog_object();
      }
    $endif
  }
}

$rect <20,340,230,380>
autoobject DeviceInterface::NavigationDeviceClass NavigationDevice;

$rect <260,300,500,340>
$output false
class MediaManagerDeviceClass : Templates::DeviceClass
{
  $rect <30,20,230,60>
  property string Title;

  $rect <30,60,230,100>
  onset Title
  {
    // Get song title when receiving from media manager or UI initialization.
    if( IsTitleReceived || IsInit )
    {
      // Remember the property's new value.
      pure Title = value;
    }
    else
    {
      // Fail to receive song title, show "---".
      pure Title = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Title;
  }

  $rect <250,20,450,60>
  property string Album;

  $rect <250,60,450,100>
  onset Album
  {
    // Get album when receiving from media manager or UI initialization.
    if( IsAlbumReceived || IsInit )
    {
      // Remember the property's new value.
      pure Album = value;
    }
    else
    {
      // Fail to receive album, show "---".
      pure Album = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Album;
  }

  $rect <480,20,680,60>
  property string Artist;

  $rect <480,60,680,100>
  onset Artist
  {
    // Get artist when receiving from media manager or UI initialization.
    if( IsArtistReceived || IsInit )
    {
      // Remember the property's new value.
      pure Artist = value;
    }
    else
    {
      // Fail to receive artist, show "---".
      pure Artist = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Artist;
  }

  $rect <720,60,920,100>
  property int32 DurationTimeSec = 0;

  $rect <720,470,940,510>
  method void SendRemoteCommand( arg Enum::MusicControlType MusicCommandType )
  {
    $if !$prototyper
    native( MusicCommandType )
    {
      ams_remote_command cmd = AMS_REMOTE_COMMAND_CNT;

      switch( MusicCommandType )
      {
        case EnumMusicControlTypePlay:
          cmd = AMS_REMOTE_COMMAND_PLAY;
          break;
        case EnumMusicControlTypePause:
          cmd = AMS_REMOTE_COMMAND_PAUSE;
          break;
        case EnumMusicControlTypeNextTrack:
          cmd = AMS_REMOTE_COMMAND_NEXT_TRACK;
          break;
        case EnumMusicControlTypePrevTrack:
          cmd = AMS_REMOTE_COMMAND_PREVIOUS_TRACK;
          break;
        case EnumMusicControlTypeVolumeUp:
          cmd = AMS_REMOTE_COMMAND_VOLUME_UP;
          break;
        case EnumMusicControlTypeVolumeDown:
          cmd = AMS_REMOTE_COMMAND_VOLUME_DOWN;
          break;
        default:
          break;
      }
      ew_send_command( cmd );
    }
    $endif
  }

  $rect <720,20,920,60>
  property int32 ElapsedTimeSec = 0;

  // An interface to set/get data from device
  note group Note1
  {
    attr Bounds = <10,430,1170,540>;
  }

  $rect <350,240,550,280>
  $output true
  method void NotifyTitleChanged( arg string aTitle )
  {
    trace "NotifyTitleChanged: " + aTitle;
    IsTitleReceived = true;
    Title = aTitle;
  }

  $rect <350,320,550,360>
  $output true
  method void NotifyArtistChanged( arg string aArtist )
  {
    trace "NotifyArtistChanged: " + aArtist;
    IsArtistReceived = true;
    Artist = aArtist;
  }

  $rect <350,280,550,320>
  $output true
  method void NotifyAlbumChanged( arg string aAlbum )
  {
    trace "NotifyAlbumChanged: " + aAlbum;
    IsAlbumReceived = true;
    Album = aAlbum;
  }

  $rect <50,470,250,510>
  method int32 GetPlayBackStateInfo()
  {
    var int32 PlayBackState = 0;
    $if !$prototyper
    native ( PlayBackState )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      PlayBackState = mp_state->playback_state;
    }
    $endif
    return PlayBackState;
  }

  $rect <270,470,470,510>
  method void GetPlaybackInfo()
  {
    var int32 ela_time = 0;
    var int32 dur = 0;
    $if !$prototyper
    native ( ela_time, dur )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      ela_time = mp_state->current_elapsed_time_sec;
      dur = mp_state->duration_sec;
    }
    $endif
    ElapsedTimeSec = ela_time;
    DurationTimeSec = dur;
  }

  $rect <500,470,700,510>
  method void GetTrackInfo()
  {
    var string media_artist = "";
    var string media_album = "";
    var string media_title = "";
    $if !$prototyper
    native ( media_artist, media_album, media_title )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      media_artist = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_artist, ( int )strlen( mp_state->str.track_artist ) );
      media_album = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_album, ( int )strlen( mp_state->str.track_album ) );
      media_title = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_title, ( int )strlen( mp_state->str.track_title ) );
    }
    $endif
    Artist = media_artist;
    Album = media_album;
    Title = media_title;
  }

  $rect <720,240,920,280>
  var bool IsInit = false;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,280,320,320>
  $output true
  method void NotifyPlayBackTimeChanged( arg int32 aElapsedTimeSec, arg int32 aDurationTimeSec )
  {
    trace "ElapsedTime: ", aElapsedTimeSec;
    trace "Duration: ", aDurationTimeSec;
    ElapsedTimeSec = aElapsedTimeSec;
    DurationTimeSec = aDurationTimeSec;

    NotifyPlayBackTimeChangedSystemEvent.Trigger( null, false );
  }

  $rect <30,240,320,280>
  object Core::SystemEvent NotifyPlayBackTimeChangedSystemEvent;

  $rect <720,280,920,320>
  var bool IsTitleReceived = false;

  $rect <720,320,920,360>
  var bool IsAlbumReceived = false;

  $rect <720,360,920,400>
  var bool IsArtistReceived = false;

  $rect <50,560,250,600>
  object Core::SystemEvent NotifyMotoConMusicUpdatedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,560,460,600>
  $output true
  method void NotfiyMotoConMusicInfoUpdated()
  {
    IsTitleReceived = true;
    IsAlbumReceived = true;
    IsArtistReceived = true;
    NotifyMotoConMusicUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <470,610,670,650>
  method bool IsAmsConnected()
  {
    $if !$prototyper
      var bool AmsConnected = false;
      native( AmsConnected )
      {
        AmsConnected = BC_ams_is_ams_connected();
      }
      return AmsConnected;
    $else
      return false;
    $endif
  }

  $rect <50,610,250,650>
  object Core::SystemEvent NotifyAmsBleConnectedStatusSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,610,460,650>
  $output true
  method void NotifyAmsBleConnectedStatusChanged()
  {
    NotifyAmsBleConnectedStatusSystemEvent.Trigger( null, false );
  }

  $rect <50,660,250,700>
  object Core::SystemEvent NotifyMediaVolumeUpdateSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,660,460,700>
  $output true
  method void NotifyMediaVolumeUpdated()
  {
    NotifyMediaVolumeUpdateSystemEvent.Trigger( null, false );
  }

  $rect <960,470,1160,510>
  method float GetVolume()
  {
    var float Volume;
    $if !$prototyper
    native ( Volume )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      Volume = mp_state->playback_volume;
    }
    $endif
    return Volume;

  }
}

$rect <261,344,461,384>
autoobject DeviceInterface::MediaManagerDeviceClass MediaManagerDevice;

$rect <810,70,1010,110>
$output false
class BluetoothDeviceClass : Templates::DeviceClass
{
  // Properties
  note group Note1
  {
    attr Bounds = <10,10,1420,260>;
  }

  // Paired Device List & Operation
  note group Note3
  {
    attr Bounds = <410,280,1020,800>;
  }

  $rect <430,520,643,560>
  method void GetPairedDeviceList()
  {
    $if !$prototyper
      var int32  DevIdx;
      var string DevName;
      var uint64 DevAddr;

      for( DevIdx = 0; DevIdx < PairedDeviceNum; DevIdx++ )
      {
        native( DevIdx, DevName, DevAddr )
        {
          BT_device_info_t device_info;
          uint8_t* stuffed_str = NULL;
          int32_t  stuffed_str_len;

          if( BT_STATUS_OK == BT_get_paired_device_info( DevIdx, &device_info ) )
          {
            stuffed_str_len = ew_handle_special_characters( device_info.device_name, &stuffed_str );
            if( ( 0 < stuffed_str_len ) && ( NULL != stuffed_str ) )
            {
              DevName = EwNewStringUtf8( stuffed_str, stuffed_str_len );
            }

            DevAddr = 0;
            for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
            {
              DevAddr = ( DevAddr << 8 ) | device_info.bd_addr[i];
            }
          }
        }

        var DeviceInterface::BtPairedDeviceInfo DevInfo = new DeviceInterface::BtPairedDeviceInfo;
        DevInfo.DeviceName = DevName;
        DevInfo.DeviceAddress = DevAddr;
        PairedDeviceList[DevIdx] = DevInfo;
      }
    $endif
  }

  $rect <250,50,450,90>
  property bool Discoverable = false;

  $rect <250,100,450,140>
  onset Discoverable
  {
    if( pure Discoverable != value )
    {
      pure Discoverable = value;
      $if !$prototyper
        native
        {
          BT_set_discoverable_state( (bool)value );
        }
      $endif
    }
  }

  $rect <250,150,450,190>
  onget Discoverable
  {
    $if !$prototyper
      var bool IsDiscoverable = false;
      native( IsDiscoverable )
      {
        IsDiscoverable = BT_get_discoverable_state();
      }
      pure Discoverable = IsDiscoverable;
    $endif

    return pure Discoverable;
  }

  $rect <30,50,240,90>
  property bool BluetoothEnabled = false;

  $rect <30,100,240,140>
  onset BluetoothEnabled
  {
    if( pure BluetoothEnabled != value )
    {
      pure BluetoothEnabled = value;
      $if !$prototyper
        native
        {
          BT_set_enable_state( (bool)value );
        }
      $endif
    }
  }

  $rect <30,150,240,190>
  onget BluetoothEnabled
  {
    $if !$prototyper
      var bool EnableStatus = false;
      native( EnableStatus )
      {
        EnableStatus = BT_get_enable_state();
      }
      pure BluetoothEnabled = EnableStatus;
    $endif

    return pure BluetoothEnabled;
  }

  $rect <460,50,660,90>
  property bool AutoConnect;

  $rect <460,100,660,140>
  onset AutoConnect
  {
    if( pure AutoConnect != value )
    {
      pure AutoConnect = value;
      $if !$prototyper
        native
        {
          CM_set_auto_connect_state( value );
        }
      $endif
    }
  }

  $rect <460,150,660,190>
  onget AutoConnect
  {
    $if !$prototyper
      var bool IsAutoConnect = false;
      native( IsAutoConnect )
      {
        IsAutoConnect = CM_get_auto_connect_state();
      }
      pure AutoConnect = IsAutoConnect;
    $endif

    return pure AutoConnect;
  }

  $rect <750,420,970,460>
  method void UnpairDevice( arg uint64 aDeviceAddress )
  {
    DeleteFromPairedDeviceList( aDeviceAddress );

    $if !$prototyper
      var uint64 DevAddr = aDeviceAddress;
      native ( DevAddr )
      {
        uint8_t bd_addr[BT_DEVICE_ADDRESS_LEN];
        for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
        {
          bd_addr[BT_DEVICE_ADDRESS_LEN - i - 1] = DevAddr >> ( 8*i );
        }
        BT_delete_paired_device( bd_addr );
      }
    $else
      // suppress warning
      aDeviceAddress;
    $endif
  }

  $rect <940,50,1170,90>
  property string LocalDeviceName;

  $rect <940,100,1170,140>
  onget LocalDeviceName
  {
    var string LocalDevName;
    $if !$prototyper
      native( LocalDevName )
      {
        const uint8_t* device_name = BT_get_local_device_name();
        LocalDevName = EwNewStringUtf8( device_name, (int)strlen( (char*)device_name ) );
      }
    $else
      LocalDevName = "(Device name)";
    $endif
    return LocalDevName;
  }

  $rect <942,150,1172,190>
  property string LocalDeviceAddress;

  $rect <942,200,1172,240>
  onget LocalDeviceAddress
  {
    $if !$prototyper
      var string DeviceAddr = "";
      native( DeviceAddr )
      {
        const uint8_t* bd_addr = BT_get_local_device_address();
        char bd_addr_display[32];
        snprintf( bd_addr_display, 32, "%02x:%02x:%02x:%02x:%02x:%02x", bd_addr[0], bd_addr[1], bd_addr[2], bd_addr[3], bd_addr[4], bd_addr[5] );
        DeviceAddr = EwNewStringAnsi( (const char*)bd_addr_display );
      }
      pure LocalDeviceAddress = DeviceAddr;
    $endif

    return pure LocalDeviceAddress;
  }

  $rect <750,320,970,360>
  method void ConnectPairedDevice( arg uint64 aDeviceAddress )
  {
    $if !$prototyper
      var uint64 DevAddr = aDeviceAddress;
      native ( DevAddr )
      {
        uint8_t bd_addr[BT_DEVICE_ADDRESS_LEN];
        for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
        {
          bd_addr[BT_DEVICE_ADDRESS_LEN - i - 1] = DevAddr >> ( 8*i );
        }
        CM_connect( bd_addr );
      }
    $else
      // suppress warning
      aDeviceAddress;
    $endif
  }

  $rect <750,370,970,410>
  method void DisconnectPairedDevice( arg uint64 aDeviceAddress )
  {
    $if !$prototyper
      var uint64 DevAddr = aDeviceAddress;
      native ( DevAddr )
      {
        uint8_t bd_addr[BT_DEVICE_ADDRESS_LEN];
        for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
        {
          bd_addr[BT_DEVICE_ADDRESS_LEN - i - 1] = DevAddr >> ( 8*i );
        }
        CM_disconnect( bd_addr );
      }
    $else
      // suppress warning
      aDeviceAddress;
    $endif
  }

  $rect <671,50,930,90>
  property bool IsPairedDeviceNumMax;

  $rect <671,100,930,140>
  onget IsPairedDeviceNumMax
  {
    $if !$prototyper
      var bool is_max_paired_device = false;
      native( is_max_paired_device )
      {
         BT_is_paired_device_max_num_reached( (bool*)&is_max_paired_device );
      }
      pure IsPairedDeviceNumMax = is_max_paired_device;
    $endif

    return pure IsPairedDeviceNumMax;
  }

  // Status/Event from BTM / CM
  note group Note4
  {
    attr Bounds = <1040,280,1420,530>;
  }

  // Status/Event from MotoCon
  note group Note6
  {
    attr Bounds = <1040,550,1420,800>;
  }

  $rect <1110,740,1360,780>
  method bool IsMotoconConnected()
  {
    $if !$prototyper
      var bool MotoconConnected = false;
      native( MotoconConnected )
      {
        MotoconConnected = BC_motocon_is_connected();
      }
      return MotoconConnected;
    $else
      return true;
    $endif
  }

  $rect <1110,590,1360,630>
  $output true
  method void NotifyMotoConEventReceived( arg Enum::MotoConRxEvent aEvent )
  {
    var DeviceInterface::MotoConContext MotoConContext = new DeviceInterface::MotoConContext;
    MotoConContext.RxEvent = aEvent;
    MotoConSystemEvent.Trigger( MotoConContext, false );
  }

  $rect <1110,640,1360,680>
  object Core::SystemEvent MotoConSystemEvent;

  $rect <39,330,239,370>
  method uint32 GetBtcPasskey()
  {
    var uint32 Passkey;
    $if !$prototyper
      native( Passkey )
      {
        Passkey = ew_get_btc_passkey();
      }
    $endif
    return Passkey;
  }

  $rect <39,379,269,419>
  method string GetBtcPairingDeviceName()
  {
    var string PairingDeviceName;
    $if !$prototyper
      native( PairingDeviceName )
      {
        uint8_t* btc_pairing_device_name;
        ew_bt_get_btc_connecting_device_name( &btc_pairing_device_name );

        uint8_t *stuffed_str = NULL;
        int32_t stuffed_str_len = ew_handle_special_characters( btc_pairing_device_name, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          PairingDeviceName = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $else
      PairingDeviceName = "(Device name)";
    $endif
    return PairingDeviceName;
  }

  $rect <1110,690,1360,730>
  $output true
  method void SendMotoConCommand( arg Enum::MotoConTx aTxCmd )
  {
    $if !$prototyper
      native( aTxCmd )
      {
        ew_send_motocon_command( aTxCmd );
      }
    $endif
  }

  $rect <1120,320,1340,360>
  $output true
  method void NotifyBtmStatus( arg Enum::BtmStatus aStatus )
  {
    trace "NotifyBtmStatus: ", aStatus;
    var DeviceInterface::BtmStatusContext BtmStatusContext = new DeviceInterface::BtmStatusContext;
    BtmStatusContext.Status = aStatus;
    BtmStatusEvent.Trigger( BtmStatusContext, false );
  }

  $rect <1120,420,1340,460>
  $output true
  method void NotifyConnectionStatus( arg Enum::ConnectionStatus aStatus )
  {
    trace "NotifyConnectionStatus: ", aStatus;
    switch( aStatus )
    {
      case Enum::ConnectionStatus.PAIRED_DEVICE_CHANGED:
      {
        postsignal OnPairedDeviceListUpdatedSlot;
      }
      case Enum::ConnectionStatus.CONNECTED_APP_CHANGED:
      {
        postsignal OnConnectedAppStatusUpdatedSlot;
      }
      default:
      {
        var DeviceInterface::ConnectionStatusContext ConnectionStatusContext = new DeviceInterface::ConnectionStatusContext;
        ConnectionStatusContext.Status = aStatus;
        ConnectionStatusEvent.Trigger( ConnectionStatusContext, false );
      }
    }
  }

  $rect <1120,370,1340,410>
  object Core::SystemEvent BtmStatusEvent;

  $rect <1120,470,1350,510>
  object Core::SystemEvent ConnectionStatusEvent;

  $rect <40,430,370,470>
  method bool IsPairingDeviceYamahaAppSPPConnected()
  {
    var bool Connected = false;
    $if !$prototyper
      native( Connected )
      {
        Connected = CM_get_spp_connection_status( CM_APP_YCONNECT );
      }
    $endif
    return Connected;
  }

  $rect <40,480,320,520>
  method void TriggerConnectionTimeoutTimer()
  {
    $if !$prototyper
      native
      {
        //BTM_start_btm_timeout_timer( BTM_BLE_PAIR_TIMEOUT );
      }
    $endif
  }

  $rect <430,370,630,410>
  array DeviceInterface::BtPairedDeviceInfo PairedDeviceList[ 8 ];

  $rect <430,420,690,460>
  slot OnPairedDeviceListUpdatedSlot
  {
    PairedDeviceNum = GetPairedDeviceNum();
    if( 0 < PairedDeviceNum )
    {
      GetPairedDeviceList();
      signal OnConnectedAppStatusUpdatedSlot;
    }
    else
    {
      NotifyConnectionStatus( Enum::ConnectionStatus.PAIRED_DEVICE_LIST_UPDATED );
    }
  }

  $rect <430,570,730,610>
  slot OnConnectedAppStatusUpdatedSlot
  {
    var int32 i = 0;
    for( i = 0; i < PairedDeviceNum; i++ )
    {
      PairedDeviceList[i].IsNaviAppConnected = GetNaviAppStatus( PairedDeviceList[i].DeviceAddress );
      PairedDeviceList[i].IsYamahaAppConnected = GetYamahaAppStatus( PairedDeviceList[i].DeviceAddress );
    }
    NotifyConnectionStatus( Enum::ConnectionStatus.PAIRED_DEVICE_LIST_UPDATED );
  }

  // Number of paired devices (max 8)
  $rect <430,320,630,360>
  var int32 PairedDeviceNum;

  $rect <430,470,630,510>
  method int32 GetPairedDeviceNum()
  {
    var int32 Num = 0;
    $if !$prototyper
      native( Num )
      {
        uint8_t paired_device_num = 0;
        if( BT_STATUS_OK == BT_get_num_paired_devices( &paired_device_num ) )
        {
          Num = paired_device_num;
        }
      }

      if( DeviceInterface::MAX_PAIRED_DEVICE_NUM < Num )
      {
        Num = DeviceInterface::MAX_PAIRED_DEVICE_NUM;
      }
    $endif
    return Num;
  }

  $rect <430,620,650,660>
  method bool GetNaviAppStatus( arg uint64 aAddress )
  {
    var bool IsNaviAppConnected = false;

    $if !$prototyper
      native( aAddress, IsNaviAppConnected )
      {
        uint8_t bd_addr[BT_DEVICE_ADDRESS_LEN];
        for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
        {
          bd_addr[i] = aAddress >> ( 8 * i );
        }
        IsNaviAppConnected = CM_get_app_connection_status( CM_APP_NAVILITE, bd_addr );
      }
    $else
      // suppress warning
      aAddress;
    $endif

    return IsNaviAppConnected;
  }

  $rect <430,670,650,710>
  method bool GetYamahaAppStatus( arg uint64 aAddress )
  {
    var bool IsYamahaAppConnected = false;

    $if !$prototyper
      native( aAddress, IsYamahaAppConnected )
      {
        uint8_t bd_addr[BT_DEVICE_ADDRESS_LEN];
        for( int32_t i = 0; i < BT_DEVICE_ADDRESS_LEN; i++ )
        {
          bd_addr[i] = aAddress >> ( 8*i );
        }
        IsYamahaAppConnected = CM_get_app_connection_status( CM_APP_YCONNECT, bd_addr );
      }
    $else
      // suppress warning
      aAddress;
    $endif

    return IsYamahaAppConnected;
  }

  $rect <41,530,240,570>
  method void ConfirmPasskey( arg bool aResult )
  {
    $if !$prototyper
      var bool aConfirmedResult = aResult;
      native( aConfirmedResult )
      {
        BT_accept_pairing( aConfirmedResult );
      }
    $else
      aResult; // suppress warning
    $endif
  }

  // Pairing Operation
  note group Note5
  {
    attr Bounds = <10,280,390,800>;
  }

  $rect <1182,50,1382,90>
  property string BtSoftwareVersion;

  $rect <1182,100,1402,140>
  onget BtSoftwareVersion
  {
    $if !$prototyper
      var string bt_sw_version = "";

      native( bt_sw_version )
      {
        uint8_t major = 0;
        uint8_t minor = 0;
        BT_get_sw_version( &major, &minor );

        char version[32];
        snprintf( version, 32, "%1u.%u", major, minor );
        bt_sw_version = EwNewStringAnsi( version );
      }

      pure BtSoftwareVersion = bt_sw_version;
    $endif

    return pure BtSoftwareVersion;
  }

  // BT log level of BT_log_severity_e type, default is BT_LOG_INFO
  $rect <1182,150,1382,190>
  property int32 LogLevel = 3;

  $rect <1182,200,1382,240>
  onset LogLevel
  {
    if( pure LogLevel != value )
    {
      pure LogLevel = value;
      $if !$prototyper
        var bool BtLogLevel = value;
        native( BtLogLevel )
        {
          BT_set_log_level( BtLogLevel );
        }
      $endif
    }
  }

  $rect <750,470,1000,510>
  method void DeleteFromPairedDeviceList( arg uint64 aDeviceAddress )
  {
    var int32 i;
    var int32 FoundIdx = -1;

    for( i = 0; i < PairedDeviceNum; i++ )
    {
      if( PairedDeviceList[i].DeviceAddress == aDeviceAddress )
      {
        FoundIdx = i;
        break;
      }
    }

    if( 0 <= FoundIdx )
    {
      for( i = FoundIdx; i < ( PairedDeviceNum - 1 ); i++ )
      {
        PairedDeviceList[i].DeviceName = PairedDeviceList[i+1].DeviceName;
        PairedDeviceList[i].DeviceAddress = PairedDeviceList[i+1].DeviceAddress;
        PairedDeviceList[i].IsNaviAppConnected = PairedDeviceList[i+1].IsNaviAppConnected;
        PairedDeviceList[i].IsYamahaAppConnected = PairedDeviceList[i+1].IsYamahaAppConnected;
      }

      PairedDeviceNum--;
      NotifyConnectionStatus( Enum::ConnectionStatus.PAIRED_DEVICE_LIST_UPDATED );
    }
  }

  $rect <40,580,240,620>
  property int32 PairingFailCount;
}

$rect <810,110,1010,150>
autoobject DeviceInterface::BluetoothDeviceClass BluetoothDevice;

$rect <810,150,1010,190>
$output false
class BtPairedDeviceInfo
{
  $rect <20,10,220,50>
  var string DeviceName;

  $rect <20,60,220,100>
  var bool IsNaviAppConnected;

  $rect <20,110,250,150>
  var bool IsYamahaAppConnected;

  $rect <20,160,220,200>
  var uint64 DeviceAddress;
}

$rect <20,150,220,190>
$output false
class RtcTime
{
  $rect <20,10,220,50>
  var uint16 Year;

  $rect <20,50,220,90>
  var uint8 Month;

  $rect <20,90,220,130>
  var uint8 Day;

  $rect <20,130,220,170>
  var uint8 Hour;

  $rect <20,170,220,210>
  var uint8 Minute;

  $rect <20,210,220,250>
  var uint8 Second;
}

$rect <560,110,760,150>
$output false
class VehicleDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,100,310,140>
  object Core::SystemEvent DDModeStateChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,50,260,90>
  $output true
  method void NotifyDDModeStateChanged()
  {
    DDModeStateChangedSystemEvent.Trigger( null, false );
  }

  // Driver Distraction Mode System Event
  note group Note2
  {
    attr Bounds = <0,0,560,160>;
  }

  $rect <320,50,540,90>
  property bool DDModeActivated;

  $rect <320,100,540,140>
  onget DDModeActivated
  {
    $if !$prototyper
      var bool IsActivated = false;

      native( IsActivated )
      {
        IsActivated = VI_is_dd_mode_activated();
      }

      return IsActivated;
    $else
      return pure DDModeActivated;
    $endif
  }

  $rect <20,180,260,220>
  method bool IsVehicleFunctionSupported( arg Enum::VehicleSupportedFunction aVehicleFeature )
  {
    var bool IsSupported = false;

    $if !$prototyper
      var int32 FeatureId = (int32)aVehicleFeature;
      native( IsSupported, FeatureId )
      {
        IsSupported = VI_is_function_supported( FeatureId );
      }
    $else
      // for screenshot
      if( Enum::VehicleSupportedFunction.TIRE_FRONT == aVehicleFeature ||
          Enum::VehicleSupportedFunction.CLOCK == aVehicleFeature ||
          Enum::VehicleSupportedFunction.GRIP_WARMER == aVehicleFeature ||
          Enum::VehicleSupportedFunction.SEAT_HEATER == aVehicleFeature ||
          Enum::VehicleSupportedFunction.AIR_TEMPERATURE == aVehicleFeature ||
          Enum::VehicleSupportedFunction.AVG_FUEL == aVehicleFeature ||
          Enum::VehicleSupportedFunction.AVG_SPEED == aVehicleFeature ||
          Enum::VehicleSupportedFunction.TRIP1 == aVehicleFeature ||
          Enum::VehicleSupportedFunction.TRIP2 == aVehicleFeature ||
          Enum::VehicleSupportedFunction.F_TRIP == aVehicleFeature )
      {
        IsSupported = true;
      }
    $endif

    return IsSupported;
  }

  $rect <280,180,480,220>
  method void SetData( arg Enum::VehicleTxType aVehicleTxType, arg uint32 aData )
  {
    $if !$prototyper
      var int32 TxTypeId = ( int32 )aVehicleTxType;
      native( aData, TxTypeId )
      {
        VI_set_tx_data( TxTypeId, aData );
      }
    $else
      trace "set vi tx data ", aVehicleTxType, " ", aData;
    $endif
  }

  $rect <280,230,480,270>
  method DeviceInterface::VehicleDataClass GetData( arg Enum::VehicleRxType aVehicleRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;

    $if !$prototyper
      if( Enum::VehicleRxType.FUEL_RATE_INSTANT == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_AVERAGE == aVehicleRxType ||
          Enum::VehicleRxType.ODOMETER_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP1_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP2_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_CONSUMPTION == aVehicleRxType ||
          Enum::VehicleRxType.AIR_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.COOLANT_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.BATTERY_VOLTAGE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP_F_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TIRE_FRONT == aVehicleRxType ||
          Enum::VehicleRxType.TIRE_REAR == aVehicleRxType ||
          Enum::VehicleRxType.TIRE_FRONT_LEFT == aVehicleRxType ||
          Enum::VehicleRxType.TIRE_FRONT_RIGHT == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_AVERAGE_UNIT_CONVERTED == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_INSTANT_UNIT_CONVERTED == aVehicleRxType )
      {
        VehicleData.DataType = Enum::DataType.FLOAT;
      }

      var int32 RxTypeId = ( int32 )aVehicleRxType;
      var bool  Valid = false;

      if( Enum::DataType.FLOAT == VehicleData.DataType )
      {
        var float RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          float rx_data = 0;
          Valid = VI_get_rx_data_float( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataFloat = RxData;
      }
      else
      {
        var uint32 RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          uint32_t rx_data = 0;
          Valid = VI_get_rx_data_uint( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataUInt32 = RxData;
      }

      VehicleData.Valid = Valid;
    $else
      if( Enum::VehicleRxType.GRIP_WARMER_STATUS == aVehicleRxType ||
          Enum::VehicleRxType.SEAT_HEATER_STATUS == aVehicleRxType )
      {
        VehicleData.DataUInt32 = SeatHeater_GripWarmer::HIGHEST_STATUS;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.AIR_TEMPERATURE == aVehicleRxType )
      {
        VehicleData.DataFloat = 25.0;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.SEAT_HEATER_STATUS == aVehicleRxType )
      {
        VehicleData.DataUInt32 = SeatHeater_GripWarmer::HIGHEST_STATUS;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.FUEL_RATE_AVERAGE == aVehicleRxType )
      {
        VehicleData.DataFloat = 22.8;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.FUEL_CONSUMPTION_UNIT == aVehicleRxType )
      {
        VehicleData.DataUInt32 = Enum::MeterFuelConsumptionUnit.L_PER_100KM;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.AVERAGE_SPEED == aVehicleRxType )
      {
        VehicleData.DataUInt32 = 120;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.TRIP_TIME == aVehicleRxType )
      {
        VehicleData.DataUInt32 = 85500; /* 23h 45m */
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.ODOMETER_VALUE == aVehicleRxType )
      {
        VehicleData.DataFloat = 997126;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.TRIP1_VALUE == aVehicleRxType )
      {
        VehicleData.DataFloat = 862.7;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.TRIP2_VALUE == aVehicleRxType )
      {
        VehicleData.DataFloat = 68.0;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.TRIP_F_VALUE == aVehicleRxType )
      {
        VehicleData.DataFloat = 4.7;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.SEAT_HEATER_VALUE_LOW == aVehicleRxType )
      {
        VehicleData.DataUInt32 = 1;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.SEAT_HEATER_VALUE_MIDDLE == aVehicleRxType )
      {
        VehicleData.DataUInt32 = 2;
        VehicleData.Valid = true;
      }
      else if( Enum::VehicleRxType.SEAT_HEATER_VALUE_HIGH == aVehicleRxType )
      {
        VehicleData.DataUInt32 = 3;
        VehicleData.Valid = true;
      }
      else
      {
        VehicleData.Valid = false;
      }
    $endif

    return VehicleData;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,260,270>
  $output true
  method void NotifyDataReceived( arg Enum::VehicleRxType aRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;
    VehicleData.RxType = aRxType;
    VehicleDataReceivedSystemEvent.Trigger( VehicleData, false );
  }

  // This object represents an individual system event.
  $rect <20,280,260,320>
  object Core::SystemEvent VehicleDataReceivedSystemEvent;

  $rect <20,330,220,370>
  var Enum::MeterDisplay CurrentMeterDisplay = Enum::MeterDisplay.TACHOMETER;

  $rect <20,380,220,420>
  var Enum::MileageSettingItem CurrentMileageSetting;

  $rect <20,430,220,470>
  var Enum::FuelSettingItem CurrentFuelSetting;

  $rect <20,480,220,520>
  var Enum::PressureSettingItem CurrentPressureSetting;

  $rect <20,530,220,570>
  var Enum::TemperatureSettingItem CurrentTempSetting;

  $rect <20,580,220,620>
  var Enum::VehicleSupportedFunction CurrentVehicleFunction;

  $rect <280,280,480,320>
  method uint32 ClampDataUInt32( arg uint32 aData, arg uint32 aMin, arg uint32 aMax )
  {
    if( aData < aMin )
    {
      aData = aMin;
    }
    else if( aData > aMax )
    {
      aData = aMax;
    }
    else
    {
      // empty
    }
    return aData;
  }

  $rect <280,330,480,370>
  method float ClampDataFloat( arg float aData, arg float aMin, arg float aMax )
  {
    if( aData < aMin )
    {
      aData = aMin;
    }
    else if( aData > aMax )
    {
      aData = aMax;
    }
    else
    {
      // empty
    }
    return aData;
  }

  $rect <280,380,480,420>
  method float RoundDownDataFloat( arg float aData, arg float aResolution )
  {
    return ( (int32)( aData / aResolution ) ) * aResolution;

  }

  $rect <600,40,800,80>
  property Enum::MileageSettingItem MileageUnit;

  $rect <600,80,800,120>
  onset MileageUnit
  {
    if( pure MileageUnit != value )
    {
      pure MileageUnit = value;
    }
  }

  $rect <600,120,800,160>
  onget MileageUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.MILEAGE_UNIT );
    if( Enum::MileageSettingItem.MILE == VehicleData.DataUInt32 )
    {
      pure MileageUnit = Enum::MileageSettingItem.MILE;
    }
    else
    {
      pure MileageUnit = Enum::MileageSettingItem.KM;
    }

    return pure MileageUnit;
  }

  $rect <830,40,1070,80>
  property Enum::MeterFuelConsumptionUnit FuelConsumptionUnit;

  $rect <830,80,1070,120>
  onset FuelConsumptionUnit
  {
    if ( pure FuelConsumptionUnit == value )
    {
      pure FuelConsumptionUnit = value;
    }
  }

  $rect <830,120,1070,160>
  onget FuelConsumptionUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_CONSUMPTION_UNIT );
    if( (uint32)Enum::MeterFuelConsumptionUnit.TOTAL > VehicleData.DataUInt32 )
    {
      pure FuelConsumptionUnit = (Enum::MeterFuelConsumptionUnit)VehicleData.DataUInt32;
    }
    return pure FuelConsumptionUnit;
  }

  $rect <610,250,830,290>
  property string AvgSpeedStr;

  $rect <610,290,830,330>
  onget AvgSpeedStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.AVERAGE_SPEED );
    if( VehicleData.Valid )
    {
      // convert unit from km to mile
      if( Enum::MileageSettingItem.MILE == MileageUnit )
      {
        VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
      }
      VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_AVERAGE_SPEED );
      pure AvgSpeedStr = string( VehicleData.DataUInt32, 0, 1 );
    }
    else
    {
      pure AvgSpeedStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure AvgSpeedStr;
  }

  $rect <610,350,830,390>
  property string AvgFuelRateStr;

  $rect <610,390,830,430>
  onget AvgFuelRateStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_AVERAGE );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelRate( VehicleData.DataFloat );

      switch( FuelConsumptionUnit )
      {
        case Enum::MeterFuelConsumptionUnit.KM_PER_LITER:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_RATE_KM_PER_LITER );
        }
        case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL,
             Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_AVERAGE_FUEL_MPG );
        }
        case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_FUEL_RATE_LITER_PER_100KM, Settings::MAX_FUEL_RATE_LITER_PER_100KM );
        }
        default:;
      }

      pure AvgFuelRateStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure AvgFuelRateStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure AvgFuelRateStr;
  }

  $rect <610,560,830,600>
  property string FuelConStr;

  $rect <610,600,830,640>
  onget FuelConStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_CONSUMPTION );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelCons( VehicleData.DataFloat );
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_CONSUMPTION );
      pure FuelConStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure FuelConStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure FuelConStr;
  }

  $rect <870,250,1080,290>
  property string TripTimeHourStr;

  $rect <870,290,1080,330>
  onget TripTimeHourStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TRIP_TIME );
    if( VehicleData.Valid )
    {
      var uint32 TripTimeHour = VehicleData.DataUInt32 / 3600;
      if( Settings::MAX_TRIP_TIME_HOUR < TripTimeHour )
      {
        TripTimeHour = Settings::MAX_TRIP_TIME_HOUR;
      }
      pure TripTimeHourStr = string( TripTimeHour );
    }
    else
    {
      pure TripTimeHourStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure TripTimeHourStr;
  }

  $rect <870,350,1090,390>
  property string TripTimeMinuteStr;

  $rect <870,390,1090,430>
  onget TripTimeMinuteStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TRIP_TIME );
    if( VehicleData.Valid )
    {
      var uint32 TripTimeHour = VehicleData.DataUInt32 / 3600;
      if( Settings::MAX_TRIP_TIME_HOUR < TripTimeHour )
      {
        TripTimeHour = Settings::MAX_TRIP_TIME_HOUR;
      }

      var uint32 TripTimeMinute = ( VehicleData.DataUInt32 / 60 ) - ( TripTimeHour ) * 60;
      if( Settings::MAX_TRIP_TIME_MINUTE < TripTimeMinute )
      {
        TripTimeMinute =  Settings::MAX_TRIP_TIME_MINUTE;
      }
      pure TripTimeMinuteStr = string( TripTimeMinute, 2 );
    }
    else
    {
      pure TripTimeMinuteStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure TripTimeMinuteStr;
  }

  // Unit Setting
  note group UnitSettingNote
  {
    attr Bounds = <580,0,1590,180>;
  }

  $rect <1090,40,1300,80>
  property Enum::TemperatureSettingItem TemperatureUnit;

  $rect <1090,80,1300,120>
  onset TemperatureUnit
  {
    if( pure TemperatureUnit != value )
    {
      pure TemperatureUnit = value;
    }
  }

  $rect <1090,120,1300,160>
  onget TemperatureUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TEMPERATURE_UNIT );
    pure TemperatureUnit = (Enum::TemperatureSettingItem)VehicleData.DataUInt32;
    return pure TemperatureUnit;
  }

  $rect <1130,250,1380,290>
  property string CoolantTemperatureStr;

  $rect <1130,290,1380,330>
  onget CoolantTemperatureStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.COOLANT_TEMPERATURE );
    if( VehicleData.Valid )
    {
      if( Settings::COOLANT_HIGH_TEMPERATURE == VehicleData.DataFloat )
      {
        pure CoolantTemperatureStr = Strings::GEN_HIGH_ABBREVIATION;
      }
      else
      {
        var float CoolantTemperature;
        if( Enum::TemperatureSettingItem.TEMP_F == TemperatureUnit )
        {
          CoolantTemperature = VehicleData.DataFloat * 1.8 + 32;
          CoolantTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( CoolantTemperature, Settings::MIN_TEMPERATURE_DEG_F, Settings::MAX_TEMPERATURE_DEG_F );
        }
        else
        {
          CoolantTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_TEMPERATURE_DEG_C, Settings::MAX_TEMPERATURE_DEG_C );
        }

        CoolantTemperature = math_floor( CoolantTemperature );
        pure CoolantTemperatureStr = string( CoolantTemperature, 0, 0 );
      }
    }
    else
    {
      pure CoolantTemperatureStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure CoolantTemperatureStr;
  }

  $rect <610,450,830,490>
  property string InstantFuelRateStr;

  $rect <610,490,830,530>
  onget InstantFuelRateStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_INSTANT );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = ConvertFuelRate( VehicleData.DataFloat );
      switch( FuelConsumptionUnit )
      {
        case Enum::MeterFuelConsumptionUnit.KM_PER_LITER:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_FUEL_RATE_KM_PER_LITER );
        }
        case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL,
             Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, 0, Settings::MAX_AVERAGE_FUEL_MPG );
        }
        case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
        {
          VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_FUEL_RATE_LITER_PER_100KM, Settings::MAX_FUEL_RATE_LITER_PER_100KM );
        }
        default:;
      }
      pure InstantFuelRateStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure InstantFuelRateStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure InstantFuelRateStr;
  }

  $rect <610,710,830,750>
  method float ConvertFuelCons( arg float aFuelCons )
  {
    var float ConvertedFuelCons = aFuelCons;

    switch( FuelConsumptionUnit )
    {
      case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL:
      {
        ConvertedFuelCons = aFuelCons * Unit::LITER_TO_USGAL_SCALE;
        ConvertedFuelCons = DeviceInterface::VehicleDevice.RoundDownDataFloat( ConvertedFuelCons, 0.1 );
      }
      case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
      {
        ConvertedFuelCons = aFuelCons * Unit::LITER_TO_IMPERIAL_GAL_SCALE;
        ConvertedFuelCons = DeviceInterface::VehicleDevice.RoundDownDataFloat( ConvertedFuelCons, 0.1 );
      }
      default:;
    }

    return ConvertedFuelCons;
  }

  $rect <870,450,1090,490>
  property string RangeStr;

  $rect <870,490,1090,530>
  onget RangeStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.RANGE_DISTANCE );
    if( VehicleData.Valid )
    {
      if( 0 == VehicleData.DataUInt32 )
      {
        pure RangeStr = Strings::GEN_LOW_ABBREVIATION;
      }
      else
      {
        // convert unit from km to mile
        if( Enum::MileageSettingItem.MILE == MileageUnit )
        {
          VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
        }
        VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_RANGE );
        pure RangeStr = string( VehicleData.DataUInt32, 0, 1 );
      }
    }
    else
    {
      pure RangeStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure RangeStr;
  }

  $rect <870,560,1090,600>
  property string BatteryStr;

  $rect <870,600,1090,640>
  onget BatteryStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.BATTERY_VOLTAGE );
    if( VehicleData.Valid )
    {
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_BATTERY_VOLTAGE, Settings::MAX_BATTERY_VOLTAGE );
      VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
      pure BatteryStr = string( VehicleData.DataFloat, 0, 1 );
    }
    else
    {
      pure BatteryStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure BatteryStr;
  }

  $rect <1330,40,1530,80>
  property Enum::PressureSettingItem PressureUnit;

  $rect <1330,80,1530,120>
  onset PressureUnit
  {
    if( pure PressureUnit != value )
    {
      pure PressureUnit = value;
    }
  }

  $rect <1330,120,1530,160>
  onget PressureUnit
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.PRESSURE_UNIT );
    pure PressureUnit = (Enum::PressureSettingItem)VehicleData.DataUInt32;
    return pure PressureUnit;
  }

  // Value String
  note group UnitSettingNote1
  {
    attr Bounds = <580,200,1590,830>;
  }

  $rect <610,660,830,700>
  method float ConvertFuelRate( arg float aFuelRate )
  {
    var float ConvertedFuelRate = aFuelRate;

    switch( FuelConsumptionUnit )
    {
      case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL:
      {
        ConvertedFuelRate = aFuelRate * Unit::KM_L_TO_US_GALLON_SCALE;
        ConvertedFuelRate = DeviceInterface::VehicleDevice.RoundDownDataFloat( ConvertedFuelRate, 0.1 );
      }
      case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL:
      {
        ConvertedFuelRate = aFuelRate * Unit::KM_L_TO_IMPERIAL_GALLON_SCALE;
        ConvertedFuelRate = DeviceInterface::VehicleDevice.RoundDownDataFloat( ConvertedFuelRate, 0.1 );
      }
      case Enum::MeterFuelConsumptionUnit.L_PER_100KM:
      {
        if( 0.0 < aFuelRate )
        {
          ConvertedFuelRate = Unit::L_100KM_SCALE_TO_KM_L / aFuelRate;
          ConvertedFuelRate = DeviceInterface::VehicleDevice.RoundDownDataFloat( ConvertedFuelRate, 0.1 );
        }
        else
        {
          ConvertedFuelRate = Settings::MAX_FUEL_CONSUMPTION;
        }
      }
      default:;
    }

    return ConvertedFuelRate;
  }

  $rect <1130,350,1380,390>
  property string AirTemperatureStr;

  $rect <1130,390,1380,430>
  onget AirTemperatureStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.AIR_TEMPERATURE );
    if( VehicleData.Valid )
    {
      var float AirTemperature;
      if( Enum::TemperatureSettingItem.TEMP_F == TemperatureUnit )
      {
        AirTemperature = VehicleData.DataFloat * 1.8 + 32;
        AirTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( AirTemperature, Settings::MIN_TEMPERATURE_DEG_F, Settings::MAX_TEMPERATURE_DEG_F );
      }
      else
      {
        AirTemperature = DeviceInterface::VehicleDevice.ClampDataFloat( VehicleData.DataFloat, Settings::MIN_TEMPERATURE_DEG_C, Settings::MAX_TEMPERATURE_DEG_C );
      }

      AirTemperature = math_floor( AirTemperature );
      pure AirTemperatureStr = string( AirTemperature, 0, 0 );
    }
    else
    {
      pure AirTemperatureStr = Strings::GEN_THREE_HYPHENS;
    }
    return pure AirTemperatureStr;
  }

  $rect <1130,450,1350,490>
  property string CruiseSpeedStr;

  $rect <1130,490,1350,530>
  onget CruiseSpeedStr
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.CRUISE_SPEED );
    if( VehicleData.Valid )
    {
      // convert unit from km to mile
      if( Enum::MileageSettingItem.MILE == MileageUnit )
      {
        VehicleData.DataUInt32 *= Unit::KM_TO_MILE_SCALE;
      }
      VehicleData.DataUInt32 = DeviceInterface::VehicleDevice.ClampDataUInt32( VehicleData.DataUInt32, 0, Settings::MAX_CRUISE_SPEED );
      pure CruiseSpeedStr = string( VehicleData.DataUInt32, 0, 1 );
    }
    else
    {
      pure CruiseSpeedStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure CruiseSpeedStr;
  }

  $rect <20,650,230,690>
  property bool LowFuelWarning;

  $rect <20,690,230,730>
  onget LowFuelWarning
  {
    $if !$prototyper
      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.LOW_FUEL_WARNING );
      if( VehicleData.Valid )
      {
        pure LowFuelWarning = (bool)VehicleData.DataUInt32;
      }

      return pure LowFuelWarning;
    $else
      // for screenshot
      return true;
    $endif
  }

  $rect <1130,560,1360,600>
  property string TireFrontPressureStr;

  $rect <1130,600,1360,640>
  onget TireFrontPressureStr
  {
    pure TireFrontPressureStr = GetTirePressureStr( Enum::VehicleRxType.TIRE_FRONT );
    return pure TireFrontPressureStr;
  }

  $rect <280,430,500,470>
  method uint32 RoundDownDataUint32( arg uint32 aData, arg uint32 aResolution )
  {
    return ( (uint32)( aData / aResolution ) ) * aResolution;

  }

  $rect <1130,760,1360,800>
  method string GetTirePressureStr( arg Enum::VehicleRxType aTireType )
  {
    if( TireSensorEquipped )
    {
      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( aTireType );
      if( 0.0 < VehicleData.DataFloat )
      {
        switch( PressureUnit )
        {
          case Enum::PressureSettingItem.PSI:
          {
            // rown down to zero decimal place
            VehicleData.DataFloat = math_floor( VehicleData.DataFloat );
            pure TireFrontPressureStr = string( VehicleData.DataFloat, 0, 0 );
          }
          case Enum::PressureSettingItem.KPA:
          {
            VehicleData.DataFloat /= Unit::KPA_TO_PSI_GAL_SCALE;
            var uint32 pressure = DeviceInterface::VehicleDevice.RoundDownDataUint32( (uint32)VehicleData.DataFloat, 10 );
            pure TireFrontPressureStr = string( pressure );
          }
          case Enum::PressureSettingItem.KGF_PER_CM2:
          {
            VehicleData.DataFloat /= Unit::KGF_PRE_CM2_TO_PSI_SCALE;
            VehicleData.DataFloat = DeviceInterface::VehicleDevice.RoundDownDataFloat( VehicleData.DataFloat, 0.1 );
            pure TireFrontPressureStr = string( VehicleData.DataFloat, 0, 1 );
          }
          default:;
        }
      }
      else
      {
        pure TireFrontPressureStr = Strings::GEN_THREE_HYPHENS;
      }
    }
    else
    {
      pure TireFrontPressureStr = Strings::GEN_THREE_HYPHENS;
    }

    return pure TireFrontPressureStr;
  }

  $rect <1130,660,1360,700>
  property string TireRearPressureStr;

  $rect <1130,700,1360,740>
  onget TireRearPressureStr
  {
    pure TireRearPressureStr = GetTirePressureStr( Enum::VehicleRxType.TIRE_REAR );
    return pure TireRearPressureStr;
  }

  $rect <20,750,240,790>
  property bool TireSensorEquipped;

  $rect <20,790,250,830>
  onget TireSensorEquipped
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TIRE_SENSOR_EQUIPPED );
    pure TireSensorEquipped = (bool)VehicleData.DataUInt32;
    return pure TireSensorEquipped;
  }

  $rect <20,860,220,900>
  property bool EngineIdling;

  $rect <20,900,220,940>
  onget EngineIdling
  {
    $if !$prototyper
      var bool IsEngineIdling = false;

      native( IsEngineIdling )
      {
        IsEngineIdling = VI_is_engine_idling();
      }

      return IsEngineIdling;
    $else
      return pure EngineIdling;
    $endif
  }

  $rect <280,490,540,530>
  property bool IsTimeoutError2Detected;

  $rect <280,530,540,570>
  onget IsTimeoutError2Detected
  {
    $if !$prototyper
      var bool IsError2Detected = false;
      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TIMEOUT_ERROR2_DETECTED );
      if( VehicleData.DataUInt32 )
      {
        IsError2Detected = true;
      }
      return IsError2Detected;
    $else
      return pure IsTimeoutError2Detected;
    $endif
  }

  $rect <280,580,540,620>
  property bool IsHeaterStatusTimeoutErr1Detected;

  $rect <280,620,540,660>
  onget IsHeaterStatusTimeoutErr1Detected
  {
    var bool Detected = false;
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.HEATER_STATUS_TIMEOUT_ERR1 );
    if( VehicleData.DataUInt32 )
    {
      Detected = true;
    }
    return Detected;
  }

  $rect <280,680,540,720>
  property bool IsResReprogramInfoTimeoutErr1Detected;

  $rect <280,720,540,760>
  onget IsResReprogramInfoTimeoutErr1Detected
  {
    var bool Detected = false;
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.RES_REPGROGRAM_INFO_TIMEOUT_ERR1 );
    if( VehicleData.DataUInt32 )
    {
      Detected = true;
    }
    return Detected;
  }

  $rect <290,800,510,840>
  method void SetTachoColorbaseRect( arg rect aUpperColorbaseRect, arg rect aLowerColorbaseRect )
  {
    $if !$prototyper
      native( aUpperColorbaseRect, aLowerColorbaseRect )
      {
        ew_tacho_set_colorbase_bounds( aUpperColorbaseRect.Point1.X, aUpperColorbaseRect.Point1.Y, aUpperColorbaseRect.Point2.X, aUpperColorbaseRect.Point2.Y,
                                       aLowerColorbaseRect.Point1.X, aLowerColorbaseRect.Point1.Y, aLowerColorbaseRect.Point2.X, aLowerColorbaseRect.Point2.Y );
      }
    $else
      // suppress warning
      aUpperColorbaseRect;
      aLowerColorbaseRect;
    $endif
  }

  $rect <290,850,510,890>
  method void SetTachoYMask( arg int32 aUpperMaskY1, arg int32 aUpperMaskY2, arg int32 aLowerMaskY1, arg int32 aLowerMaskY2 )
  {
    $if !$prototyper
      native( aUpperMaskY1, aUpperMaskY2, aLowerMaskY1, aLowerMaskY2 )
      {
        ew_tacho_set_y_mask( aUpperMaskY1, aUpperMaskY2, aLowerMaskY1, aLowerMaskY2 );
      }
    $else
      // suppress warning
      aUpperMaskY1;
      aUpperMaskY2;
      aLowerMaskY1;
      aLowerMaskY2;
    $endif
  }
}

$rect <560,70,760,110>
autoobject DeviceInterface::VehicleDeviceClass VehicleDevice;

$rect <320,70,520,110>
$output false
class WeatherDeviceClass : Templates::DeviceClass
{
  $rect <110,180,310,220>
  method void GetWeatherInfo( arg int32 aWeaItemIdx )
  {
    $if !$prototyper
      var int32 WTime;
      var int32 WType;
      var int32 WTemp;
      var int32 TempMin;
      var int32 TempMax;
      var int32 RainProb;

      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TEMPERATURE_UNIT );
      var Enum::TemperatureSettingItem WeaTempType = ( Enum::TemperatureSettingItem )VehicleData.DataUInt32;

      native( aWeaItemIdx, WTime, WType, WTemp, TempMin, TempMax, RainProb )
      {
        bc_motocon_weather_info_t* w_obj = NULL;
        #if( !UNIT_TEST_WEA )
          w_obj = ew_get_weather_info_obj( aWeaItemIdx );
        #else
          w_obj = TEST_get_weather_obj( aWeaItemIdx );
        #endif

        WTime = w_obj->time;
        WTemp = (int)w_obj->temperature;
        TempMin = (int)w_obj->temperature_min;
        TempMax = (int)w_obj->temperature_max;
        RainProb = w_obj->rain_probability;

        switch( w_obj->type )
        {
          case BC_MOTOCON_WEATHER_SUNNY:
            WType = EnumWeatherIconTypeSUNNY;
            break;
          case BC_MOTOCON_WEATHER_PARTLY_CLOUDY_DAY:
            WType = EnumWeatherIconTypePARTLY_CLOUDY_DAY;
            break;
          case BC_MOTOCON_WEATHER_CLOUDY_DAY:
            WType = EnumWeatherIconTypeCLOUDY_DAY;
            break;
          case BC_MOTOCON_WEATHER_RAIN:
            WType = EnumWeatherIconTypeRAIN;
            break;
          case BC_MOTOCON_WEATHER_SNOW:
            WType = EnumWeatherIconTypeSNOW;
            break;
          case BC_MOTOCON_WEATHER_WIND:
            WType = EnumWeatherIconTypeWIND;
            break;
          case BC_MOTOCON_WEATHER_RAIN_STORM_MIX:
            WType = EnumWeatherIconTypeRAIN_STORM_MIX;
            break;
          case BC_MOTOCON_WEATHER_RAIN_SNOW_MIX:
            WType = EnumWeatherIconTypeRAIN_SNOW_MIX;
            break;
          case BC_MOTOCON_WEATHER_FOG:
            WType = EnumWeatherIconTypeFOG;
            break;
          case BC_MOTOCON_WEATHER_SMOG:
            WType = EnumWeatherIconTypeSMOG;
            break;
          case BC_MOTOCON_WEATHER_HAIL:
            WType = EnumWeatherIconTypeHAIL;
            break;
          case BC_MOTOCON_WEATHER_SCATTERED_SHOWERS_DAY:
            WType = EnumWeatherIconTypeSCATTERED_SHOWERS_DAY;
            break;
          case BC_MOTOCON_WEATHER_SCATTERED_STORM_DAY:
            WType = EnumWeatherIconTypeSCATTERED_STORM_DAY;
            break;
          case BC_MOTOCON_WEATHER_NO_DATA:
            WType = EnumWeatherIconTypeNO_DATA;
            break;
          case BC_MOTOCON_WEATHER_RAIN_LIGHT:
            WType = EnumWeatherIconTypeRAIN_LIGHT;
            break;
          case BC_MOTOCON_WEATHER_RAIN_HEAVY:
            WType = EnumWeatherIconTypeRAIN_HEAVY;
            break;
          case BC_MOTOCON_WEATHER_SNOW_LIGHT:
            WType = EnumWeatherIconTypeSNOW_LIGHT;
            break;
          case BC_MOTOCON_WEATHER_SNOW_HEAVY:
            WType = EnumWeatherIconTypeSNOW_HEAVY;
            break;
          case BC_MOTOCON_WEATHER_RAIN_SNOW_MIX_LIGHT:
            WType = EnumWeatherIconTypeRAIN_SNOW_MIX_LIGHT;
            break;
          case BC_MOTOCON_WEATHER_RAIN_SNOW_MIX_HEAVY:
            WType = EnumWeatherIconTypeRAIN_SNOW_MIX_HEAVY;
            break;
          case BC_MOTOCON_WEATHER_CLOUDY:
            WType = EnumWeatherIconTypeCLOUDY;
            break;
          case BC_MOTOCON_WEATHER_CLEAR:
            WType = EnumWeatherIconTypeCLEAR;
            break;
          case BC_MOTOCON_WEATHER_PARTLY_CLOUDY_NIGHT:
            WType = EnumWeatherIconTypePARTLY_CLOUDY_NIGHT;
            break;
          case BC_MOTOCON_WEATHER_CLOUDY_NIGHT:
            WType = EnumWeatherIconTypeCLOUDY_NIGHT;
            break;
          case BC_MOTOCON_WEATHER_SCATTERED_SHOWERS_NIGHT:
            WType = EnumWeatherIconTypeSCATTERED_SHOWERS_NIGHT;
            break;
          case BC_MOTOCON_WEATHER_SCATTERED_STORM_NIGHT:
            WType = EnumWeatherIconTypeSCATTERED_STORM_NIGHT;
            break;
          default:
            EwPrint( "Unexpected weather type is received\r\n" );
            break;
        }
      }
      WeatherTime = WTime;
      WeatherType = WType;
      Temperature = ConvertTemperature( WeaTempType, WTemp );
      MinTemperature = ConvertTemperature( WeaTempType, TempMin );
      MaxTemperature = ConvertTemperature( WeaTempType, TempMax );
      RainProbability = RainProb;
    $else
      aWeaItemIdx;
      switch( aWeaItemIdx )
      {
        case 0:
        {
          MinTemperature = 59;
          MaxTemperature = 108;
          RainProbability = 10;
        }
        case 1: /* 1 day */
        {
          RainProbability = 62;
          MinTemperature = 57;
          MaxTemperature = 100;
        }
        case 2: /* 2 day */
        {
          RainProbability = 100;
          MinTemperature = 52;
          MaxTemperature = 63;
        }
        case 3: /* 3 day */
        {
          RainProbability = 82;
          MinTemperature = 50;
          MaxTemperature = 102;
        }
        case 4: /* 4 day */
        {
          RainProbability = 62;
          MinTemperature = 62;
          MaxTemperature = 82;
        }
        case 5: /* 5 day */
        {
          RainProbability = 100;
          MinTemperature = 53;
          MaxTemperature = 87;
        }
        case 6: /* 1h */
        {
          RainProbability = 62;
          Temperature = 67;
        }
        case 7: /* 2h */
        {
          RainProbability = 100;
          Temperature = 82;
        }
        case 8: /* 3h */
        {
          RainProbability = 82;
          Temperature = 108;
        }
        case 9: /* 6 day */
        {
          RainProbability = 82;
          MinTemperature = 52;
          MaxTemperature = 78;
        }
        default:;
      }

      WeatherLocation = "Current location";
      WeatherTime = aWeaItemIdx;
      WeatherType = Enum::WeatherIconType.SUNNY;
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <110,300,330,340>
  $output true
  method void NotifyWeatherInfoUpdated()
  {
    IsWeatherInfoReceived = true;
  }

  $rect <320,180,520,220>
  method void GetWeatherLoc()
  {
    $if !$prototyper
      var string CurrentLoc;

      native( CurrentLoc )
      {
        char* cur_loc;
        #if( !UNIT_TEST_WEA )
          ew_get_weather_loc( &cur_loc );
        #else
          TEST_weather_location( &cur_loc );
        #endif
        CurrentLoc = EwNewStringUtf8( (const unsigned char*) cur_loc, (int)strlen( cur_loc ) );
      }
    WeatherLocation = CurrentLoc;
    $endif
  }

  $rect <100,-10,300,30>
  var int32 WeatherTime;

  $rect <100,30,300,70>
  var int32 Temperature;

  $rect <100,70,300,110>
  var int32 MaxTemperature;

  $rect <310,-10,510,30>
  var int32 WeatherType;

  $rect <310,30,510,70>
  var int32 MinTemperature;

  $rect <310,70,510,110>
  var int32 RainProbability;

  $rect <100,110,300,150>
  var string WeatherLocation;

  $rect <110,240,340,280>
  method void SendWeatherInfoRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_weather_info_req();
      }
    $endif
  }

  $rect <350,240,590,280>
  method void SendVehicleSettingRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_vehicle_setting_req();
      }
    $endif
  }

  $rect <310,110,510,150>
  var int32 WeekDay;

  $rect <540,180,740,220>
  method void GetWeekDay()
  {
    $if !$prototyper
      var int32 NewWeekDay;

      native( NewWeekDay )
      {
        int week_day;
        #if( !UNIT_TEST_WEA )
          week_day = ew_get_weather_week_day();
        #else
          week_day = TEST_weather_weekday();
        #endif
        NewWeekDay = week_day;
      }
    WeekDay = NewWeekDay;
    $else
      WeekDay = 1;
    $endif
  }

  $rect <530,-10,770,30>
  property bool IsWeatherInfoReceived = false;

  $rect <530,30,770,70>
  onset IsWeatherInfoReceived
  {
    // Remember the property's new value.
    pure IsWeatherInfoReceived = value;

    notifyobservers ^IsWeatherInfoReceived;
  }

  $rect <110,360,310,400>
  method int32 ConvertTemperature( arg Enum::TemperatureSettingItem aTempUnit, arg int32 aTemperature )
  {
    var int32 Temp = aTemperature;
    if( Enum::TemperatureSettingItem.TEMP_F == aTempUnit )
    {
      Temp = ( int32 )( ( aTemperature * 9 + 160 ) / 5 );
    }
    return Temp;
  }
}

$rect <320,110,520,150>
autoobject DeviceInterface::WeatherDeviceClass WeatherDevice;

$rect <560,150,760,190>
$output false
class VehicleDataClass
{
  $rect <10,110,210,150>
  var float DataFloat = 0;

  $rect <10,160,210,200>
  var uint32 DataUInt32 = 0;

  $rect <10,10,210,50>
  var bool Valid = false;

  $rect <10,60,210,100>
  var Enum::DataType DataType = Enum::DataType.UINT32;

  $rect <230,10,430,50>
  var Enum::VehicleRxType RxType;
}

$rect <21,380,221,420>
class NaviDataClass
{
  $rect <80,60,280,100>
  $output true
  var string CurrentRoad;

  $rect <80,100,280,140>
  $output true
  var int32 ETA;

  $rect <80,140,280,180>
  $output true
  var int32 DayNightMode;

  $rect <80,180,280,220>
  $output true
  var int32 SpeedLimit;

  $rect <280,60,480,100>
  $output true
  var Enum::NaviAlertType NaviEventType;

  $rect <280,100,480,140>
  $output true
  var string NaviEventDist;

  $rect <280,140,480,180>
  $output true
  var bool NaviEventVisibility;

  $rect <280,180,480,220>
  $output true
  var string NaviEventSpeed;

  $rect <490,60,690,100>
  $output true
  var Enum::NaviCameraType NaviCameraType;

  $rect <80,220,280,260>
  $output true
  var int32 RouteCalProgress;

  $rect <280,220,480,260>
  $output true
  var int32 ViaPoints;

  $rect <490,100,690,140>
  $output true
  var bool IsHomeSet;

  $rect <490,140,690,180>
  $output true
  var bool IsOfficeSet;

  $rect <490,180,690,220>
  $output true
  var string ZoomLevel;

  $rect <490,220,690,260>
  $output true
  var string NaviEventDesc;
}

$rect <811,190,1011,230>
$output false
class MotoConContext
{
  $rect <10,10,210,50>
  var Enum::MotoConRxEvent RxEvent;
}

$rect <530,300,740,340>
$output false
class NotificationDeviceClass : Templates::DeviceClass
{
  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <30,220,240,260>
  $output true
  method bool IsPhoneCallStateActive()
  {
    return ( Enum::PhoneCallState.ACTIVE == GetPhoneCallState() );
  }

  // Phone Call
  note group Note1
  {
    attr Bounds = <10,10,970,280>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,60,280,100>
  $output true
  method void NotifyPhoneCallStateChanged()
  {
    trace "NotifyPhoneCallStateChanged";
    PhoneCallStateChangedSystemEvent.Trigger( null, false );
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,350,230,390>
  $output true
  method void NotifyListUpdated()
  {
    trace "NotifyListUpdated";
    NotificationListUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <30,400,320,440>
  object Core::SystemEvent NotificationListUpdatedSystemEvent;

  $rect <840,350,1050,390>
  method DeviceInterface::NotificationContext GetNotificationAtItem( arg uint32 aItemNo )
  {
    var DeviceInterface::NotificationContext NotificationItem = new DeviceInterface::NotificationContext;
    NotificationItem.ReceivedTime = new DeviceInterface::DateTime;

    $if !$prototyper
      var uint32 Uid;
      var uint16 CallRepetition;
      var uint32 Category;
      var string Title = "";
      var string Subtitle = "";
      var string Message = "";
      var string ReceivedHour = "";
      var string ReceivedMinute = "";

      native( aItemNo, Uid, CallRepetition, Title, Subtitle, Message, Category, ReceivedHour, ReceivedMinute )
      {
        uint32_t notification_uid;
        uint16_t call_repetition;
        uint8_t  notification_title[NOTIFICATION_TITLE_MAX_LEN];
        uint8_t  notification_subtitle[NOTIFICATION_SUBTITLE_MAX_LEN];
        uint8_t  notification_message[NOTIFICATION_MESSAGE_MAX_LEN];
        notification_time_t received_time;
        EnumNotificationCategory notification_category;

        NTF_get_notification_at_idx( aItemNo, &notification_uid, &call_repetition,
                                     notification_title, NOTIFICATION_TITLE_MAX_LEN,
                                     notification_subtitle, NOTIFICATION_SUBTITLE_MAX_LEN,
                                     notification_message, NOTIFICATION_MESSAGE_MAX_LEN,
                                     &notification_category, &received_time );

        Uid = notification_uid;
        CallRepetition = call_repetition;

        uint8_t *stuffed_str = NULL;
        int stuffed_str_len = ew_handle_special_characters( notification_title, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Title = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        stuffed_str_len = ew_handle_special_characters( notification_subtitle, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Subtitle = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        stuffed_str_len = ew_handle_special_characters( notification_message, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Message = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        Category = notification_category;
        ReceivedHour = EwNewStringUInt( received_time.hour, 1, 10 );
        ReceivedMinute = EwNewStringUInt( received_time.minute, 2, 10 );
      }

      NotificationItem.Uid = Uid;
      NotificationItem.CallRepetition = CallRepetition;
      NotificationItem.Title = Title;
      NotificationItem.Subtitle = Subtitle;
      NotificationItem.Message = Message;
      NotificationItem.Category = (Enum::NotificationCategory)Category;
      NotificationItem.ReceivedTime.Hour = ReceivedHour;
      NotificationItem.ReceivedTime.Minute = ReceivedMinute;
    $else
      aItemNo; // suppress warning
    $endif

    return NotificationItem;
  }

  $rect <337,350,547,390>
  property uint32 NotificationNum;

  $rect <337,400,547,440>
  onget NotificationNum
  {
    $if !$prototyper
      var uint32 Num = 0;
      native( Num )
      {
        Num = NTF_get_notification_num();
      }

      pure NotificationNum = Num;
    $endif
    return pure NotificationNum;
  }

  // Notification
  note group Note2
  {
    attr Bounds = <10,300,1070,460>;
  }

  $rect <840,400,1050,440>
  method void DeleteNotificationOfUid( arg uint32 Uid )
  {
    $if !$prototyper
      native( Uid )
      {
        NTF_delete_notification( Uid );
      }
    $endif
  }

  $rect <560,350,820,390>
  method int32 GetBufferIdxOfNotificationUID( arg uint32 Uid )
  {
    var int32 Index = -1;
    $if !$prototyper
      native( Uid, Index )
      {
        Index = NTF_get_idx_of_notification_uid( Uid );
      }
    $endif
    return Index;
  }

  $rect <30,110,330,150>
  object Core::SystemEvent PhoneCallStateChangedSystemEvent;

  $rect <250,170,460,210>
  method string GetIncomingCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t *stuffed_str = NULL;

        NTF_get_incoming_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }

  // Get active call duration in ms
  $rect <680,110,890,150>
  method uint32 GetActiveCallDuration()
  {
    var uint32 DurationMS;

    $if !$prototyper
      native( DurationMS )
      {
        DurationMS = NTF_get_active_call_duration();
      }
    $endif

    return DurationMS;
  }

  $rect <30,170,240,210>
  method Enum::PhoneCallState GetPhoneCallState()
  {
    var Enum::PhoneCallState PhoneCallState = Enum::PhoneCallState.IDLE;

    $if !$prototyper
      native( PhoneCallState )
      {
        int32_t phone_call_state = NTF_get_phonecall_state();
        PhoneCallState = (EnumPhoneCallState)phone_call_state;
      }
    $endif

    return PhoneCallState;
  }

  $rect <740,170,950,210>
  method void AnswerPhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_answer_call();
      }
    $endif
  }

  $rect <740,220,950,260>
  method void DeclinePhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_decline_call();
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <470,170,730,210>
  $output true
  method bool IsPhoneCallVolumeControllable()
  {
    var bool Controllable = false;

    $if !$prototyper
      native( Controllable )
      {
        Controllable = NTF_is_phonecall_volume_controllable();
      }
    $endif

    return Controllable;
  }

  $rect <470,220,730,260>
  method void PhoneCallVolumeControl( arg Enum::VolumeControl aControl )
  {
    $if !$prototyper
      native( aControl )
      {
        NTF_phonecall_volume_control( aControl );
      }
    $endif
  }

  $rect <340,110,650,150>
  object Core::SystemEvent PhoneCallVolumeChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <340,60,590,100>
  $output true
  method void NotifyPhoneCallVolumeChanged()
  {
    trace "NotifyPhoneCallVolumeChanged";
    PhoneCallVolumeChangedSystemEvent.Trigger( null, false );
  }

  $rect <680,60,890,100>
  method uint32 GetPhoneCallVolume()
  {
    var uint32 PhoneCallVolume = 0;

    $if !$prototyper
      native( PhoneCallVolume )
      {
        PhoneCallVolume = BC_motocon_get_phonecall_volume();
      }
    $endif

    return PhoneCallVolume;
  }

  $rect <560,400,820,440>
  method int32 GetNotificationNumOfCategory( arg Enum::NotificationCategory aCategory )
  {
    var int32 Num = 0;
    $if !$prototyper
      native( aCategory, Num )
      {
        Num = NTF_get_notification_num_of_category( aCategory );
      }
    $else
      // suppress warning
      aCategory;

      Num = 1;
    $endif
    return Num;
  }

  $rect <250,220,460,260>
  method string GetActiveCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t* stuffed_str = NULL;

        NTF_get_active_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }

  $rect <30,480,220,520>
  method int32 CallNative( arg Enum::NotificationNativeCall aCmd, arg uint32 aData )
  {
    var int32 result;
    $if !$prototyper
      native( aCmd, aData, result )
      {
        result = NTF_call_native( aCmd, aData );
      }
    $else
      //suppress warming
      aCmd;
      aData;
    $endif
    return result;
  }
}

$rect <530,340,730,380>
autoobject DeviceInterface::NotificationDeviceClass NotificationDevice;

$rect <530,380,730,420>
$output false
class DateTime
{
  $rect <70,50,270,90>
  var string Year;

  $rect <70,100,270,140>
  var string Month;

  $rect <70,150,270,190>
  var string Date;

  $rect <70,200,270,240>
  var string Hour;

  $rect <70,250,270,290>
  var string Minute;

  $rect <70,300,270,340>
  var string Second;
}

$rect <530,420,730,460>
$output false
class NotificationContext
{
  $rect <10,10,210,50>
  var uint32 Uid;

  $rect <10,60,210,100>
  var uint16 CallRepetition;

  $rect <10,110,210,150>
  var string Title;

  $rect <10,210,210,250>
  var string Message;

  $rect <10,260,210,300>
  var Enum::NotificationCategory Category;

  $rect <10,310,210,350>
  var DeviceInterface::DateTime ReceivedTime;

  $rect <10,160,210,200>
  var string Subtitle;
}

$rect <20,230,300,270>
$output false
const uint8 INSPECTION_NEGATIVE_RESPONSE = 0xFF;

$rect <20,190,220,230>
$output false
class SystemData
{
  $rect <10,10,210,50>
  var Enum::SystemRxEvent RxEvent;
}

$rect <20,420,220,460>
class NaviTbtDataClass
{
  $rect <50,40,250,80>
  $output true
  var int32 IconIdx;

  $rect <50,100,250,140>
  $output true
  var string DistUnit;

  $rect <260,40,460,80>
  $output true
  var float Distance;

  $rect <270,100,470,140>
  $output true
  var string TbtDescription;
}

$rect <20,460,220,500>
class NaviPoiDataClass
{
  $rect <50,100,250,140>
  $output true
  var string DistUnit;

  $rect <50,40,250,80>
  $output true
  var float Distance;

  $rect <270,100,470,140>
  $output true
  var string PoiTitle;
}

$rect <810,230,1010,270>
$output false
class BtmStatusContext
{
  $rect <10,10,210,50>
  var Enum::BtmStatus Status;
}

$rect <810,270,1010,310>
$output false
class ConnectionStatusContext
{
  $rect <10,10,210,50>
  var Enum::ConnectionStatus Status;
}

$rect <810,310,1060,350>
$output false
const int32 MAX_PAIRED_DEVICE_NUM = 8;
