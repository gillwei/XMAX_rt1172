$version 10.00

$rect <270,20,470,60>
inline Inline
{
  #include <stddef.h>
  #include <stdlib.h>
  #include "ew_priv.h"
  #include "EEPM_pub.h"
  #include "PERIPHERAL_pub.h"
  #include "VI_pub.h"
  #include "MM_pub_ams_type.h"
  #include "BC_motocon_pub_type.h"

}

$rect <20,20,220,60>
$output false
class SystemDeviceClass : Templates::DeviceClass
{
  // Interface to get system info
  note group Note1
  {
    attr Bounds = <10,10,970,280>;
  }

  $rect <250,70,450,110>
  property string SoftwareVersion;

  $rect <470,70,670,110>
  property bool IsDebugBuild;

  $rect <470,120,670,160>
  onget IsDebugBuild
  {
    $if( !$prototyper )
      var bool is_debug_build;
      native( is_debug_build )
      {
        is_debug_build = ew_is_debug_build();
      }
      return is_debug_build;
    $else
      return true;
    $endif
  }

  // Interfaces for factory test
  note group Note3
  {
    attr Bounds = <10,300,910,460>;
  }

  $rect <40,390,240,430>
  $output true
  method void QuitTest()
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Quit;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <490,390,710,430>
  object Core::SystemEvent FactoryTestSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,340,240,380>
  $output true
  method void TestDisplayPattern( arg int32 aIdx )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Display;
    TestContext.Data = aIdx - 1;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <30,220,230,260>
  $output true
  method void NotifyEsnRead( arg string aESN )
  {
    ESN = aESN;
  }

  $rect <30,70,230,110>
  property string ESN;

  $rect <30,120,230,160>
  onset ESN
  {
    if( pure ESN != value )
    {
      pure ESN = value;
      notifyobservers ^ESN;
    }

  }

  $rect <30,170,230,210>
  onget ESN
  {
    $if( !$prototyper )
      if( "" == pure ESN )
      {
        native
        {
           ew_get_esn();
        }
      }
    $endif

    return pure ESN;
  }

  $rect <250,120,450,160>
  onget SoftwareVersion
  {
    $if !$prototyper
      var string software_version = "";

      if( "" == pure SoftwareVersion )
      {
        native( software_version )
        {
           char version[8];
           ew_get_software_version( version );
           software_version = EwNewStringAnsi( version );
        }

        pure SoftwareVersion = software_version;
      }
    $endif

    return pure SoftwareVersion;
  }

  $rect <30,520,250,560>
  method void ResetToFactoryDefault()
  {
    FactoryResetTimer.Enabled = true;
    $if !$prototyper
      native
      {
        ew_reset_to_factory_default();
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,570,250,610>
  $output true
  method void NotifyFactoryResetComplete()
  {
    FactoryResetTimer.Enabled = false;
    notifyobservers ^FactoryResetComplete;
  }

  // Device Interface for Factory Reset
  note group Note4
  {
    attr Bounds = <10,480,580,690>;
  }

  $rect <270,520,520,560>
  object Core::Timer FactoryResetTimer
  {
    preset OnTrigger = OnFactoryResetTimeoutSlot;
    preset Period = 2000;
    preset Enabled = false;
  }

  $rect <270,570,520,610>
  slot OnFactoryResetTimeoutSlot
  {
    FactoryResetTimer.Enabled = false;
    NotifyFactoryResetComplete();
  }

  $rect <270,620,520,660>
  method void RebootSystem()
  {
    $if !$prototyper
      native
      {
        ew_reboot_system();
      }
    $endif
  }

  $rect <30,620,250,660>
  property bool FactoryResetComplete = false;

  $rect <40,710,240,750>
  method void SetTFTDutyCycle( arg int32 aDutyCycle )
  {
    $if !$prototyper
      native( aDutyCycle )
      {
        PERIPHERAL_pwm_set_display_dutycycle( aDutyCycle );
      }
    $else
    // suppress warning
    if( 0 == aDutyCycle )
    {
      // empty body
    }
    $endif
  }

  $rect <270,710,470,750>
  property int32 BrightnessLevel = 7;

  $rect <250,170,450,210>
  property string BtSoftwareVersion;

  $rect <250,220,450,260>
  onget BtSoftwareVersion
  {
    $if !$prototyper
      var string bt_sw_version = "";

      native( bt_sw_version )
      {
         char version[8];
         ew_get_bt_software_version( version );
         bt_sw_version = EwNewStringAnsi( version );
      }

      pure BtSoftwareVersion = bt_sw_version;
    $endif

    return pure BtSoftwareVersion;
  }

  $rect <250,340,470,380>
  $output true
  method void StartBurnInTest()
  {
    trace "StartBurnInTest";
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInStart;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <250,390,470,430>
  $output true
  method void UpdateBurnInTestTime( arg uint32 aTimeSec )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInTimeUpdate;
    TestContext.Data = ( int32 )aTimeSec;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <499,340,709,380>
  $output true
  method void ShowBurnInTestResult( arg bool aResult )
  {
    trace "ShowBurnInTestResult: ", aResult;
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInResult;
    if( aResult )
    {
      TestContext.Data = 1;
    }
    else
    {
      TestContext.Data = 0;
    }
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <470,170,670,210>
  var bool IsHopperTestMode = false;

  // Device Interface for QR code
  note group Note5
  {
    attr Bounds = <610,480,1120,690>;
  }

  $rect <870,520,1070,560>
  object Core::SystemEvent QrCodeSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <650,520,850,560>
  $output true
  method void NotifyQrCodeReady( arg string aQrCodeStr )
  {
    trace "QR code is ready";
    QrCodeText = aQrCodeStr;
    QrCodeSystemEvent.Trigger( null, false );
  }

  $rect <650,570,850,610>
  method void GetQrCode( arg int32 pixelnum )
  {
    $if !$prototyper
      native( pixelnum )
      {
        ew_request_qrcode( pixelnum );
      }
    $else
      // suppress warning
      if( pixelnum > 0 )
      {
        // empty body
      }
    $endif
  }

  $rect <680,120,930,160>
  method void GetLocalTime()
  {
    $if !$prototyper
      var uint16 RtcYear;
      var uint8 RtcMonth;
      var uint8 RtcDay;
      var uint8 RtcHour;
      var uint8 RtcMinute;
      var uint8 RtcSecond;

      native( RtcYear, RtcMonth, RtcDay, RtcHour, RtcMinute, RtcSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        ew_get_rtc_time( &srtc_time );

        RtcYear = srtc_time.year;
        RtcMonth = srtc_time.month;
        RtcDay = srtc_time.day;
        RtcHour = srtc_time.hour;
        RtcMinute = srtc_time.minute;
        RtcSecond = srtc_time.second;
      }

      if( null == CurrentLocalTime )
      {
        CurrentLocalTime = new DeviceInterface::RtcTime;
      }

      CurrentLocalTime.Year = RtcYear;
      CurrentLocalTime.Month = RtcMonth;
      CurrentLocalTime.Day = RtcDay;
      CurrentLocalTime.Hour = RtcHour;
      CurrentLocalTime.Minute = RtcMinute;
      CurrentLocalTime.Second = RtcSecond;
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <681,70,930,110>
  $output true
  method void NotifyUpdateLocalTime()
  {
    GetLocalTime();
    UpdateLocalTimeSystemEvent.Trigger( CurrentLocalTime, false );
  }

  $rect <680,220,930,260>
  object Core::SystemEvent UpdateLocalTimeSystemEvent;

  $rect <680,170,930,210>
  var DeviceInterface::RtcTime CurrentLocalTime;

  $rect <870,570,1070,610>
  property string QrCodeText;
}

$rect <20,60,220,100>
autoobject DeviceInterface::SystemDeviceClass SystemDevice;

$rect <19,170,229,210>
$output false
class NavigationDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,90,220,130>
  object Core::SystemEvent MapUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,40,220,80>
  $output true
  method void NotifyMapUpdate()
  {
    MapUpdateEvent.Trigger( null, true );
  }

  $rect <250,40,450,80>
  method bool IsMapFrameReady()
  {
    $if( !$prototyper )
      var bool IsMapFrameReady = false;
      native( IsMapFrameReady )
      {
        IsMapFrameReady = ew_navi_is_map_frame_ready();
      }
      return IsMapFrameReady;
    $else
      return false;
    $endif
  }
}

$rect <19,210,229,250>
autoobject DeviceInterface::NavigationDeviceClass NavigationDevice;

$rect <19,290,259,330>
$output false
class MediaManagerDeviceClass : Templates::DeviceClass
{
  $rect <30,20,230,60>
  property string Title;

  $rect <30,60,230,100>
  onset Title
  {
    // Get song title when receiving from media manager or UI initialization.
    if( IsTitleReceived || IsInit )
    {

      if( value == "" && ( IsTitleReceived || IsInit ) )
      {
        // If received song title is empty, show "---".
        pure Title = Strings::GEN_three_hyphens;
      }
      else
      {
        // Remember the property's new value.
        pure Title = value;
      }
    }
    else
    {
      // Fail to receive song title, show "---".
      pure Title = Strings::GEN_three_hyphens;
    }

    // Notify all associated property observers.
    notifyobservers ^Title;
  }

  $rect <250,20,450,60>
  property string Album;

  $rect <250,60,450,100>
  onset Album
  {
    // Get album when receiving from media manager or UI initialization.
    if( IsAlbumReceived || IsInit )
    {
      if( value == "" && ( IsAlbumReceived || IsInit ) )
      {
        // If received album is empty, show "---".
        pure Album = Strings::GEN_three_hyphens;
      }
      else
      {
        // Remember the property's new value.
        pure Album = value;
      }
    }
    else
    {
      // Fail to receive album, show "---".
      pure Album = Strings::GEN_three_hyphens;
    }

    // Notify all associated property observers.
    notifyobservers ^Album;
  }

  $rect <480,20,680,60>
  property string Artist;

  $rect <480,60,680,100>
  onset Artist
  {
    // Get artist when receiving from media manager or UI initialization.
    if( IsArtistReceived || IsInit )
    {
      if( value == "" && ( IsArtistReceived || IsInit ) )
      {
        // If received artist is empty, show "---".
        pure Artist = Strings::GEN_three_hyphens;
      }
      else
      {
        // Remember the property's new value.
        pure Artist = value;
      }
    }
    else
    {
      // Fail to receive artist, show "---".
      pure Artist = Strings::GEN_three_hyphens;
    }

    // Notify all associated property observers.
    notifyobservers ^Artist;
  }

  $rect <720,60,920,100>
  property int32 DurationTimeSec = 0;

  $rect <720,470,940,510>
  method void SendRemoteCommand( arg Enum::CommandType cmd_type )
  {
    var int32 cmd_idx;

    switch( cmd_type )
    {
      case Enum::CommandType.Play: cmd_idx = 0;
      case Enum::CommandType.Pause: cmd_idx = 1;
      case Enum::CommandType.NextTrack: cmd_idx = 2;
      case Enum::CommandType.PrevTrack: cmd_idx = 3;
      default:cmd_idx = 14; // according to AMS spec, only 14 commands so that we set index to 14 in case no command is matched.
    }

    $if !$prototyper
    // suppress warning
    if( cmd_idx )
    {
      // empty body
    }
    native( cmd_idx )
    {
      ams_remote_command cmd = AMS_REMOTE_COMMAND_CNT;
      switch( cmd_idx )
      {
        case 0:
          cmd = AMS_REMOTE_COMMAND_PLAY;
          break;
        case 1:
          cmd = AMS_REMOTE_COMMAND_PAUSE;
          break;
        case 2:
          cmd = AMS_REMOTE_COMMAND_NEXT_TRACK;
          break;
        case 3:
          cmd = AMS_REMOTE_COMMAND_PREVIOUS_TRACK;
          break;
        default:
          break;
      }
      ew_send_command( cmd );
    }
    $endif
  }

  $rect <720,20,920,60>
  property int32 ElapsedTimeSec = 0;

  // An interface to set/get data from device
  note group Note1
  {
    attr Bounds = <10,430,1040,540>;
  }

  $rect <30,120,230,160>
  property int32 PlaybackState = 0;

  $rect <30,160,230,200>
  onset PlaybackState
  {
    // Remember the property's new value.
    pure PlaybackState = value;
  }

  $rect <250,120,450,160>
  property string PlayerName;

  $rect <250,160,450,200>
  onset PlayerName
  {
    // Remember the property's new value.
    pure PlayerName = value;
  }

  $rect <350,240,550,280>
  $output true
  method void NotifyTitleChanged( arg string aTitle )
  {
    trace "NotifyTitleChanged: " + aTitle;
    IsTitleReceived = true;
    Title = aTitle;
  }

  $rect <350,320,550,360>
  $output true
  method void NotifyArtistChanged( arg string aArtist )
  {
    trace "NotifyArtistChanged: " + aArtist;
    IsArtistReceived = true;
    Artist = aArtist;
  }

  $rect <350,280,550,320>
  $output true
  method void NotifyAlbumChanged( arg string aAlbum )
  {
    trace "NotifyAlbumChanged: " + aAlbum;
    IsAlbumReceived = true;
    Album = aAlbum;
  }

  $rect <50,470,250,510>
  method void GetPlayerInfo()
  {
    var string p_name = "";
    var int32 p_state = 0;
    $if !$prototyper
    native ( p_name, p_state )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      p_name = EwNewStringAnsi( mp_state->str.player_name );
      p_state = mp_state->playback_state;
    }
    $endif
    PlayerName = p_name;
    PlaybackState = p_state;
  }

  $rect <270,470,470,510>
  method void GetPlaybackInfo()
  {
    var int32 ela_time = 0;
    var int32 dur = 0;
    $if !$prototyper
    native ( ela_time, dur )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      ela_time = mp_state->current_elapsed_time_sec;
      dur = mp_state->duration_sec;
    }
    $endif
    ElapsedTimeSec = ela_time;
    DurationTimeSec = dur;
  }

  $rect <500,470,700,510>
  method void GetTrackInfo()
  {
    var string media_artist = "";
    var string media_album = "";
    var string media_title = "";
    $if !$prototyper
    native ( media_artist, media_album, media_title )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      media_artist = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_artist, ( int )strlen( mp_state->str.track_artist ) );
      media_album = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_album, ( int )strlen( mp_state->str.track_album ) );
      media_title = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_title, ( int )strlen( mp_state->str.track_title ) );
    }
    $endif
    Artist = media_artist;
    Album = media_album;
    Title = media_title;
  }

  $rect <720,240,920,280>
  var bool IsInit = false;

  $rect <350,360,610,400>
  $output true
  method void NotifyPlayerStateChanged( arg int32 aPlaybackState )
  {
    trace "NotifyPlayerStateChanged: ", aPlaybackState;
    PlaybackState = aPlaybackState;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,280,320,320>
  $output true
  method void NotifyPlayBackTimeChanged( arg int32 aElapsedTimeSec, arg int32 aDurationTimeSec )
  {
    trace "ElapsedTime: ", aElapsedTimeSec;
    trace "Duration: ", aDurationTimeSec;
    ElapsedTimeSec = aElapsedTimeSec;
    DurationTimeSec = aDurationTimeSec;

    NotifyPlayBackTimeChangedSystemEvent.Trigger( null, false );
  }

  $rect <30,240,320,280>
  object Core::SystemEvent NotifyPlayBackTimeChangedSystemEvent;

  $rect <720,280,920,320>
  var bool IsTitleReceived = false;

  $rect <720,320,920,360>
  var bool IsAlbumReceived = false;

  $rect <720,360,920,400>
  var bool IsArtistReceived = false;
}

$rect <19,330,219,370>
autoobject DeviceInterface::MediaManagerDeviceClass MediaManagerDevice;

$rect <19,400,219,440>
$output false
class BluetoothDeviceClass : Templates::DeviceClass
{
  // BT related properties
  note group Note1
  {
    attr Bounds = <10,10,1600,260>;
  }

  // Interfaces to react to BT system events
  note group Note2
  {
    attr Bounds = <9,280,1180,451>;
  }

  // Interfaces to perform BT operations on device
  note group Note3
  {
    attr Bounds = <10,470,840,690>;
  }

  $rect <290,510,503,550>
  method void GetPairedDeviceAtItem( arg int32 aItemNo )
  {
    $if !$prototyper
      var string DevName;
      var bool   IsConnected;

      native( aItemNo, DevName, IsConnected )
      {
        uint8_t* device_name;
        bool     is_connected;
        ew_bt_get_paired_device_at_index( aItemNo, &device_name, &is_connected );
        DevName = EwNewStringAnsi( ( char* )device_name );
        IsConnected = is_connected;
      }
      PairedDeviceObj.DeviceName = DevName;
      PairedDeviceObj.IsConnected = IsConnected;
    $else
      if( aItemNo > 0 )
      {
        // empty body to suppress warning
      }
    $endif
  }

  $rect <520,331,810,371>
  object Core::SystemEvent PasskeyGeneratedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,331,280,371>
  $output true
  method void NotifyPasskeyGenerated( arg string aPasskey )
  {
    trace "NotifyPasskeyGenerated: ", aPasskey;
    Passkey = aPasskey;
    PasskeyGeneratedSystemEvent.Trigger( null, false );
  }

  $rect <300,331,500,371>
  var string Passkey;

  $rect <520,391,810,431>
  object Core::SystemEvent ConnectionResultSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,391,280,431>
  $output true
  method void NotifyConnectionResult( arg Enum::BtResult aResult )
  {
    ConnectionResult = aResult;
    ConnectionResultSystemEvent.Trigger( null, false );
  }

  $rect <300,391,500,431>
  property Enum::BtResult ConnectionResult = Enum::BtResult.FAIL;

  $rect <250,50,450,90>
  property bool Discoverable = false;

  $rect <250,100,450,140>
  onset Discoverable
  {
    if( pure Discoverable != value )
    {
      pure Discoverable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_discoverable( ( bool )value );
        }
      $endif
    }
  }

  $rect <250,150,450,190>
  onget Discoverable
  {
    $if !$prototyper
      var bool IsDiscoverable = false;
      native( IsDiscoverable )
      {
        IsDiscoverable = ew_bt_get_discoverable();
      }
      return IsDiscoverable;
    $else
      return pure Discoverable;
    $endif
  }

  $rect <30,50,240,90>
  property bool BluetoothEnable = false;

  $rect <30,100,240,140>
  onset BluetoothEnable
  {
    trace "OnSetBluetoothEnable ", value;
    if( pure BluetoothEnable != value )
    {
      pure BluetoothEnable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_enable( ( bool )value );
        }
      $endif
    }
  }

  $rect <30,150,240,190>
  onget BluetoothEnable
  {
    return pure BluetoothEnable;

  }

  $rect <460,50,660,90>
  property bool AutoConnect;

  $rect <460,100,660,140>
  onset AutoConnect
  {
    pure AutoConnect = value;
    $if !$prototyper
      native
      {
        ew_bt_set_autoconnect( ( bool )value );
      }
    $endif
  }

  $rect <460,150,660,190>
  onget AutoConnect
  {
    $if !$prototyper
      var bool IsAutoConnect = false;
      native( IsAutoConnect )
      {
        IsAutoConnect = ew_bt_get_autoconnect();
      }
      return IsAutoConnect;
    $else
      return pure AutoConnect;
    $endif
  }

  $rect <670,50,880,90>
  property int32 PairedDeviceNum;

  $rect <670,100,880,140>
  onget PairedDeviceNum
  {
    $if !$prototyper
      var int32 PairedDevNum = 0;
      native( PairedDevNum )
      {
        PairedDevNum = ew_bt_get_paired_device_num();
      }
      return PairedDevNum;
    $else
      return pure PairedDeviceNum;
    $endif

  }

  $rect <40,630,260,670>
  method void UnpairDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_unpair_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <290,570,503,610>
  object DeviceInterface::BluetoothPairedDeviceInfo PairedDeviceObj;

  $rect <30,200,240,240>
  method void GetBluetoothEnable()
  {
    $if !$prototyper
      var bool enable = false;
      native( enable )
      {
        enable = ew_bt_get_enable();
      }
      BluetoothEnable = enable;
    $endif
  }

  $rect <1108,50,1338,90>
  property string LocalDeviceName;

  $rect <1108,100,1338,140>
  onget LocalDeviceName
  {
    $if !$prototyper
      var string DevName = "";
      native( DevName )
      {
        uint8_t* device_name;
        ew_bt_get_local_device_name( &device_name );
        DevName = EwNewStringAnsi( ( char* )device_name );
      }
      return DevName;
    $else
      return pure LocalDeviceName;
    $endif
  }

  $rect <1350,50,1580,90>
  property string LocalDeviceAddress;

  $rect <1350,100,1580,140>
  onget LocalDeviceAddress
  {
    $if !$prototyper
      var string DeviceAddr = "";
      native( DeviceAddr )
      {
        uint8_t dev_addr[BT_DEVICE_ADDRESS_LEN + 1];
        ew_bt_get_local_device_address( dev_addr );
        dev_addr[BT_DEVICE_ADDRESS_LEN + 1] = NULL;
        DeviceAddr = EwNewStringAnsi( dev_addr );
      }
      return DeviceAddr;
    $else
      return pure LocalDeviceAddress;
    $endif
  }

  $rect <40,510,260,550>
  method void ConnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_connect_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( aPairedDeviceIndex > 0 )
      {
        // empty body
      }
    $endif
  }

  $rect <290,630,490,670>
  method bool IsBlePairedDevice( arg int32 aPairedDeviceIndex )
  {
    var bool IsBlePairedDevice = false;
    $if !$prototyper
      native ( aPairedDeviceIndex, IsBlePairedDevice )
      {
        IsBlePairedDevice = ew_bt_is_ble_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( "" == aPairedDeviceIndex )
      {
        // empty body
      }
    $endif
    return IsBlePairedDevice;
  }

  $rect <40,570,260,610>
  method void DisconnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_disconnect_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <891,50,1091,90>
  property bool IsMaxPairedDevice;

  $rect <891,100,1091,140>
  onget IsMaxPairedDevice
  {
    $if !$prototyper
      var bool is_max_paired_device = false;
      native( is_max_paired_device )
      {
        is_max_paired_device = ew_bt_is_max_paired_device_num();
      }
      return is_max_paired_device;
    $else
      return pure IsMaxPairedDevice;
    $endif
  }

  $rect <40,806,240,846>
  property Enum::BtFwStatus BtFwStatus;

  $rect <40,860,240,900>
  onset BtFwStatus
  {
    if ( pure BtFwStatus != value )
    {
      pure BtFwStatus = value;
      notifyobservers ^BtFwStatus;
    }

  }

  $rect <40,750,240,790>
  $output true
  method void NotifyBtFwStatus( arg Enum::BtFwStatus status, arg string version )
  {
    trace "NotifyBtFWStatus: ", status;
    trace "BtFwVer: ", version;

    BtFwStatus = status;
  }

  // Interfaces to BT firmware update
  note group Note4
  {
    attr Bounds = <10,710,320,920>;
  }

  $rect <530,510,750,550>
  property bool RefreshPairedDeviceList;

  $rect <530,570,790,610>
  onset RefreshPairedDeviceList
  {
    pure RefreshPairedDeviceList = value;
    notifyobservers ^RefreshPairedDeviceList;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <820,330,1170,370>
  $output true
  method void NotifyPairedDeviceConnectionStatusUpdated()
  {
    RefreshPairedDeviceList = true;
  }
}

$rect <19,440,219,480>
autoobject DeviceInterface::BluetoothDeviceClass BluetoothDevice;

$rect <19,480,219,520>
$output false
class BluetoothPairedDeviceInfo
{
  $rect <20,10,220,50>
  var string DeviceName;

  $rect <20,60,220,100>
  var bool IsConnected;
}

$rect <20,100,220,140>
$output false
class RtcTime
{
  $rect <20,10,220,50>
  var uint16 Year;

  $rect <20,50,220,90>
  var uint8 Month;

  $rect <20,90,220,130>
  var uint8 Day;

  $rect <20,130,220,170>
  var uint8 Hour;

  $rect <20,170,220,210>
  var uint8 Minute;

  $rect <20,210,220,250>
  var uint8 Second;
}

$rect <20,630,220,670>
$output false
class VehicleDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,100,310,140>
  object Core::SystemEvent DDModeStateChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,50,260,90>
  $output true
  method void NotifyDDModeStateChanged()
  {
    DDModeStateChangedSystemEvent.Trigger( null, false );
  }

  // Driver Distraction Mode System Event
  note group Note2
  {
    attr Bounds = <0,0,560,160>;
  }

  $rect <320,50,540,90>
  property bool DDModeActivated;

  $rect <320,100,540,140>
  onget DDModeActivated
  {
    $if !$prototyper
      var bool IsActivated = false;

      native( IsActivated )
      {
        IsActivated = VI_is_dd_mode_activated();
      }

      return IsActivated;
    $else
      return pure DDModeActivated;
    $endif
  }

  $rect <20,180,260,220>
  method bool IsVehicleFeatureSupported( arg Enum::VehicleFeature aVehicleFeature )
  {
    var bool IsSupported = false;

    $if !$prototyper
      var int32 FeatureId = ( int32 )aVehicleFeature;
      native( IsSupported, FeatureId )
      {
        IsSupported = ew_vi_is_feature_supported( FeatureId );
      }
    $else
      // suppress warning
      if( ( int32 )aVehicleFeature >= 0 )
      {
        // empty
      }
    $endif

    return IsSupported;
  }

  $rect <280,180,480,220>
  method void SetData( arg Enum::VehicleTxType aVehicleTxType, arg uint32 aData )
  {
    $if !$prototyper
      var int32 TxTypeId = ( int32 )aVehicleTxType;
      native( aData, TxTypeId )
      {
        VI_set_tx_data( TxTypeId, aData );
      }
    $else
      trace "set vi tx data ", aVehicleTxType, " ", aData;
    $endif
  }

  $rect <280,230,480,270>
  method DeviceInterface::VehicleDataClass GetData( arg Enum::VehicleRxType aVehicleRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;

    $if !$prototyper
      if( Enum::VehicleRxType.FUEL_RATE_INSTANT == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_AVERAGE == aVehicleRxType ||
          Enum::VehicleRxType.ODOMETER_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP1_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP2_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_CONSUMPTION == aVehicleRxType ||
          Enum::VehicleRxType.AIR_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.COOLANT_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.BATTERY_VOLTAGE == aVehicleRxType ||
          Enum::VehicleRxType.F_TRIP == aVehicleRxType )
      {
        VehicleData.DataType = Enum::DataType.FLOAT;
      }

      var int32 RxTypeId = ( int32 )aVehicleRxType;
      var bool  Validity = false;

      if( Enum::DataType.FLOAT == VehicleData.DataType )
      {
        var float RxData = 0;
        native( RxTypeId, Validity, RxData )
        {
          float rx_data = 0;
          Validity = VI_get_rx_data_float( RxTypeId, &rx_data );
          if( Validity )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataFloat = RxData;
      }
      else
      {
        var uint32 RxData = 0;
        native( RxTypeId, Validity, RxData )
        {
          uint32_t rx_data = 0;
          Validity = VI_get_rx_data_uint( RxTypeId, &rx_data );
          if( Validity )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataUInt32 = RxData;
      }

      VehicleData.Validity = Validity;
    $else
      // suppress warning
      if( ( int32 )aVehicleRxType >= 0 )
      {
        // empty
      }
    $endif

    return VehicleData;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,260,270>
  $output true
  method void NotifyDataReceived( arg Enum::VehicleRxType aRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;
    VehicleData.RxType = aRxType;
    VehicleDataReceivedSystemEvent.Trigger( VehicleData, false );
  }

  // This object represents an individual system event.
  $rect <20,280,260,320>
  object Core::SystemEvent VehicleDataReceivedSystemEvent;
}

$rect <20,590,220,630>
autoobject DeviceInterface::VehicleDeviceClass VehicleDevice;

$rect <290,170,490,210>
$output false
class WeatherDeviceClass : Templates::DeviceClass
{
  $rect <110,180,310,220>
  method void GetWeatherInfo( arg int32 aWeaItemIdx )
  {
    $if !$prototyper
      var int32 WTime;
      var int32 WType;
      var int32 WTemp;
      var int32 TempMin;
      var int32 TempMax;
      var int32 RainProb;

      trace "index : ", aWeaItemIdx;
      native( aWeaItemIdx, WTime, WType, WTemp, TempMin, TempMax, RainProb )
      {
        bc_motocon_weather_info_t* w_obj = NULL;
        w_obj = ew_get_weather_info_obj( aWeaItemIdx );
        WTime = w_obj->time;
        WType = w_obj->type;
        WTemp = w_obj->temperature;
        TempMin = w_obj->temperature_min;
        TempMax = w_obj->temperature_max;
        RainProb = w_obj->rain_probability;
      }
      WeatherTime = WTime;
      WeatherType = WType;
      Temperature = WTemp;
      MinTemperature = TempMin;
      MaxTemperature = TempMax;
      RainProbability = RainProb;
    $else
      if( aWeaItemIdx > 0 )
      {
      // suppress warning
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <110,300,330,340>
  $output true
  method void NotifyWeatherInfoUpdated()
  {
    IsWeatherInfoReceived = true;
  }

  $rect <320,180,520,220>
  method void GetWeatherLoc()
  {
    $if !$prototyper
      var string CurrentLoc;

      native( CurrentLoc )
      {
        char* cur_loc;
        ew_get_weather_loc( &cur_loc );
        CurrentLoc = EwNewStringAnsi( cur_loc );
      }
    WeatherLocation = CurrentLoc;
    $endif
  }

  $rect <100,-10,300,30>
  var int32 WeatherTime;

  $rect <100,30,300,70>
  var int32 Temperature;

  $rect <100,70,300,110>
  var int32 MaxTemperature;

  $rect <310,-10,510,30>
  var int32 WeatherType;

  $rect <310,30,510,70>
  var int32 MinTemperature;

  $rect <310,70,510,110>
  var int32 RainProbability;

  $rect <100,110,300,150>
  var string WeatherLocation;

  $rect <110,240,340,280>
  method void SendWeatherInfoRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_weather_info_req();
      }
    $endif
  }

  $rect <350,240,590,280>
  method void SendVehicleSettingRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_vehicle_setting_req();
      }
    $endif
  }

  $rect <310,110,510,150>
  var int32 WeekDay;

  $rect <540,180,740,220>
  method void GetWeekDay()
  {
    $if !$prototyper
      var int32 NewWeekDay;

      native( NewWeekDay )
      {
        int week_day = ew_get_weather_week_day();
        NewWeekDay = week_day;
      }
    WeekDay = NewWeekDay;
    $endif
  }

  $rect <530,-10,770,30>
  property bool IsWeatherInfoReceived = false;

  $rect <530,30,770,70>
  onset IsWeatherInfoReceived
  {
    // Remember the property's new value.
    pure IsWeatherInfoReceived = value;

    notifyobservers ^IsWeatherInfoReceived;

  }
}

$rect <290,210,490,250>
autoobject DeviceInterface::WeatherDeviceClass WeatherDevice;

$rect <20,670,220,710>
$output false
class VehicleDataClass
{
  $rect <10,110,210,150>
  var float DataFloat = 0;

  $rect <10,160,210,200>
  var uint32 DataUInt32 = 0;

  $rect <10,10,210,50>
  var bool Validity = false;

  $rect <10,60,210,100>
  var Enum::DataType DataType = Enum::DataType.UINT32;

  $rect <230,10,430,50>
  var Enum::VehicleRxType RxType;
}
