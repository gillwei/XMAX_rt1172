$version 10.00

$rect <20,10,220,50>
inline Inline
{
  #include <stddef.h>
  #include <stdlib.h>
  #include "ew_priv.h"
  #include "display_support.h"
  #include "EEPM_pub.h"
  #include "PERIPHERAL_pub.h"
  #include "VI_pub.h"
  #include "MM_pub_ams_type.h"
  #include "BTM_pub.h"
  #include "BC_motocon_pub.h"
  #include "BC_motocon_pub_type.h"
  #include "BC_ams_pub.h"
  #include "NTF_pub.h"
  #include "TEST_pub.h"
}

$rect <20,70,220,110>
$output false
class SystemDeviceClass : Templates::DeviceClass
{
  // Interface to get system info
  note group Note1
  {
    attr Bounds = <10,10,960,280>;
  }

  $rect <250,70,450,110>
  property string SoftwareVersion;

  $rect <470,70,670,110>
  property bool IsDebugBuild;

  $rect <470,120,670,160>
  onget IsDebugBuild
  {
    $if( !$prototyper )
      var bool is_debug_build;
      native( is_debug_build )
      {
        is_debug_build = ew_is_debug_build();
      }
      return is_debug_build;
    $else
      return true;
    $endif
  }

  // Interfaces for factory test
  note group Note3
  {
    attr Bounds = <10,300,740,460>;
  }

  $rect <40,390,240,430>
  $output true
  method void QuitTest()
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Quit;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <490,390,710,430>
  object Core::SystemEvent FactoryTestSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,340,240,380>
  $output true
  method void TestDisplayPattern( arg int32 aIdx )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.Display;
    TestContext.Data = aIdx - 1;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <30,220,230,260>
  $output true
  method void NotifyEsnRead( arg string aESN )
  {
    ESN = aESN;
  }

  $rect <30,70,230,110>
  property string ESN;

  $rect <30,120,230,160>
  onset ESN
  {
    if( pure ESN != value )
    {
      pure ESN = value;
      notifyobservers ^ESN;
    }

  }

  $rect <30,170,230,210>
  onget ESN
  {
    $if( !$prototyper )
      if( "" == pure ESN )
      {
        native
        {
           ew_get_esn();
        }
      }
    $endif

    return pure ESN;
  }

  $rect <250,120,450,160>
  onget SoftwareVersion
  {
    $if !$prototyper
      var string software_version = "";

      if( "" == pure SoftwareVersion )
      {
        native( software_version )
        {
           char version[8];
           ew_get_software_version( version );
           software_version = EwNewStringAnsi( version );
        }

        pure SoftwareVersion = software_version;
      }
    $endif

    return pure SoftwareVersion;
  }

  $rect <30,520,250,560>
  method void ResetToFactoryDefault()
  {
    FactoryResetTimer.Enabled = true;
    $if !$prototyper
      native
      {
        ew_reset_to_factory_default();
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,570,250,610>
  $output true
  method void NotifyFactoryResetComplete()
  {
    FactoryResetTimer.Enabled = false;
    notifyobservers ^FactoryResetComplete;
  }

  // Device Interface for Factory Reset
  note group Note4
  {
    attr Bounds = <10,480,580,690>;
  }

  $rect <270,520,520,560>
  object Core::Timer FactoryResetTimer
  {
    preset OnTrigger = OnFactoryResetTimeoutSlot;
    preset Period = 2000;
    preset Enabled = false;
  }

  $rect <270,570,520,610>
  slot OnFactoryResetTimeoutSlot
  {
    FactoryResetTimer.Enabled = false;
    NotifyFactoryResetComplete();
  }

  $rect <270,620,520,660>
  method void RebootSystem()
  {
    $if !$prototyper
      native
      {
        ew_reboot_system();
      }
    $endif
  }

  $rect <30,620,250,660>
  property bool FactoryResetComplete = false;

  $rect <750,300,950,340>
  method void SetTFTDutyCycle( arg int32 aDutyCycle )
  {
    $if !$prototyper
      native( aDutyCycle )
      {
        PERIPHERAL_pwm_set_display_dutycycle( aDutyCycle );
      }
    $else
    // suppress warning
    if( 0 == aDutyCycle )
    {
      // empty body
    }
    $endif
  }

  $rect <750,350,950,390>
  property int32 BrightnessLevel = 7;

  $rect <250,170,450,210>
  property string BtSoftwareVersion;

  $rect <250,220,450,260>
  onget BtSoftwareVersion
  {
    $if !$prototyper
      var string bt_sw_version = "";

      native( bt_sw_version )
      {
         char version[8];
         ew_get_bt_software_version( version );
         bt_sw_version = EwNewStringAnsi( version );
      }

      pure BtSoftwareVersion = bt_sw_version;
    $endif

    return pure BtSoftwareVersion;
  }

  $rect <250,340,470,380>
  $output true
  method void StartBurnInTest()
  {
    trace "StartBurnInTest";
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInStart;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <250,390,470,430>
  $output true
  method void UpdateBurnInTestTime( arg uint32 aTimeSec )
  {
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInTimeUpdate;
    TestContext.Data = ( int32 )aTimeSec;
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <499,340,709,380>
  $output true
  method void ShowBurnInTestResult( arg bool aResult )
  {
    trace "ShowBurnInTestResult: ", aResult;
    var Factory::TestContext TestContext = new Factory::TestContext;
    TestContext.TestItem = Enum::FactoryTest.BurnInResult;
    if( aResult )
    {
      TestContext.Data = 1;
    }
    else
    {
      TestContext.Data = 0;
    }
    FactoryTestSystemEvent.Trigger( TestContext, false );
  }

  $rect <470,170,670,210>
  var bool IsHopperTestMode = false;

  // Device Interface for QR code
  note group Note5
  {
    attr Bounds = <610,480,1120,690>;
  }

  $rect <870,520,1070,560>
  object Core::SystemEvent QrCodeSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <650,520,850,560>
  $output true
  method void NotifyQrCodeReady( arg string aQrCodeStr )
  {
    trace "QR code is ready";
    QrCodeText = aQrCodeStr;
    QrCodeSystemEvent.Trigger( null, false );
  }

  $rect <650,570,850,610>
  method void GetQrCode( arg int32 pixelnum )
  {
    $if !$prototyper
      native( pixelnum )
      {
        ew_request_qrcode( pixelnum );
      }
    $else
      // suppress warning
      if( pixelnum > 0 )
      {
        // empty body
      }
    $endif
  }

  $rect <680,120,930,160>
  method DeviceInterface::RtcTime GetLocalTime()
  {
    var DeviceInterface::RtcTime CurrentLocalTime = new DeviceInterface::RtcTime;

    $if !$prototyper
      var uint16 RtcYear;
      var uint8 RtcMonth;
      var uint8 RtcDay;
      var uint8 RtcHour;
      var uint8 RtcMinute;
      var uint8 RtcSecond;

      native( RtcYear, RtcMonth, RtcDay, RtcHour, RtcMinute, RtcSecond )
      {
        snvs_lp_srtc_datetime_t srtc_time;
        ew_get_rtc_time( &srtc_time );

        RtcYear = srtc_time.year;
        RtcMonth = srtc_time.month;
        RtcDay = srtc_time.day;
        RtcHour = srtc_time.hour;
        RtcMinute = srtc_time.minute;
        RtcSecond = srtc_time.second;
      }

      CurrentLocalTime.Year = RtcYear;
      CurrentLocalTime.Month = RtcMonth;
      CurrentLocalTime.Day = RtcDay;
      CurrentLocalTime.Hour = RtcHour;
      CurrentLocalTime.Minute = RtcMinute;
      CurrentLocalTime.Second = RtcSecond;
    $else
      // for screenshot
      CurrentLocalTime.Hour = 12;
      CurrentLocalTime.Minute = 40;
    $endif

    return CurrentLocalTime;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <681,70,930,110>
  $output true
  method void NotifyUpdateLocalTime()
  {
    UpdateLocalTimeSystemEvent.Trigger( null, false );
  }

  $rect <680,170,930,210>
  object Core::SystemEvent UpdateLocalTimeSystemEvent;

  $rect <870,570,1070,610>
  property string QrCodeText;

  // Opening Flow Control
  note group Note6
  {
    attr Bounds = <440,700,1120,910>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <455,746,665,786>
  $output true
  method void StartOpening()
  {
    OpeningSystemEvent.Trigger( null, false );
  }

  $rect <455,796,665,836>
  object Core::SystemEvent OpeningSystemEvent;

  $rect <470,220,670,260>
  method bool IsKeyStateValid()
  {
    var bool IsValid = true;
    $if !$prototyper
      native( IsValid )
      {
        IsValid = VI_is_key_state_valid();
      }
    $endif
    return IsValid;
  }

  $rect <675,746,885,786>
  method bool IsTFTBacklightOn()
  {
    var bool IsBacklightOn = false;
    $if !$prototyper
      native( IsBacklightOn )
      {
        IsBacklightOn = display_is_tft_backlight_on();
      }
    $else
      IsBacklightOn = true;
    $endif
    return IsBacklightOn;
  }

  $rect <900,747,1100,787>
  property Enum::OperationMode OperationMode;

  $rect <900,797,1100,837>
  onset OperationMode
  {
    if( pure OperationMode != value )
    {
      pure OperationMode = value;
      $if !$prototyper
        native( value )
        {
          ew_set_operation_mode( value );
        }
      $endif
    }
  }

  $rect <899,847,1099,887>
  onget OperationMode
  {
    $if !$prototyper
      var Enum::OperationMode Mode = Enum::OperationMode.NORMAL;
      native( Mode )
      {
        Mode = ew_get_operation_mode();
      }
      pure OperationMode = Mode;
    $endif

    return pure OperationMode;
  }

  $rect <675,796,885,836>
  method bool IsOperationModeReady()
  {
    var bool IsOperationModeReady = false;
    $if !$prototyper
      native( IsOperationModeReady )
      {
        IsOperationModeReady = ew_is_operation_mode_ready();
      }
    $else
      IsOperationModeReady = true;
    $endif
    return IsOperationModeReady;
  }

  // Inspection Mode
  note group Note7
  {
    attr Bounds = <10,700,310,1160>;
  }

  $rect <30,1040,290,1080>
  object Core::SystemEvent InspectionDisplaySystemEvent;

  $rect <30,890,290,930>
  object Core::SystemEvent InspectionModeSystemEvent;

  // Notifiy the inspection display pattern to test
  $rect <30,740,290,780>
  $output true
  method void NotifyInspectionRequest( arg Enum::InspectionMode aMode, arg Enum::InspectionDisplay aDisplayPattern )
  {
    InspectionDisplayPattern = aDisplayPattern;
    InspectionMode = aMode;
  }

  $rect <30,790,230,830>
  property Enum::InspectionMode InspectionMode = Enum::InspectionMode.NONE;

  $rect <30,840,230,880>
  onset InspectionMode
  {
    pure InspectionMode = value;
    InspectionModeSystemEvent.Trigger( null, false );
  }

  $rect <30,940,230,980>
  property Enum::InspectionDisplay InspectionDisplayPattern;

  $rect <30,990,230,1030>
  onset InspectionDisplayPattern
  {
    if ( pure InspectionDisplayPattern != value )
    {
      pure InspectionDisplayPattern = value;
      InspectionDisplaySystemEvent.Trigger( null, false );
    }
  }

  $rect <30,1090,250,1130>
  method void SendInspectionResponse( arg Enum::InspectionMode aMode, arg uint8 aRes )
  {
    $if !$prototyper
      native( aMode, aRes )
      {
        VI_send_inspection_response( aMode, aRes );
      }
    $endif
  }
}

$rect <20,110,220,150>
autoobject DeviceInterface::SystemDeviceClass SystemDevice;

$rect <20,300,230,340>
$output false
class NavigationDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,90,220,130>
  object Core::SystemEvent MapUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,40,220,80>
  $output true
  method void NotifyMapUpdate()
  {
    MapUpdateEvent.Trigger( null, true );
  }

  $rect <250,40,450,80>
  method bool IsMapFrameReady()
  {
    $if( !$prototyper )
      var bool IsMapFrameReady = false;
      native( IsMapFrameReady )
      {
        IsMapFrameReady = ew_navi_is_map_frame_ready();
      }
      return IsMapFrameReady;
    $else
      return false;
    $endif
  }

  $rect <230,150,430,190>
  object Core::SystemEvent CurRdUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,150,220,190>
  $output true
  method void NotifyCurRdUpdate()
  {
    CurRdUpdateEvent.Trigger( null, false );
  }

  $rect <220,190,420,230>
  object Core::SystemEvent ETAUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,190,220,230>
  $output true
  method void NotifyETAUpdate()
  {
    ETAUpdateEvent.Trigger( null, false );
  }

  $rect <220,230,420,270>
  object Core::SystemEvent DayNightModeUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,220,270>
  $output true
  method void NotifyDayNightModeUpdate()
  {
    DayNightModeUpdateEvent.Trigger( null, false );
  }

  $rect <220,270,420,310>
  object Core::SystemEvent SpeedLimitUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,270,220,310>
  $output true
  method void NotifySpeedLimitUpdate()
  {
    SpeedLimitUpdateEvent.Trigger( null, false );
  }

  $rect <220,310,420,350>
  object Core::SystemEvent NaviIncidentUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,310,220,350>
  $output true
  method void NotifyNaviEventUpdate()
  {
    NaviIncidentUpdateEvent.Trigger( null, false );
  }

  $rect <460,150,660,190>
  method DeviceInterface::NaviDataClass GetNaviData( arg Enum::NaviDataType aDataType )
  {
    var DeviceInterface::NaviDataClass NaviData = new DeviceInterface::NaviDataClass;
    $if !$prototyper
    var int32 NaviDataType = ( int32 )aDataType;

    // suppress warning
    if( NaviDataType )
    {
      // empty body
    }

    native( NaviDataType, NaviData )
    {
      #if( UNIT_TEST_NAVI )
        navi_data_type* navi_obj = NULL;
        navi_obj = TEST_get_navi_obj();
        switch( NaviDataType )
        {
          case 0:
            {
              NaviData->CurrentRoad = EwNewStringUtf8( ( const unsigned char* )navi_obj->current_road, ( int )strlen( navi_obj->current_road ) );
            }
            break;
          case 1:
            {
              NaviData->ETA = navi_obj->eta;
            }
            break;
          case 2:
            {
              NaviData->SpeedLimit = navi_obj->speed_limit;
            }
            break;
          case 3:
            {
              NaviData->DayNightMode = navi_obj->daynight;
            }
            break;
          case 4:
            {
              NaviData->NaviEventType = navi_obj->navi_event.event_type;
              NaviData->NaviEventDist = EwNewStringUtf8( ( const unsigned char* )navi_obj->navi_event.dist, ( int )strlen( navi_obj->navi_event.dist ) );
              NaviData->NaviEventSpeed = EwNewStringUtf8( ( const unsigned char* )navi_obj->navi_event.speed, ( int )strlen( navi_obj->navi_event.speed ) );
              NaviData->NaviEventVisibility = navi_obj->navi_event.visibility;
            }
            break;
          default:
            break;
        }
      #endif
    }
    $else
      aDataType; // suppress warning.
    $endif

    return NaviData;

  }

  $rect <250,90,450,130>
  method bool IsRouteGuidanceStarted()
  {
    $if( !$prototyper )
      var bool IsNavigating= false;
      native( IsNavigating )
      {
        IsNavigating = ew_navi_is_route_guidance_started();
      }
      return IsNavigating;
    $else
      return false;
    $endif
  }

  $rect <220,350,420,390>
  object Core::SystemEvent NavigatingStatusUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,350,220,390>
  $output true
  method void NotifyNavigatingStatusUpdate()
  {
    NavigatingStatusUpdateEvent.Trigger( null, false );
  }

  $rect <220,400,420,440>
  object Core::SystemEvent TbtListUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,400,220,440>
  $output true
  method void NotifyTbtListUpdate( arg int32 aNewTbtListSize )
  {
    TbtListSize = aNewTbtListSize;
    TbtListUpdateEvent.Trigger( null, false );
  }

  $rect <220,450,420,490>
  object Core::SystemEvent ActiveTbtItemUpdateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,450,220,490>
  $output true
  method void NotifyActiveTbtItemUpdate( arg int32 aNewActiveTbtItemIdx )
  {
    ActiveTbtItemIdx = aNewActiveTbtItemIdx;
    ActiveTbtItemUpdateEvent.Trigger( null, false );
  }

  $rect <460,210,660,250>
  method DeviceInterface::NaviTbtDataClass GetNaviTbtData( arg int32 aTbtItemIdx )
  {
    var DeviceInterface::NaviTbtDataClass NaviTbtData = new DeviceInterface::NaviTbtDataClass;

    $if !$prototyper
      native( NaviTbtData, aTbtItemIdx )
      {
        #if( UNIT_TEST_NAVI )
          uint32_t list_idx;
          uint32_t icon_idx;
          uint16_t distance;
          char* dist_unit;
          char* description;
          TEST_get_navi_tbt_data( aTbtItemIdx, &list_idx, &icon_idx, &distance, &dist_unit, &description );
          NaviTbtData->ListIdx = list_idx;
          NaviTbtData->IconIdx = icon_idx;
          NaviTbtData->Distance = distance;
          NaviTbtData->DistUnit = EwNewStringUtf8( ( const unsigned char* )dist_unit, ( int )strlen( dist_unit ) );
          NaviTbtData->TbtDescription = EwNewStringUtf8( ( const unsigned char* )description, ( int )strlen( description ) );
        #endif
      }
    $else
      aTbtItemIdx; // suppress warning.
    $endif

    return NaviTbtData;
  }

  $rect <480,40,680,80>
  var int32 ActiveTbtItemIdx;

  $rect <480,90,680,130>
  var int32 TbtListSize = 0;

  $rect <710,40,910,80>
  var Enum::HomeType CurrentHome = Enum::HomeType.NAVI_DEFAULT_VIEW;
}

$rect <20,340,230,380>
autoobject DeviceInterface::NavigationDeviceClass NavigationDevice;

$rect <260,300,500,340>
$output false
class MediaManagerDeviceClass : Templates::DeviceClass
{
  $rect <30,20,230,60>
  property string Title;

  $rect <30,60,230,100>
  onset Title
  {
    // Get song title when receiving from media manager or UI initialization.
    if( IsTitleReceived || IsInit )
    {
      // Remember the property's new value.
      pure Title = value;
    }
    else
    {
      // Fail to receive song title, show "---".
      pure Title = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Title;
  }

  $rect <250,20,450,60>
  property string Album;

  $rect <250,60,450,100>
  onset Album
  {
    // Get album when receiving from media manager or UI initialization.
    if( IsAlbumReceived || IsInit )
    {
      // Remember the property's new value.
      pure Album = value;
    }
    else
    {
      // Fail to receive album, show "---".
      pure Album = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Album;
  }

  $rect <480,20,680,60>
  property string Artist;

  $rect <480,60,680,100>
  onset Artist
  {
    // Get artist when receiving from media manager or UI initialization.
    if( IsArtistReceived || IsInit )
    {
      // Remember the property's new value.
      pure Artist = value;
    }
    else
    {
      // Fail to receive artist, show "---".
      pure Artist = Strings::GEN_THREE_HYPHENS;
    }

    // Notify all associated property observers.
    notifyobservers ^Artist;
  }

  $rect <720,60,920,100>
  property int32 DurationTimeSec = 0;

  $rect <720,470,940,510>
  method void SendRemoteCommand( arg Enum::MusicControlType cmd_type )
  {
    $if !$prototyper
    var int32 cmd_idx = ( int32 )cmd_type;
    // suppress warning
    if( cmd_idx )
    {
      // empty body
    }
    native( cmd_idx )
    {
      ams_remote_command cmd = AMS_REMOTE_COMMAND_CNT;

      switch( cmd_idx )
      {
        case 0:
          cmd = AMS_REMOTE_COMMAND_PLAY;
          break;
        case 1:
          cmd = AMS_REMOTE_COMMAND_PAUSE;
          break;
        case 2:
          cmd = AMS_REMOTE_COMMAND_NEXT_TRACK;
          break;
        case 3:
          cmd = AMS_REMOTE_COMMAND_PREVIOUS_TRACK;
          break;
        default:
          break;
      }
      ew_send_command( cmd );
    }
    $endif
  }

  $rect <720,20,920,60>
  property int32 ElapsedTimeSec = 0;

  // An interface to set/get data from device
  note group Note1
  {
    attr Bounds = <10,430,1040,540>;
  }

  $rect <350,240,550,280>
  $output true
  method void NotifyTitleChanged( arg string aTitle )
  {
    trace "NotifyTitleChanged: " + aTitle;
    IsTitleReceived = true;
    Title = aTitle;
  }

  $rect <350,320,550,360>
  $output true
  method void NotifyArtistChanged( arg string aArtist )
  {
    trace "NotifyArtistChanged: " + aArtist;
    IsArtistReceived = true;
    Artist = aArtist;
  }

  $rect <350,280,550,320>
  $output true
  method void NotifyAlbumChanged( arg string aAlbum )
  {
    trace "NotifyAlbumChanged: " + aAlbum;
    IsAlbumReceived = true;
    Album = aAlbum;
  }

  $rect <50,470,250,510>
  method int32 GetPlayBackStateInfo()
  {
    var int32 PlayBackState = 0;
    $if !$prototyper
    native ( PlayBackState )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      PlayBackState = mp_state->playback_state;
    }
    $endif
    return PlayBackState;
  }

  $rect <270,470,470,510>
  method void GetPlaybackInfo()
  {
    var int32 ela_time = 0;
    var int32 dur = 0;
    $if !$prototyper
    native ( ela_time, dur )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      ela_time = mp_state->current_elapsed_time_sec;
      dur = mp_state->duration_sec;
    }
    $endif
    ElapsedTimeSec = ela_time;
    DurationTimeSec = dur;
  }

  $rect <500,470,700,510>
  method void GetTrackInfo()
  {
    var string media_artist = "";
    var string media_album = "";
    var string media_title = "";
    $if !$prototyper
    native ( media_artist, media_album, media_title )
    {
      mm_media_player_obj* mp_state = NULL;
      mp_state = ew_get_media_player_state();
      media_artist = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_artist, ( int )strlen( mp_state->str.track_artist ) );
      media_album = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_album, ( int )strlen( mp_state->str.track_album ) );
      media_title = EwNewStringUtf8( ( const unsigned char* )mp_state->str.track_title, ( int )strlen( mp_state->str.track_title ) );
    }
    $endif
    Artist = media_artist;
    Album = media_album;
    Title = media_title;
  }

  $rect <720,240,920,280>
  var bool IsInit = false;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,280,320,320>
  $output true
  method void NotifyPlayBackTimeChanged( arg int32 aElapsedTimeSec, arg int32 aDurationTimeSec )
  {
    trace "ElapsedTime: ", aElapsedTimeSec;
    trace "Duration: ", aDurationTimeSec;
    ElapsedTimeSec = aElapsedTimeSec;
    DurationTimeSec = aDurationTimeSec;

    NotifyPlayBackTimeChangedSystemEvent.Trigger( null, false );
  }

  $rect <30,240,320,280>
  object Core::SystemEvent NotifyPlayBackTimeChangedSystemEvent;

  $rect <720,280,920,320>
  var bool IsTitleReceived = false;

  $rect <720,320,920,360>
  var bool IsAlbumReceived = false;

  $rect <720,360,920,400>
  var bool IsArtistReceived = false;

  $rect <50,560,250,600>
  object Core::SystemEvent NotifyMotoConMusicUpdatedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,560,460,600>
  $output true
  method void NotfiyMotoConMusicInfoUpdated()
  {
    IsTitleReceived = true;
    IsAlbumReceived = true;
    IsArtistReceived = true;
    NotifyMotoConMusicUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <470,610,670,650>
  method bool IsAmsConnected()
  {
    $if !$prototyper
      var bool AmsConnected = false;
      native( AmsConnected )
      {
        AmsConnected = BC_ams_is_ams_connected();
      }
      return AmsConnected;
    $else
      return false;
    $endif
  }

  $rect <50,610,250,650>
  object Core::SystemEvent NotifyAmsBleConnectedStatusSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <260,610,460,650>
  $output true
  method void NotifyAmsBleConnectedStatusChanged()
  {
    NotifyAmsBleConnectedStatusSystemEvent.Trigger( null, false );
  }
}

$rect <261,344,461,384>
autoobject DeviceInterface::MediaManagerDeviceClass MediaManagerDevice;

$rect <750,70,950,110>
$output false
class BluetoothDeviceClass : Templates::DeviceClass
{
  // BT related properties
  note group Note1
  {
    attr Bounds = <10,10,1600,260>;
  }

  // Interfaces to react to BT system events
  note group Note2
  {
    attr Bounds = <9,280,1690,450>;
  }

  // Interfaces to perform BT operations on device
  note group Note3
  {
    attr Bounds = <10,470,840,690>;
  }

  $rect <290,510,503,550>
  method void GetPairedDeviceAtItem( arg int32 aItemNo )
  {
    $if !$prototyper
      var string DevName;
      var bool   IsConnected;

      native( aItemNo, DevName, IsConnected )
      {
        uint8_t* device_name;
        bool     is_connected;
        ew_bt_get_paired_device_at_index( aItemNo, &device_name, &is_connected );
        DevName = EwNewStringUtf8( (const unsigned char*)device_name, (int)strlen( (char*)device_name ) );
        IsConnected = is_connected;
      }
      PairedDeviceObj.DeviceName = DevName;
      PairedDeviceObj.IsConnected = IsConnected;
    $else
      if( aItemNo > 0 )
      {
        // empty body to suppress warning
      }
    $endif
  }

  $rect <30,380,290,420>
  object Core::SystemEvent BtcPairingChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,330,290,370>
  $output true
  method void NotifyBtcPairingStateChanged( arg Enum::BtcPairingState aState )
  {
    BtcPairingState = aState;
    BtcPairingChangedSystemEvent.Trigger( null, false );
  }

  $rect <302,330,502,370>
  property Enum::BtcPairingState BtcPairingState;

  $rect <250,50,450,90>
  property bool Discoverable = false;

  $rect <250,100,450,140>
  onset Discoverable
  {
    if( pure Discoverable != value )
    {
      pure Discoverable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_discoverable( ( bool )value );
        }
      $endif
    }
  }

  $rect <250,150,450,190>
  onget Discoverable
  {
    $if !$prototyper
      var bool IsDiscoverable = false;
      native( IsDiscoverable )
      {
        IsDiscoverable = ew_bt_get_discoverable();
      }
      return IsDiscoverable;
    $else
      return pure Discoverable;
    $endif
  }

  $rect <30,50,240,90>
  property bool BluetoothEnable = false;

  $rect <30,100,240,140>
  onset BluetoothEnable
  {
    trace "OnSetBluetoothEnable ", value;

    if( pure BluetoothEnable != value )
    {
      pure BluetoothEnable = value;
      $if !$prototyper
        native
        {
          ew_bt_set_enable( ( bool )value );
        }
      $endif
    }

    notifyobservers ^BluetoothEnable;
  }

  $rect <30,150,240,190>
  onget BluetoothEnable
  {
    return pure BluetoothEnable;

  }

  $rect <460,50,660,90>
  property bool AutoConnect;

  $rect <460,100,660,140>
  onset AutoConnect
  {
    pure AutoConnect = value;
    $if !$prototyper
      native
      {
        ew_bt_set_autoconnect( ( bool )value );
      }
    $endif
  }

  $rect <460,150,660,190>
  onget AutoConnect
  {
    $if !$prototyper
      var bool IsAutoConnect = false;
      native( IsAutoConnect )
      {
        IsAutoConnect = ew_bt_get_autoconnect();
      }
      return IsAutoConnect;
    $else
      return pure AutoConnect;
    $endif
  }

  $rect <670,50,880,90>
  property int32 PairedDeviceNum;

  $rect <670,100,880,140>
  onget PairedDeviceNum
  {
    $if !$prototyper
      var int32 PairedDevNum = 0;
      native( PairedDevNum )
      {
        PairedDevNum = ew_bt_get_paired_device_num();
      }
      return PairedDevNum;
    $else
      return pure PairedDeviceNum;
    $endif

  }

  $rect <40,630,260,670>
  method void UnpairDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_unpair_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <290,570,503,610>
  object DeviceInterface::BluetoothPairedDeviceInfo PairedDeviceObj;

  $rect <30,200,240,240>
  method void GetBluetoothEnable()
  {
    $if !$prototyper
      var bool enable = false;
      native( enable )
      {
        enable = ew_bt_get_enable();
      }
      BluetoothEnable = enable;
    $endif
  }

  $rect <1108,50,1338,90>
  property string LocalDeviceName;

  $rect <1108,100,1338,140>
  onget LocalDeviceName
  {
    var string LocalDevName;
    $if !$prototyper
      native( LocalDevName )
      {
        uint8_t* device_name;
        ew_bt_get_local_device_name( &device_name );
        LocalDevName = EwNewStringUtf8( (const unsigned char*)device_name, (int)strlen( (char*)device_name ) );
      }
    $else
      LocalDevName = "Prototyper";
    $endif
    return LocalDevName;
  }

  $rect <1350,50,1580,90>
  property string LocalDeviceAddress;

  $rect <1350,100,1580,140>
  onget LocalDeviceAddress
  {
    $if !$prototyper
      var string DeviceAddr = "";
      native( DeviceAddr )
      {
        uint8_t dev_addr[BT_DEVICE_ADDRESS_LEN + 1];
        ew_bt_get_local_device_address( dev_addr );
        dev_addr[BT_DEVICE_ADDRESS_LEN + 1] = NULL;
        DeviceAddr = EwNewStringAnsi( dev_addr );
      }
      return DeviceAddr;
    $else
      return pure LocalDeviceAddress;
    $endif
  }

  $rect <40,510,260,550>
  method void ConnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_connect_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( aPairedDeviceIndex > 0 )
      {
        // empty body
      }
    $endif
  }

  $rect <290,630,490,670>
  method bool IsBlePairedDevice( arg int32 aPairedDeviceIndex )
  {
    var bool IsBlePairedDevice = false;
    $if !$prototyper
      native ( aPairedDeviceIndex, IsBlePairedDevice )
      {
        IsBlePairedDevice = ew_bt_is_ble_paired_device( aPairedDeviceIndex );
      }
    $else
      // suppress warning
      if( "" == aPairedDeviceIndex )
      {
        // empty body
      }
    $endif
    return IsBlePairedDevice;
  }

  $rect <40,570,260,610>
  method void DisconnectPairedDevice( arg int32 aPairedDeviceIndex )
  {
    $if !$prototyper
      native ( aPairedDeviceIndex )
      {
        ew_bt_disconnect_paired_device( aPairedDeviceIndex );
      }
    $endif
  }

  $rect <891,50,1091,90>
  property bool IsMaxPairedDevice;

  $rect <891,100,1091,140>
  onget IsMaxPairedDevice
  {
    $if !$prototyper
      var bool is_max_paired_device = false;
      native( is_max_paired_device )
      {
        is_max_paired_device = ew_bt_is_max_paired_device_num();
      }
      return is_max_paired_device;
    $else
      return pure IsMaxPairedDevice;
    $endif
  }

  $rect <40,806,240,846>
  property Enum::BtFwStatus BtFwStatus;

  $rect <40,860,240,900>
  onset BtFwStatus
  {
    if ( pure BtFwStatus != value )
    {
      pure BtFwStatus = value;
      notifyobservers ^BtFwStatus;
    }

  }

  $rect <40,750,240,790>
  $output true
  method void NotifyBtFwStatus( arg Enum::BtFwStatus status, arg string version )
  {
    trace "NotifyBtFWStatus: ", status;
    trace "BtFwVer: ", version;

    BtFwStatus = status;
  }

  // Interfaces to BT firmware update
  note group Note4
  {
    attr Bounds = <10,710,320,920>;
  }

  $rect <530,510,750,550>
  property bool RefreshPairedDeviceList;

  $rect <530,570,790,610>
  onset RefreshPairedDeviceList
  {
    pure RefreshPairedDeviceList = value;
    notifyobservers ^RefreshPairedDeviceList;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <760,330,1110,370>
  $output true
  method void NotifyPairedDeviceConnectionStatusUpdated()
  {
    RefreshPairedDeviceList = true;
    PairedDeviceUpdatedSystemEvent.Trigger( null, false );
  }

  // Interfaces of BLE
  note group Note5
  {
    attr Bounds = <860,470,1640,730>;
  }

  // MotoCon connection status
  note group Note6
  {
    attr Bounds = <350,710,660,920>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <881,520,1130,560>
  $output true
  method void NotifyBlePairingStateChanged()
  {
    BlePairingStateChangedEvent.Trigger( null, false );
  }

  $rect <880,570,1130,610>
  object Core::SystemEvent BlePairingStateChangedEvent;

  $rect <1150,620,1360,660>
  method void SetBleAdvertisement( arg bool aEnable )
  {
    $if !$prototyper
      native( aEnable )
      {
        BTM_set_ble_advertisement( aEnable );
      }
    $else
      trace "SetBleAdvertisement ", aEnable;
    $endif
  }

  $rect <670,150,870,190>
  method bool IsBtConnected()
  {
    var bool BtConnected = false;

    $if !$prototyper
      native( BtConnected )
      {
        BtConnected = BTM_is_bt_connected();
      }
    $endif

    return BtConnected;
  }

  $rect <1150,670,1360,710>
  method int32 GetBlePairingFailCount()
  {
    var int32 FailCount = 0;

    $if !$prototyper
    native( FailCount )
    {
      FailCount = BTM_get_ble_pairing_fail_count();
    }
    $endif

    return FailCount;
  }

  $rect <1370,520,1620,560>
  method bool IsMotoconConnected()
  {
    $if !$prototyper
      var bool MotoconConnected = false;
      native( MotoconConnected )
      {
        MotoconConnected = BC_motocon_is_connected();
      }
      return MotoconConnected;
    $else
      return false;
    $endif
  }

  $rect <1370,570,1620,610>
  method string GetBleConnectedDeviceName()
  {
    var string BleConnectedDeviceName = "";

    $if !$prototyper
      native( BleConnectedDeviceName )
      {
        uint8_t* ble_connected_device_name;
        bool has_ble_connected_device = BTM_get_ble_connected_device_name( &ble_connected_device_name );
        if( has_ble_connected_device )
        {
          BleConnectedDeviceName = EwNewStringUtf8( (const unsigned char*)ble_connected_device_name, (int)strlen( (char*)ble_connected_device_name ) );
        }
      }
    $endif

    return BleConnectedDeviceName;
  }

  $rect <880,620,1080,660>
  property Enum::BlePairingState BlePairingState;

  $rect <880,670,1080,710>
  onget BlePairingState
  {
    var Enum::BlePairingState State;

    $if !$prototyper
      native( State )
      {
        State = ew_get_ble_pairing_state();
      }
    $endif

    return State;
  }

  $rect <1150,520,1350,560>
  property uint32 BlePincode;

  $rect <1150,570,1350,610>
  onget BlePincode
  {
    $if !$prototyper
      var uint32 Pincode = 0;
      native( Pincode )
      {
        Pincode = ew_get_ble_pincode();
      }
      return Pincode;
    $else
      return pure BlePincode;
    $endif
  }

  $rect <380,760,630,800>
  $output true
  method void NotifyMotoConEventReceived( arg Enum::MotoConRxEvent aEvent )
  {
    var DeviceInterface::MotoConContext MotoConContext = new DeviceInterface::MotoConContext;
    MotoConContext.RxEvent = aEvent;
    MotoConSystemEvent.Trigger( MotoConContext, false );
  }

  $rect <380,810,630,850>
  object Core::SystemEvent MotoConSystemEvent;

  $rect <760,380,1110,420>
  object Core::SystemEvent PairedDeviceUpdatedSystemEvent;

  $rect <1130,380,1370,420>
  property Enum::BtDeviceConnectionResult ConnectPairedDeviceResult;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <1130,330,1370,370>
  $output true
  method void NotifyBtcConnectionResult( arg Enum::BtDeviceConnectionResult aResult )
  {
    ConnectPairedDeviceResult = aResult;
    BtcConnectionResultSystemEvent.Trigger( null, false );
  }

  $rect <1380,380,1670,420>
  object Core::SystemEvent BtcConnectionResultSystemEvent;

  $rect <300,380,500,420>
  method uint32 GetBtcPasskey()
  {
    var uint32 Passkey;
    $if !$prototyper
      native( Passkey )
      {
        Passkey = ew_get_btc_passkey();
      }
    $endif
    return Passkey;
  }

  $rect <510,330,740,370>
  method string GetBtcPairingDeviceName()
  {
    var string PairingDeviceName;
    $if !$prototyper
      native( PairingDeviceName )
      {
        uint8_t* btc_pairing_device_name;
        ew_bt_get_btc_connecting_device_name( &btc_pairing_device_name );
        PairingDeviceName = EwNewStringUtf8( (const unsigned char*)btc_pairing_device_name, (int)strlen( (char*)btc_pairing_device_name ) );
      }
    $else
      PairingDeviceName = "(Device name)";
    $endif
    return PairingDeviceName;
  }
}

$rect <750,110,950,150>
autoobject DeviceInterface::BluetoothDeviceClass BluetoothDevice;

$rect <750,150,950,190>
$output false
class BluetoothPairedDeviceInfo
{
  $rect <20,10,220,50>
  var string DeviceName;

  $rect <20,60,220,100>
  var bool IsConnected;
}

$rect <20,150,220,190>
$output false
class RtcTime
{
  $rect <20,10,220,50>
  var uint16 Year;

  $rect <20,50,220,90>
  var uint8 Month;

  $rect <20,90,220,130>
  var uint8 Day;

  $rect <20,130,220,170>
  var uint8 Hour;

  $rect <20,170,220,210>
  var uint8 Minute;

  $rect <20,210,220,250>
  var uint8 Second;
}

$rect <500,110,700,150>
$output false
class VehicleDeviceClass : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <20,100,310,140>
  object Core::SystemEvent DDModeStateChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,50,260,90>
  $output true
  method void NotifyDDModeStateChanged()
  {
    DDModeStateChangedSystemEvent.Trigger( null, false );
  }

  // Driver Distraction Mode System Event
  note group Note2
  {
    attr Bounds = <0,0,560,160>;
  }

  $rect <320,50,540,90>
  property bool DDModeActivated;

  $rect <320,100,540,140>
  onget DDModeActivated
  {
    $if !$prototyper
      var bool IsActivated = false;

      native( IsActivated )
      {
        IsActivated = VI_is_dd_mode_activated();
      }

      return IsActivated;
    $else
      return pure DDModeActivated;
    $endif
  }

  $rect <20,180,260,220>
  method bool IsVehicleFunctionSupported( arg Enum::VehicleSupportedFunction aVehicleFeature )
  {
    var bool IsSupported = false;

    $if !$prototyper
      var int32 FeatureId = ( int32 )aVehicleFeature;
      native( IsSupported, FeatureId )
      {
        IsSupported = VI_is_function_supported( FeatureId );
      }
    $else
      // enable pressure in the unit setting for screenshot
      if( Enum::VehicleSupportedFunction.TIRE_FRONT == aVehicleFeature )
      {
        IsSupported = true;
      }
    $endif

    return IsSupported;
  }

  $rect <280,180,480,220>
  method void SetData( arg Enum::VehicleTxType aVehicleTxType, arg uint32 aData )
  {
    $if !$prototyper
      var int32 TxTypeId = ( int32 )aVehicleTxType;
      native( aData, TxTypeId )
      {
        VI_set_tx_data( TxTypeId, aData );
      }
    $else
      trace "set vi tx data ", aVehicleTxType, " ", aData;
    $endif
  }

  $rect <280,230,480,270>
  method DeviceInterface::VehicleDataClass GetData( arg Enum::VehicleRxType aVehicleRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;

    $if !$prototyper
      if( Enum::VehicleRxType.FUEL_RATE_INSTANT == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_RATE_AVERAGE == aVehicleRxType ||
          Enum::VehicleRxType.ODOMETER_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP1_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.TRIP2_VALUE == aVehicleRxType ||
          Enum::VehicleRxType.FUEL_CONSUMPTION == aVehicleRxType ||
          Enum::VehicleRxType.AIR_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.COOLANT_TEMPERATURE == aVehicleRxType ||
          Enum::VehicleRxType.BATTERY_VOLTAGE == aVehicleRxType ||
          Enum::VehicleRxType.F_TRIP == aVehicleRxType )
      {
        VehicleData.DataType = Enum::DataType.FLOAT;
      }

      var int32 RxTypeId = ( int32 )aVehicleRxType;
      var bool  Valid = false;

      if( Enum::DataType.FLOAT == VehicleData.DataType )
      {
        var float RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          float rx_data = 0;
          Valid = VI_get_rx_data_float( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataFloat = RxData;
      }
      else
      {
        var uint32 RxData = 0;
        native( RxTypeId, Valid, RxData )
        {
          uint32_t rx_data = 0;
          Valid = VI_get_rx_data_uint( RxTypeId, &rx_data );
          if( Valid )
          {
            RxData = rx_data;
          }
        }
        VehicleData.DataUInt32 = RxData;
      }

      VehicleData.Valid = Valid;
    $else
      // suppress warning
      if( ( int32 )aVehicleRxType >= 0 )
      {
        // empty
      }
    $endif

    return VehicleData;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,230,260,270>
  $output true
  method void NotifyDataReceived( arg Enum::VehicleRxType aRxType )
  {
    var DeviceInterface::VehicleDataClass VehicleData = new DeviceInterface::VehicleDataClass;
    VehicleData.RxType = aRxType;
    VehicleDataReceivedSystemEvent.Trigger( VehicleData, false );
  }

  // This object represents an individual system event.
  $rect <20,280,260,320>
  object Core::SystemEvent VehicleDataReceivedSystemEvent;

  $rect <20,330,220,370>
  var Enum::MeterDisplay CurrentMeterDisplay = Enum::MeterDisplay.TACHOMETER;

  $rect <20,380,220,420>
  var Enum::MileageSettingItem CurrentMileageSetting;

  $rect <20,430,220,470>
  var Enum::FuelSettingItem CurrentFuelSetting;

  $rect <20,480,220,520>
  var Enum::PressureSettingItem CurrentPressureSetting;

  $rect <20,530,220,570>
  var Enum::TemperatureSettingItem CurrentTempSetting;

  $rect <20,580,220,620>
  var Enum::VehicleSupportedFunction CurrentVehicleFunction;
}

$rect <500,70,700,110>
autoobject DeviceInterface::VehicleDeviceClass VehicleDevice;

$rect <260,70,460,110>
$output false
class WeatherDeviceClass : Templates::DeviceClass
{
  $rect <110,180,310,220>
  method void GetWeatherInfo( arg int32 aWeaItemIdx )
  {
    $if !$prototyper
      var int32 WTime;
      var int32 WType;
      var int32 WTemp;
      var int32 TempMin;
      var int32 TempMax;
      var int32 RainProb;

      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.TEMPERATURE_UNIT );
      var Enum::TemperatureSettingItem WeaTempType = ( Enum::TemperatureSettingItem )VehicleData.DataUInt32;

      native( aWeaItemIdx, WTime, WType, WTemp, TempMin, TempMax, RainProb )
      {
        bc_motocon_weather_info_t* w_obj = NULL;
        w_obj = ew_get_weather_info_obj( aWeaItemIdx );
        WTime = w_obj->time;
        WType = w_obj->type;
        WTemp = (int)w_obj->temperature;
        TempMin = (int)w_obj->temperature_min;
        TempMax = (int)w_obj->temperature_max;
        RainProb = w_obj->rain_probability;
      }
      WeatherTime = WTime;
      WeatherType = WType;
      Temperature = ConvertTemperature( WeaTempType, WTemp );
      MinTemperature = ConvertTemperature( WeaTempType, TempMin );
      MaxTemperature = ConvertTemperature( WeaTempType, TempMax );
      RainProbability = RainProb;
    $else
      if( aWeaItemIdx > 0 )
      {
      // suppress warning
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <110,300,330,340>
  $output true
  method void NotifyWeatherInfoUpdated()
  {
    IsWeatherInfoReceived = true;
  }

  $rect <320,180,520,220>
  method void GetWeatherLoc()
  {
    $if !$prototyper
      var string CurrentLoc;

      native( CurrentLoc )
      {
        char* cur_loc;
        ew_get_weather_loc( &cur_loc );
        CurrentLoc = EwNewStringUtf8( (const unsigned char*) cur_loc, (int)strlen( cur_loc ) );
      }
    WeatherLocation = CurrentLoc;
    $endif
  }

  $rect <100,-10,300,30>
  var int32 WeatherTime;

  $rect <100,30,300,70>
  var int32 Temperature;

  $rect <100,70,300,110>
  var int32 MaxTemperature;

  $rect <310,-10,510,30>
  var int32 WeatherType;

  $rect <310,30,510,70>
  var int32 MinTemperature;

  $rect <310,70,510,110>
  var int32 RainProbability;

  $rect <100,110,300,150>
  var string WeatherLocation;

  $rect <110,240,340,280>
  method void SendWeatherInfoRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_weather_info_req();
      }
    $endif
  }

  $rect <350,240,590,280>
  method void SendVehicleSettingRequest()
  {
    $if !$prototyper
      native
      {
        ew_send_vehicle_setting_req();
      }
    $endif
  }

  $rect <310,110,510,150>
  var int32 WeekDay;

  $rect <540,180,740,220>
  method void GetWeekDay()
  {
    $if !$prototyper
      var int32 NewWeekDay;

      native( NewWeekDay )
      {
        int week_day = ew_get_weather_week_day();
        NewWeekDay = week_day;
      }
    WeekDay = NewWeekDay;
    $endif
  }

  $rect <530,-10,770,30>
  property bool IsWeatherInfoReceived = false;

  $rect <530,30,770,70>
  onset IsWeatherInfoReceived
  {
    // Remember the property's new value.
    pure IsWeatherInfoReceived = value;

    notifyobservers ^IsWeatherInfoReceived;

  }

  $rect <110,360,310,400>
  method int32 ConvertTemperature( arg Enum::TemperatureSettingItem aTempUnit, arg int32 aTemperature )
  {
    var int32 Temp = aTemperature;
    if( Enum::TemperatureSettingItem.TEMP_F == aTempUnit )
    {
      Temp = ( int32 )( ( aTemperature * 9 + 160 ) / 5 );
    }
    return Temp;
  }
}

$rect <260,110,460,150>
autoobject DeviceInterface::WeatherDeviceClass WeatherDevice;

$rect <500,150,700,190>
$output false
class VehicleDataClass
{
  $rect <10,110,210,150>
  var float DataFloat = 0;

  $rect <10,160,210,200>
  var uint32 DataUInt32 = 0;

  $rect <10,10,210,50>
  var bool Valid = false;

  $rect <10,60,210,100>
  var Enum::DataType DataType = Enum::DataType.UINT32;

  $rect <230,10,430,50>
  var Enum::VehicleRxType RxType;
}

$rect <21,380,221,420>
$output false
class NaviDataClass
{
  $rect <80,60,280,100>
  var string CurrentRoad;

  $rect <80,100,280,140>
  var int32 ETA;

  $rect <80,140,280,180>
  var int32 DayNightMode;

  $rect <80,180,280,220>
  var int32 SpeedLimit;

  $rect <280,60,480,100>
  var int32 NaviEventType;

  $rect <280,100,480,140>
  var string NaviEventDist;

  $rect <280,140,480,180>
  var bool NaviEventVisibility;

  $rect <280,180,480,220>
  var string NaviEventSpeed;
}

$rect <751,190,951,230>
$output false
class MotoConContext
{
  $rect <10,10,210,50>
  var Enum::MotoConRxEvent RxEvent;
}

$rect <530,300,740,340>
$output false
class NotificationDeviceClass : Templates::DeviceClass
{
  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <30,220,240,260>
  $output true
  method bool IsPhoneCallStateActive()
  {
    return ( Enum::PhoneCallState.ACTIVE == GetPhoneCallState() );
  }

  // Phone Call
  note group Note1
  {
    attr Bounds = <10,10,970,280>;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,60,280,100>
  $output true
  method void NotifyPhoneCallStateChanged()
  {
    trace "NotifyPhoneCallStateChanged";
    PhoneCallStateChangedSystemEvent.Trigger( null, false );
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,350,230,390>
  $output true
  method void NotifyListUpdated()
  {
    trace "NotifyListUpdated";
    NotificationListUpdatedSystemEvent.Trigger( null, false );
  }

  $rect <30,400,320,440>
  object Core::SystemEvent NotificationListUpdatedSystemEvent;

  $rect <840,350,1050,390>
  method DeviceInterface::NotificationContext GetNotificationAtItem( arg uint32 aItemNo )
  {
    var DeviceInterface::NotificationContext NotificationItem = new DeviceInterface::NotificationContext;
    NotificationItem.ReceivedTime = new DeviceInterface::DateTime;

    $if !$prototyper
      var uint32 Uid;
      var uint16 CallRepetition;
      var uint32 Category;
      var string Title = "";
      var string Message = "";
      var string ReceivedHour = "";
      var string ReceivedMinute = "";

      native( aItemNo, Uid, Title, Message, Category, ReceivedHour, ReceivedMinute )
      {
        uint32_t notification_uid;
        uint16_t call_repetition;
        uint8_t  notification_title[NOTIFICATION_TITLE_MAX_LEN];
        uint8_t  notification_message[NOTIFICATION_MESSAGE_MAX_LEN];
        notification_time_t received_time;
        EnumNotificationCategory notification_category;

        NTF_get_notification_at_idx( aItemNo, &notification_uid, &call_repetition, notification_title, NOTIFICATION_TITLE_MAX_LEN, notification_message, NOTIFICATION_MESSAGE_MAX_LEN, &notification_category, &received_time );

        Uid = notification_uid;
        CallRepetition = call_repetition;

        uint8_t *stuffed_str = NULL;
        int stuffed_str_len = ew_handle_special_characters( notification_title, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Title = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        stuffed_str_len = ew_handle_special_characters( notification_message, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Message = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }

        Category = notification_category;
        ReceivedHour = EwNewStringUInt( received_time.hour, 1, 10 );
        ReceivedMinute = EwNewStringUInt( received_time.minute, 2, 10 );
      }

      NotificationItem.Uid = Uid;
      NotificationItem.CallRepetition = CallRepetition;
      NotificationItem.Title = Title;
      NotificationItem.Message = Message;
      NotificationItem.Category = (Enum::NotificationCategory)Category;
      NotificationItem.ReceivedTime.Hour = ReceivedHour;
      NotificationItem.ReceivedTime.Minute = ReceivedMinute;
    $else
      aItemNo; // suppress warning
    $endif

    return NotificationItem;
  }

  $rect <337,350,547,390>
  property uint32 NotificationNum;

  $rect <337,400,547,440>
  onget NotificationNum
  {
    $if !$prototyper
      var uint32 Num = 0;
      native( Num )
      {
        Num = NTF_get_notification_num();
      }

      pure NotificationNum = Num;
    $endif
    return pure NotificationNum;
  }

  // Notification
  note group Note2
  {
    attr Bounds = <10,300,1070,460>;
  }

  $rect <840,400,1050,440>
  method void DeleteNotificationOfUid( arg uint32 Uid )
  {
    $if !$prototyper
      native( Uid )
      {
        NTF_delete_notification( Uid );
      }
    $endif
  }

  $rect <560,350,820,390>
  method int32 GetBufferIdxOfNotificationUID( arg uint32 Uid )
  {
    var int32 Index = -1;
    $if !$prototyper
      native( Uid, Index )
      {
        Index = NTF_get_idx_of_notification_uid( Uid );
      }
    $endif
    return Index;
  }

  $rect <30,110,330,150>
  object Core::SystemEvent PhoneCallStateChangedSystemEvent;

  $rect <250,170,460,210>
  method string GetIncomingCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t *stuffed_str = NULL;

        NTF_get_incoming_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }

  // Get active call duration in ms
  $rect <680,110,890,150>
  method uint32 GetActiveCallDuration()
  {
    var uint32 DurationMS;

    $if !$prototyper
      native( DurationMS )
      {
        DurationMS = NTF_get_active_call_duration();
      }
    $endif

    return DurationMS;
  }

  $rect <30,170,240,210>
  method Enum::PhoneCallState GetPhoneCallState()
  {
    var Enum::PhoneCallState PhoneCallState = Enum::PhoneCallState.IDLE;

    $if !$prototyper
      native( PhoneCallState )
      {
        int32_t phone_call_state = NTF_get_phonecall_state();
        PhoneCallState = (EnumPhoneCallState)phone_call_state;
      }
    $endif

    return PhoneCallState;
  }

  $rect <740,170,950,210>
  method void AnswerPhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_answer_call();
      }
    $endif
  }

  $rect <740,220,950,260>
  method void DeclinePhoneCall()
  {
    $if !$prototyper
      native
      {
        NTF_decline_call();
      }
    $endif
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <470,170,730,210>
  $output true
  method bool IsPhoneCallVolumeControllable()
  {
    var bool Controllable = false;

    $if !$prototyper
      native( Controllable )
      {
        Controllable = NTF_is_phonecall_volume_controllable();
      }
    $endif

    return Controllable;
  }

  $rect <470,220,730,260>
  method void PhoneCallVolumeControl( arg Enum::VolumeControl aControl )
  {
    $if !$prototyper
      native( aControl )
      {
        NTF_phonecall_volume_control( aControl );
      }
    $endif
  }

  $rect <340,110,650,150>
  object Core::SystemEvent PhoneCallVolumeChangedSystemEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <340,60,590,100>
  $output true
  method void NotifyPhoneCallVolumeChanged()
  {
    trace "NotifyPhoneCallVolumeChanged";
    PhoneCallVolumeChangedSystemEvent.Trigger( null, false );
  }

  $rect <680,60,890,100>
  method uint32 GetPhoneCallVolume()
  {
    var uint32 PhoneCallVolume = 0;

    $if !$prototyper
      native( PhoneCallVolume )
      {
        PhoneCallVolume = BC_motocon_get_phonecall_volume();
      }
    $endif

    return PhoneCallVolume;
  }

  $rect <560,400,820,440>
  method int32 GetNotificationNumOfCategory( arg Enum::NotificationCategory aCategory )
  {
    var int32 Num = 0;
    $if !$prototyper
      native( aCategory, Num )
      {
        Num = NTF_get_notification_num_of_category( aCategory );
      }
    $endif
    return Num;
  }

  $rect <250,220,460,260>
  method string GetActiveCallCaller()
  {
    var string Caller;

    $if !$prototyper
      native( Caller )
      {
        uint8_t* phone_caller;
        uint8_t* stuffed_str = NULL;

        NTF_get_active_call_caller( &phone_caller );
        int stuffed_str_len = ew_handle_special_characters( phone_caller, &stuffed_str );
        if( stuffed_str_len > 0 && stuffed_str != NULL )
        {
          Caller = EwNewStringUtf8( stuffed_str, stuffed_str_len );
        }
      }
    $endif

    return Caller;
  }
}

$rect <530,340,730,380>
autoobject DeviceInterface::NotificationDeviceClass NotificationDevice;

$rect <20,420,220,460>
$output false
class NaviTbtDataClass
{
  $rect <50,40,250,80>
  var int32 IconIdx;

  $rect <50,90,250,130>
  var string DistUnit;

  $rect <50,150,250,190>
  var string TbtDescription;

  $rect <50,210,250,250>
  var int32 ListIdx;

  $rect <50,260,250,300>
  var int32 Distance;
}

$rect <530,380,730,420>
$output false
class DateTime
{
  $rect <70,50,270,90>
  var string Year;

  $rect <70,100,270,140>
  var string Month;

  $rect <70,150,270,190>
  var string Date;

  $rect <70,200,270,240>
  var string Hour;

  $rect <70,250,270,290>
  var string Minute;

  $rect <70,300,270,340>
  var string Second;
}

$rect <530,420,730,460>
$output false
class NotificationContext
{
  $rect <10,10,210,50>
  var uint32 Uid;

  $rect <10,60,210,100>
  var uint16 CallRepetition;

  $rect <10,110,210,150>
  var string Title;

  $rect <10,210,210,250>
  var string Message;

  $rect <10,260,210,300>
  var Enum::NotificationCategory Category;

  $rect <10,310,210,350>
  var DeviceInterface::DateTime ReceivedTime;

  $rect <10,160,210,200>
  var string Subtitle;
}

$rect <20,190,300,230>
$output false
const uint8 INSPECTION_NEGATIVE_RESPONSE = 0xFF;
