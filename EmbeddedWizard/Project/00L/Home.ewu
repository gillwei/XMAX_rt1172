$version 11.00

$rect <430,120,630,160>
$output false
class HOM12_EcoVisualizer : Home::BaseHome
{
  $rect <550,600,730,640>
  inherited method Init()
  {
    trace "HOM12";
    if( DeviceInterface::VehicleDevice.IsTimeoutError2Detected )
    {
      RemoveAllEcoRecord();
    }
    else
    {
      signal OnEcoBarUpdateSlot;
    }
    SetFuelRateUnit();
  }

  $rect <540,660,770,700>
  inherited method OnLongEnterKeyActivated()
  {
    if( Components::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      PresentDialog( new Info::INF01_MeterDisplaySettingMenu, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <550,130,730,170>
  inherited var HomeType = Enum::HomeType.ECO_VISUALIZER;

  $rect <20,20,160,60>
  object Views::Image EcoMeterBase
  {
    preset Bounds = <61,44,417,200>;
    preset Bitmap = Resource::EcoBase;
  }

  $rect <20,20,160,60>
  object Home::EcoMeterChart EcoMeterChart
  {
    preset Layout = Core::Layout[AlignToRight];
    preset Bounds = <61,44,435,200>;
    preset Enabled = false;
    preset MaxValue = 2.0;
    preset DotFrame = Resource::EcoDot;
    preset BarSize = 6;
    preset Records = null;
    preset StartAnimation = ShiftLeftStarts;
    preset EndAnimation = ShiftLeftEnds;
  }

  $rect <20,20,160,60>
  object Views::Rectangle RightBlackArea
  {
    preset Bounds = <417,44,435,184>;
    preset Color = #070707FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle LeftBlackArea
  {
    preset Bounds = <43,44,61,184>;
    preset Color = #070707FF;
  }

  $rect <20,20,160,60>
  object Views::Image GradientCover
  {
    preset Bounds = <55,61,412,189>;
    preset Bitmap = Resource::GradientCover;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Text AvgFuel
  {
    preset Bounds = <85,212,194,242>;
    preset String = "AVG FUEL";
    preset Font = Fonts::NotoSansMedium22pt;
  }

  $rect <20,20,160,60>
  object Views::Text Average
  {
    preset Bounds = <205,196,328,253>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansMedium42pt;
  }

  $rect <20,20,160,60>
  object Views::Image Unit
  {
    preset Bounds = <333,205,393,247>;
    preset Bitmap = Resource::IconUnitKM_L;
  }

  $rect <20,20,160,60>
  object Views::Image EcoWindowLine
  {
    preset Bounds = <52,244,428,259>;
    preset Bitmap = Resource::EcoWindowLine;
  }

  $rect <20,20,160,60>
  object Views::Image AvgLine
  {
    preset Bounds = <0,102,480,129>;
    preset Bitmap = Resource::AvgLine;
  }

  $rect <760,80,960,120>
  property float CurrentRelativeValue;

  $rect <760,120,960,160>
  onset CurrentRelativeValue
  {
    // Remember the property's new value.
    pure CurrentRelativeValue = value;

    if( EcoRecordList.NoOfItems >= EcoRecordList.MaxValue )
    {
      EcoRecordList.RemoveRecord();
    }

    EcoRecordList.AddRecord( CurrentRelativeValue );

    if( EcoRecordList.NoOfItems == 1 )
    {
      EcoMeterChart.Record = EcoRecordList.firstRecord;
      Index++;
    }
    else
    {
      if( Index == EcoRecordList.MaxValue )
      {
        //Remove EcoMeterComponent view from view list.
        EcoMeterChart.RemoveEcoUnit( Index - EcoRecordList.MaxValue );
        Index--;
      }
      EcoMeterChart.Record = EcoRecordList.GetRecord( Index );
      Index++;
    }

    EcoMeterChart.Records = EcoRecordList;
  }

  $rect <990,640,1190,680>
  object Effects::RectEffect ShiftLeftEffect
  {
    preset OnFinished = ShiftLeftEnds;
    preset OnAnimate = OnMoveLeft;
    preset Bounces = 1;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Enabled = false;
    preset Value2 = <50,45,419,184>;
    preset Value1 = <56,45,425,184>;
  }

  $rect <990,680,1190,720>
  slot OnMoveLeft
  {
    EcoMeterChart.Bounds = ShiftLeftEffect.Value;

  }

  $rect <990,600,1190,640>
  slot ShiftLeftStarts
  {
    signal EcoMeterChart.OnAnimate;
    ShiftLeftEffect.Enabled = true;
  }

  $rect <990,720,1190,760>
  slot ShiftLeftEnds
  {
    ShiftLeftEffect.Enabled = false;
  }

  $rect <140,380,330,420>
  object Core::Timer Timer
  {
    preset OnTrigger = OnUpdateSlot;
    preset Period = 1000;
    preset Enabled = false;
  }

  $rect <140,420,340,460>
  slot OnUpdateSlot
  {
    if( ValueArrayIdx > 20 )
    {
      ValueArrayIdx = 0;
    }

    // hide the 6th ~ 8th bar.
    if( ValueArrayIdx > 5 && ValueArrayIdx < 9 )
    {
      CurrentRelativeValue = -1;
      EcoMeterChart.HideEcoUnit( ValueArrayIdx );
    }
    else
    {
      CurrentRelativeValue = ValueArray[ValueArrayIdx];
    }
    ValueArrayIdx++;

  }

  $rect <980,80,1180,120>
  var int32 Index = 0;

  $rect <550,410,750,450>
  object Core::SystemEventHandler VehicleDataReceivedEventHandler
  {
    preset OnEvent = OnVehicleDataReceivedSlot;
    preset Event = DeviceInterface::VehicleDevice.VehicleDataReceivedSystemEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <750,410,950,450>
  slot OnVehicleDataReceivedSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = ( DeviceInterface::VehicleDataClass )VehicleDataReceivedEventHandler.Context;
    if( null != VehicleData )
    {
      switch( VehicleData.RxType )
      {
        case Enum::VehicleRxType.TIMEOUT_ERROR2_UPDATED:
        {
          if( DeviceInterface::VehicleDevice.IsTimeoutError2Detected )
          {
            EcoBarUpdateTimer.Enabled = false;
            RemoveAllEcoRecord();
            Average.String = Strings::GEN_THREE_HYPHENS;
          }
          else
          {
            EcoBarUpdateTimer.Enabled = true;
          }
        }
        case Enum::VehicleRxType.FUEL_CONSUMPTION_UNIT:
        {
          SetFuelRateUnit();
          RemoveAllEcoRecord();
        }
        default:;
      }
    }
  }

  // Variable
  note group Note1
  {
    attr Bounds = <520,40,1210,310>;
  }

  // System event
  note group Note2
  {
    attr Bounds = <520,360,1210,520>;
  }

  // Method
  note group Note
  {
    attr Bounds = <520,540,1210,810>;
  }

  // Test
  note group Note3
  {
    attr Bounds = <80,310,410,590>;
  }

  $rect <550,720,750,760>
  method void RemoveAllEcoRecord()
  {
    if( EcoRecordList.NoOfItems > 0 )
    {
      while( EcoRecordList.NoOfItems > 0 )
      {
        EcoMeterChart.RemoveEcoUnit( Index - 1 );
        EcoRecordList.RemoveRecord();
        Index--;
      }
      EcoRecordList.ClearList();
    }
  }

  $rect <550,80,750,120>
  object Home::RecordList EcoRecordList;

  $rect <140,470,340,510>
  array float ValueArray[ 21 ] =
  (
    Default[0] = 0.0;
    Default[1] = 0.1;
    Default[2] = 0.2;
    Default[3] = 0.3;
    Default[4] = 0.4;
    Default[5] = 0.5;
    Default[6] = 0.6;
    Default[7] = 0.7;
    Default[8] = 0.8;
    Default[9] = 0.9;
    Default[10] = 1.0;
    Default[11] = 1.1;
    Default[12] = 1.2;
    Default[13] = 1.3;
    Default[14] = 1.4;
    Default[15] = 1.5;
    Default[16] = 1.6;
    Default[17] = 1.7;
    Default[18] = 1.8;
    Default[19] = 1.9;
    Default[20] = 2.0;
  );

  $rect <140,510,340,550>
  var int32 ValueArrayIdx = 0;

  $rect <550,190,750,230>
  property float FuelRateInst;

  $rect <550,230,750,270>
  onset FuelRateInst
  {
    // Remember the property's new value.
    pure FuelRateInst = value;
  }

  $rect <770,190,970,230>
  property float FuelRateAvg;

  $rect <770,230,970,270>
  onset FuelRateAvg
  {
    // Remember the property's new value.
    pure FuelRateAvg = value;

    if( FuelRateAvg == 0.0 )
    {
      RemoveAllEcoRecord();
      AvgLine.Visible = false;
      Average.String = Strings::GEN_THREE_HYPHENS;
    }
    else
    {
      AvgLine.Visible = true;
      CurrentRelativeValue = FuelRateInst/FuelRateAvg;
      Average.String = string( FuelRateAvg, 0, 1 );
    }
  }

  $rect <770,600,960,640>
  object Core::Timer EcoBarUpdateTimer
  {
    preset OnTrigger = OnEcoBarUpdateSlot;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <770,650,970,690>
  slot OnEcoBarUpdateSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.ENGINE_SPEED );
    if( VehicleData.DataUInt32 < 50 )
    {
      CurrentRelativeValue = -1; // make sure the head of eco bar is not drawn.
      EcoMeterChart.HideEcoUnit( Index ); // hide the eco bar.
    }
    else
    {
      if( DeviceInterface::VehicleDevice.EngineIdling )
      {
        switch( DeviceInterface::VehicleDevice.FuelConsumptionUnit )
        {
          case Enum::MeterFuelConsumptionUnit.KM_PER_LITER: CurrentRelativeValue = 0.0; // show the head of eco bar only(minimum relative value).
          case Enum::MeterFuelConsumptionUnit.L_PER_100KM: CurrentRelativeValue = 2.0; // show full eco bar(maximum relative value).
          default:;
        }
      }
      else
      {
        VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_INSTANT_UNIT_CONVERTED );
        FuelRateInst = VehicleData.DataFloat;

        VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.FUEL_RATE_AVERAGE_UNIT_CONVERTED );
        if( VehicleData.Valid )
        {
          FuelRateAvg = VehicleData.DataFloat;
        }
        else
        {
          AvgLine.Visible = false;
          RemoveAllEcoRecord();
          Average.String = Strings::GEN_THREE_HYPHENS;
        }
      }
    }
  }

  $rect <760,720,960,760>
  method void SetFuelRateUnit()
  {
    switch( DeviceInterface::VehicleDevice.FuelConsumptionUnit )
    {
      case Enum::MeterFuelConsumptionUnit.KM_PER_LITER: Unit.Bitmap = Resource::IconUnitKM_L;
      case Enum::MeterFuelConsumptionUnit.L_PER_100KM: Unit.Bitmap = Resource::IconUnitL_100KM;
      case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL,
           Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL: Unit.Bitmap = Resource::IconUnitMPG;
      default:;
    }
  }
}

$rect <710,120,910,160>
$output false
class HOM13_SpeedVisualizer : Home::BaseHome
{
  $rect <560,480,740,520>
  inherited method Init()
  {
    trace "Init HOM13";

    $if !$prototyper
      var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.MILEAGE_UNIT );
      if( null != VehicleData )
      {
        SpeedUnit = (Enum::MileageSettingItem)VehicleData.DataUInt32;
      }

      signal OnSpeedLimitUpdateSlot;
    $else
      SpeedUnit = Enum::MileageSettingItem.KM;
      SpeedLimit = 100;
    $endif
  }

  $rect <880,480,1110,520>
  inherited method OnLongEnterKeyActivated()
  {
    if( Components::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      PresentDialog( new Info::INF01_MeterDisplaySettingMenu, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <540,160,720,200>
  inherited var HomeType = Enum::HomeType.SPEED_VISUALIZER;

  $rect <20,20,160,60>
  object Home::SpeedCircle SpeedCircle
  {
    preset Bounds = <0,38,480,272>;
  }

  $rect <20,20,160,60>
  object Views::Image SpeedVisualizerTitle
  {
    preset Bounds = <93,91,387,225>;
    preset Bitmap = Resource::SVSpeedUnLimit;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Image SpeedLimitUnit
  {
    preset Bounds = <211,191,271,211>;
    preset Bitmap = Resource::SVKmH;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text SpeedLimitText
  {
    preset Bounds = <183,136,297,193>;
    preset String = "";
    preset Font = Fonts::NotoSansMedium42pt;
  }

  $rect <20,20,160,60>
  object Views::Image SpeedLimitTitle
  {
    preset Bounds = <142,105,338,148>;
    preset Bitmap = Resource::SVSpeedLimit;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper StatusShadow
  {
    preset Bounds = <0,38,480,52>;
    preset Bitmap = Resource::StatusShadow;
  }

  $rect <550,290,830,330>
  object Core::SystemEventHandler VehicleDataReceivedEventHandler
  {
    preset OnEvent = OnVehicleDataReceivedSlot;
    preset Event = DeviceInterface::VehicleDevice.VehicleDataReceivedSystemEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <550,330,830,370>
  slot OnVehicleDataReceivedSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = ( DeviceInterface::VehicleDataClass )VehicleDataReceivedEventHandler.Context;
    if( null != VehicleData )
    {
      switch( VehicleData.RxType )
      {
        case Enum::VehicleRxType.TIMEOUT_ERROR2_UPDATED:
        {
          if( DeviceInterface::VehicleDevice.IsTimeoutError2Detected )
          {
            SpeedLimitText.String = "- -";
            SpeedLimitText.Color = Color::GRAY_FOR_DISABLED;
          }
          else
          {
            SpeedLimitText.Color = Color::WHITE;
            signal OnSpeedLimitUpdateSlot;
          }
        }
        case Enum::VehicleRxType.MILEAGE_UNIT:
        {
          VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.MILEAGE_UNIT );
          SpeedUnit = (Enum::MileageSettingItem)VehicleData.DataUInt32;
          signal OnSpeedLimitUpdateSlot;
        }
        default:;
      }
    }
  }

  $rect <910,290,1120,330>
  object Core::SystemEventHandler SpeedLimitUpdateEventHandler
  {
    preset OnEvent = OnSpeedLimitUpdateSlot;
    preset Event = DeviceInterface::NavigationDevice.SpeedLimitUpdateEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <910,330,1140,370>
  slot OnSpeedLimitUpdateSlot
  {
    var DeviceInterface::NaviDataClass NaviData = DeviceInterface::NavigationDevice.GetNaviData( Enum::NaviDataType.SPEED_LIMIT );

    if( null != NaviData )
    {
      SpeedLimit = NaviData.SpeedLimit;
      signal OnSpeedUpdateSlot;
    }
  }

  $rect <760,70,960,110>
  property Enum::MileageSettingItem SpeedUnit;

  $rect <760,110,960,150>
  onset SpeedUnit
  {
    if( pure SpeedUnit != value )
    {
      // Remember the property's new value.
      pure SpeedUnit = value;

      switch( SpeedUnit )
      {
        case Enum::MileageSettingItem.KM: SpeedLimitUnit.Bitmap = Resource::SVKmH;
        case Enum::MileageSettingItem.MILE: SpeedLimitUnit.Bitmap = Resource::SVMPH;
        default:;
      }
    }
  }

  $rect <760,150,960,190>
  onget SpeedUnit
  {
    return pure SpeedUnit;
  }

  $rect <540,70,740,110>
  property int32 SpeedLimit;

  $rect <540,110,740,150>
  onset SpeedLimit
  {
    if( pure SpeedLimit != value )
    {
      // Remember the property's new value.
      pure SpeedLimit = value;

      SpeedCircle.SpeedLimit = value;
      SpeedLimitText.String = string( value );

      // If speed limit is zero, that means there is no speed limit. In this case, white circle shouldn't be displayed.
      if( value > 0 )
      {
        SpeedCircle.Color = Home::SV_WITH_SPEED_LIMIT;
        SpeedCircle.GradientLine.Visible = true;
        SpeedVisualizerTitle.Visible = false;
        SpeedLimitTitle.Visible = true;
        SpeedLimitUnit.Visible = true;
        SpeedLimitText.Visible = true;
      }
      else
      {
        SpeedCircle.Color  = Home::SV_WITHOUT_SPEED_LIMIT;
        SpeedCircle.GradientLine.Visible = false;
        SpeedVisualizerTitle.Visible = true;
        SpeedLimitTitle.Visible = false;
        SpeedLimitUnit.Visible = false;
        SpeedLimitText.Visible = false;
      }
    }
  }

  $rect <130,450,330,490>
  object Core::Timer Timer
  {
    preset OnTrigger = OnTimerSlot;
    preset Period = 100;
    preset Enabled = false;
  }

  $rect <130,490,330,530>
  slot OnTimerSlot
  {
    if( Ascending )
    {
      SpeedCircle.SpeedValue += 10;
      if( SpeedCircle.SpeedValue == 70 )
      {
        SpeedLimit = 50;
      }
      if( SpeedCircle.SpeedValue >= 140 )
      {
        Ascending = false;
      }
    }
    else
    {
      SpeedCircle.SpeedValue -= 10;
      if( SpeedCircle.SpeedValue == 70 )
      {
        SpeedLimit = 40;
      }
      if( SpeedCircle.SpeedValue == 0 )
      {
        Ascending = true;
      }
    }

  }

  $rect <130,530,330,570>
  var bool Ascending = true;

  // Test
  note group Note3
  {
    attr Bounds = <110,390,360,580>;
  }

  // Variable
  note group Note1
  {
    attr Bounds = <520,30,1210,220>;
  }

  // System event
  note group Note2
  {
    attr Bounds = <520,240,1210,400>;
  }

  // Method
  note group Note
  {
    attr Bounds = <520,430,1210,630>;
  }

  $rect <560,530,750,570>
  object Core::Timer SpeedUpdateTimer
  {
    preset OnTrigger = OnSpeedUpdateSlot;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <560,580,760,620>
  slot OnSpeedUpdateSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.VEHICLE_SPEED_METER );
    if( null != VehicleData )
    {
      SpeedCircle.SpeedValue = (int32)VehicleData.DataUInt32;
    }
  }
}

$rect <10,10,210,50>
$output false
class BaseHome : Components::BaseMainBG
{
  $rect <220,340,450,380>
  inherited method OnShortEnterKeyActivated()
  {
    // When loading animation is displayed, enter key operation should not be executed.
    if( !NaviConnectFailedTimer.Enabled )
    {
      GetRoot().PresentDialog( new Launcher::LNC_Main, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <220,290,450,330>
  inherited method OnShortHomeKeyActivated()
  {
    // When loading animation is displayed, home key operation should not be executed.
    if( !NaviConnectFailedTimer.Enabled )
    {
      var Enum::HomeType NextHomeType = GetNextHomeType( HomeType );
      var Application::Application App = ( Application::Application )GetRoot();
      if( null != App )
      {
        if( Enum::HomeType.NAVI_DEFAULT_VIEW == HomeType )
        {
          // Leave navigation home screen so that stop map frame request.
          DeviceInterface::NavigationDevice.StopMapFrameRequest();
        }

        switch( NextHomeType )
        {
          case Enum::HomeType.TACHO_VISUALIZER,
               Enum::HomeType.SPEED_VISUALIZER,
               Enum::HomeType.ECO_VISUALIZER:
          {
            App.SlideInHome( NextHomeType );
          }
          case Enum::HomeType.NAVI_DEFAULT_VIEW,
               Enum::HomeType.NAVI_NEXT_TURN,
               Enum::HomeType.NAVI_TURN_BY_TURN:
          {
            App.SwitchToHome( NextHomeType );
          }
          case Enum::HomeType.VEHICLE_INFO:
          {
            App.SlideInHome( NextHomeType );
          }
          default:;
        }
      }
    }
  }

  $rect <0,290,200,330>
  method void ReturnToHome()
  {
    var Menu::BaseMenuView MenuDialog = ( Menu::BaseMenuView )GetDialogAtIndex( 0 );
    if( null != MenuDialog )
    {
      DismissDialog( MenuDialog, null, null, null, null, null, false );
    }
  }

  $rect <470,290,670,330>
  var Enum::HomeType HomeType;

  $rect <0,340,200,380>
  method Enum::HomeType GetNextHomeType( arg Enum::HomeType aCurrentHomeType )
  {
    var Enum::HomeType NextHomeType = Enum::HomeType.TOTAL;
    switch( aCurrentHomeType )
    {
      case Enum::HomeType.TACHO_VISUALIZER, Enum::HomeType.ECO_VISUALIZER, Enum::HomeType.SPEED_VISUALIZER:
      {
        if( !DeviceInterface::NavigationDevice.NaviAppSppConnected )
        {
          NextHomeType = Enum::HomeType.VEHICLE_INFO;
        }
        else if( !DeviceInterface::NavigationDevice.GetNaviConnectStatus() )
        {
          NextHomeType = Enum::HomeType.VEHICLE_INFO;
        }
        else
        {
          NextHomeType = DeviceInterface::NavigationDevice.CurrentHome;
        }
      }
      case Enum::HomeType.NAVI_DEFAULT_VIEW, Enum::HomeType.NAVI_NEXT_TURN, Enum::HomeType.NAVI_TURN_BY_TURN:
      {
        NextHomeType = Enum::HomeType.VEHICLE_INFO;
      }
      case Enum::HomeType.VEHICLE_INFO:
      {
        switch( DeviceInterface::VehicleDevice.CurrentMeterDisplay )
        {
          case Enum::MeterDisplay.TACHOMETER: NextHomeType = Enum::HomeType.TACHO_VISUALIZER;
          case Enum::MeterDisplay.ECHO_METER: NextHomeType = Enum::HomeType.ECO_VISUALIZER;
          case Enum::MeterDisplay.SPEED_METER: NextHomeType = Enum::HomeType.SPEED_VISUALIZER;
          default:;
        }
      }
      default:;
    }
    return NextHomeType;
  }

  $rect <474,354,674,394>
  property bool AccessNaviView;

  $rect <474,394,674,434>
  onset AccessNaviView
  {
    if( pure AccessNaviView != value )
    {
      pure AccessNaviView = value;

      NaviConnectFailedTimer.Enabled = value;
      LoadingAnimation.Animated = value;
      LoadingAnimation.Visible = value;
    }
  }

  $rect <430,470,630,510>
  object Core::Timer NaviConnectFailedTimer
  {
    preset OnTrigger = OnNaviConnectFailedSlot;
    preset Period = 5000;
  }

  $rect <430,510,630,550>
  slot OnNaviConnectFailedSlot
  {
    AccessNaviView = false;
    PresentDialog( new Pop::POP02_ConnectionError, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Pop::POP16_NaviLoadingUI LoadingAnimation
  {
    preset Bounds = <0,38,480,272>;
    preset Visible = false;
  }
}

$rect <980,120,1180,160>
$output false
class HOM03_VehicleInfo : Home::BaseHome
{
  $rect <10,290,190,330>
  inherited method Init()
  {
    trace "Init HOM03";
  }

  $rect <230,340,460,380>
  inherited method OnShortDownKeyActivated()
  {
    VehicleInfoMenu.ScrollUp();
  }

  $rect <230,290,460,330>
  inherited method OnShortUpKeyActivated()
  {
    VehicleInfoMenu.ScrollDown();
  }

  $rect <230,390,460,430>
  inherited method OnLongEnterKeyActivated()
  {
    if( Components::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      PresentDialog( new Settings::SET46_VehicleInfoReset, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <10,340,190,380>
  inherited var HomeType = Enum::HomeType.VEHICLE_INFO;

  $rect <20,20,160,60>
  object Views::Image IconInfo
  {
    preset Bounds = <17,51,67,101>;
    preset Bitmap = Resource::IconInfo;
  }

  $rect <20,20,160,60>
  object Home::VehicleInfoMenu VehicleInfoMenu
  {
    preset Bounds = <78,40,480,268>;
  }
}

$rect <980,170,1180,210>
$output false
class VehicleInfoMenu : Core::Group
{
  $rect <0,290,180,330>
  inherited method Init()
  {
    InitItems();
    SetDividers();
    SetArrowIcons();

    if( VerticalList.NoOfItems < 3 )
    {
      VerticalList.Bounds.h = VerticalList.ItemHeight * VerticalList.NoOfItems;
    }
    else
    {
      VerticalList.Bounds.h = Bounds.h;
    }
  }

  $rect <0,240,180,280>
  inherited property Bounds = <0,0,402,228>;

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,402,228>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = true;
    preset ItemHeight = 76;
    preset ItemClass = Home::ItemVehicleInfo;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <210,240,410,280>
  slot OnLoadItem
  {
    var int32 ItemNo = VerticalList.Item;

    var Home::ItemVehicleInfo MenuItem = (Home::ItemVehicleInfo)VerticalList.View;
    if( null != MenuItem )
    {
      MenuItem.Title.String = LoadItemTitle( ItemNo );
      MenuItem.IconUnit.Bitmap = LoadItemUnitIconBmp( ItemNo );

      if( Enum::VehicleInfoMenuItem.TRIP_TIME == Items[ItemNo] )
      {
        MenuItem.HourText.String = LoadItemHour( ItemNo );
        MenuItem.HourText.Visible = true;

        MenuItem.MinuteText.String = LoadItemMinute( ItemNo );
        MenuItem.MinuteText.Visible = true;

        MenuItem.HourIcon.Visible = true;
        MenuItem.ValueText.Visible = false;
      }
      else
      {
        MenuItem.ValueText.String = LoadItemValue( ItemNo );
        MenuItem.ValueText.Visible = true;
        MenuItem.ValueTextBlink = LoadItemValueBlink( ItemNo );

        MenuItem.HourText.Visible = false;
        MenuItem.MinuteText.Visible = false;
        MenuItem.HourIcon.Visible = false;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image Divider1
  {
    preset Bounds = <0,70,359,77>;
    preset Bitmap = Resource::InfoDivider;
  }

  $rect <20,20,160,60>
  object Views::Image Divider2
  {
    preset Bounds = <0,146,359,153>;
    preset Bitmap = Resource::InfoDivider;
  }

  $rect <0,340,180,380>
  method void InitItems()
  {
    var int32 i;
    var int32 NoOfItems;
    var Enum::VehicleInfoMenuItem MenuItem;

    for( i = 0; i < (int32)Enum::VehicleInfoMenuItem.TOTAL; i++ )
    {
      MenuItem = (Enum::VehicleInfoMenuItem)i;
      switch( MenuItem )
      {
        case Enum::VehicleInfoMenuItem.AVG_SPEED:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.AVG_SPEED ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.AVG_FUEL:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.AVG_FUEL ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.INST_FUEL:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.CURRENT_FUEL ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.RANGE:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.RANGE_DISTANCE ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.FUEL_CONSUMPTION ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.AIR_TEMPERATURE:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.AIR_TEMPERATURE ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.COOLANT ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.BATTERY:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.BATTERY_VOLTAGE ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.TIRE_FRONT:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.TIRE_FRONT ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.TIRE_REAR:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.TIRE_REAR ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.TIRE_FRONT_RIGHT ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.TIRE_FRONT_LEFT ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        case Enum::VehicleInfoMenuItem.CRUISE:
        {
          if( DeviceInterface::VehicleDevice.IsVehicleFunctionSupported( Enum::VehicleSupportedFunction.CRUISE ) )
          {
            Items[NoOfItems] = MenuItem;
            NoOfItems++;
          }
        }
        default:
        {
          Items[NoOfItems] = MenuItem;
          NoOfItems++;
        }
      }
    }

    VerticalList.NoOfItems = NoOfItems;
  }

  $rect <660,240,860,280>
  array Enum::VehicleInfoMenuItem Items[ 14 ];

  $rect <210,290,410,330>
  method string LoadItemTitle( arg int32 aItemNo )
  {
    var string Title;
    switch( Items[aItemNo] )
    {
      case Enum::VehicleInfoMenuItem.AVG_SPEED: Title = Strings::HOM03_AVG_SPEED;
      case Enum::VehicleInfoMenuItem.AVG_FUEL: Title = Strings::HOM03_AVG_FUEL;
      case Enum::VehicleInfoMenuItem.INST_FUEL: Title = Strings::HOM03_INST_FUEL;
      case Enum::VehicleInfoMenuItem.TRIP_TIME: Title = Strings::HOM03_TRIP_TIME;
      case Enum::VehicleInfoMenuItem.RANGE: Title = Strings::HOM03_RANGE;
      case Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION: Title = Strings::HOM03_FUEL_CONSUMPTION;
      case Enum::VehicleInfoMenuItem.AIR_TEMPERATURE: Title = Strings::HOM03_AIR;
      case Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE: Title = Strings::HOM03_COOLANT;
      case Enum::VehicleInfoMenuItem.BATTERY: Title = Strings::HOM03_BATTERY;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT: Title = Strings::HOM03_FRONT_R;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT: Title = Strings::HOM03_FRONT_L;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT: Title = Strings::HOM03_FRONT;
      case Enum::VehicleInfoMenuItem.TIRE_REAR: Title = Strings::HOM03_REAR;
      case Enum::VehicleInfoMenuItem.CRUISE: Title = Strings::HOM03_CRUISE;
      default:;
    }
    return Title;
  }

  $rect <0,390,180,430>
  method void SetDividers()
  {
    if( 1 <= VerticalList.NoOfItems )
    {
      Divider1.Visible = true;
    }
    else
    {
      Divider1.Visible = false;
    }

    if( 2 <= VerticalList.NoOfItems )
    {
      Divider2.Visible = true;
    }
    else
    {
      Divider2.Visible = false;
    }
  }

  $rect <210,390,410,430>
  method Resources::Bitmap LoadItemUnitIconBmp( arg int32 aItemNo )
  {
    var Resources::Bitmap IconBitmap;
    switch( Items[aItemNo] )
    {
      case Enum::VehicleInfoMenuItem.AVG_SPEED,
           Enum::VehicleInfoMenuItem.RANGE,
           Enum::VehicleInfoMenuItem.CRUISE:
      {
        if( Enum::MileageSettingItem.KM == DeviceInterface::VehicleDevice.MileageUnit )
        {
          IconBitmap = Resource::IconUnitKM;
        }
        else
        {
          IconBitmap = Resource::IconUnitMile;
        }
      }
      case Enum::VehicleInfoMenuItem.AVG_FUEL,
           Enum::VehicleInfoMenuItem.INST_FUEL:
      {
        switch( DeviceInterface::VehicleDevice.FuelConsumptionUnit )
        {
          case Enum::MeterFuelConsumptionUnit.KM_PER_LITER: IconBitmap = Resource::IconUnitKM_L;
          case Enum::MeterFuelConsumptionUnit.L_PER_100KM: IconBitmap = Resource::IconUnitL_100KM;
          case Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL,
               Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL: IconBitmap = Resource::IconUnitMPG;
          default:;
        }
      }
      case Enum::VehicleInfoMenuItem.TRIP_TIME: IconBitmap = Resource::IconUnitMinute;
      case Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION:
      {
        switch( DeviceInterface::VehicleDevice.FuelConsumptionUnit )
        {
          case Enum::MeterFuelConsumptionUnit.KM_PER_LITER,
               Enum::MeterFuelConsumptionUnit.L_PER_100KM: IconBitmap = Resource::IconUnitL;
          case Enum::MeterFuelConsumptionUnit.MILE_PER_US_GAL,
               Enum::MeterFuelConsumptionUnit.MILE_PER_IMPERIAL_GAL: IconBitmap = Resource::IconUnitGal;
          default:;
        }
      }

      case Enum::VehicleInfoMenuItem.AIR_TEMPERATURE,
           Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE:
      {
        if( Enum::TemperatureSettingItem.TEMP_C == DeviceInterface::VehicleDevice.TemperatureUnit )
        {
          IconBitmap = Resource::IconUnitDegC;
        }
        else
        {
          IconBitmap = Resource::IconUnitDegF;
        }
      }

      case Enum::VehicleInfoMenuItem.BATTERY: IconBitmap = Resource::IconUnitVolt;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT,
           Enum::VehicleInfoMenuItem.TIRE_REAR,
           Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT,
           Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT:
      {
        switch( DeviceInterface::VehicleDevice.PressureUnit )
        {
          case Enum::PressureSettingItem.KGF_PER_CM2: IconBitmap = Resource::IconUnitKGF_CM2;
          case Enum::PressureSettingItem.KPA: IconBitmap = Resource::IconUnitKPA;
          case Enum::PressureSettingItem.PSI: IconBitmap = Resource::IconUnitPSI;
          default:;
        }
      }
      default:;
    }
    return IconBitmap;
  }

  $rect <210,340,410,380>
  method string LoadItemValue( arg int32 aItemNo )
  {
    var string ValueStr;
    switch( Items[aItemNo] )
    {
      case Enum::VehicleInfoMenuItem.AVG_SPEED: ValueStr = DeviceInterface::VehicleDevice.AvgSpeedStr;
      case Enum::VehicleInfoMenuItem.AVG_FUEL: ValueStr = DeviceInterface::VehicleDevice.AvgFuelRateStr;
      case Enum::VehicleInfoMenuItem.INST_FUEL: ValueStr = DeviceInterface::VehicleDevice.InstantFuelRateStr;
      case Enum::VehicleInfoMenuItem.RANGE: ValueStr = DeviceInterface::VehicleDevice.RangeStr;
      case Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION: ValueStr = DeviceInterface::VehicleDevice.FuelConStr;
      case Enum::VehicleInfoMenuItem.AIR_TEMPERATURE: ValueStr = DeviceInterface::VehicleDevice.AirTemperatureStr;
      case Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE: ValueStr = DeviceInterface::VehicleDevice.CoolantTemperatureStr;
      case Enum::VehicleInfoMenuItem.BATTERY: ValueStr = DeviceInterface::VehicleDevice.BatteryStr;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT: ValueStr = DeviceInterface::VehicleDevice.TireFrontPressureStr;
      case Enum::VehicleInfoMenuItem.TIRE_REAR: ValueStr = DeviceInterface::VehicleDevice.TireRearPressureStr;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT: ValueStr = Strings::GEN_THREE_HYPHENS;
      case Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT: ValueStr = Strings::GEN_THREE_HYPHENS;
      case Enum::VehicleInfoMenuItem.CRUISE: ValueStr = DeviceInterface::VehicleDevice.CruiseSpeedStr;
      default:;
    }
    return ValueStr;
  }

  $rect <660,290,860,330>
  method void ScrollUp()
  {
    if( !RowScrollEffect.Enabled &&
        1 < VerticalList.NoOfItems )
    {
      RowScrollEffect.Value1 = VerticalList.ScrollOffset;
      RowScrollEffect.Value2 = VerticalList.ScrollOffset - 76;
      RowScrollEffect.Enabled = true;
    }
  }

  $rect <660,340,860,380>
  method void ScrollDown()
  {
    if( !RowScrollEffect.Enabled &&
        1 < VerticalList.NoOfItems )
    {
      RowScrollEffect.Value1 = VerticalList.ScrollOffset;
      RowScrollEffect.Value2 = VerticalList.ScrollOffset + 76;
      RowScrollEffect.Enabled = true;
    }
  }

  $rect <0,440,180,480>
  method void SetArrowIcons()
  {
    if( 1 < VerticalList.NoOfItems )
    {
      UpArrowIcon.Visible = true;
      DownArrowIcon.Visible = true;
    }
    else
    {
      UpArrowIcon.Visible = false;
      DownArrowIcon.Visible = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image UpArrowIcon
  {
    preset Bounds = <363,1,395,33>;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <20,20,160,60>
  object Views::Image DownArrowIcon
  {
    preset Bounds = <363,185,395,217>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <430,340,630,380>
  method string LoadItemHour( arg int32 aItemNo )
  {
    var string HourString;
    if( Enum::VehicleInfoMenuItem.TRIP_TIME == Items[aItemNo] )
    {
      HourString = DeviceInterface::VehicleDevice.TripTimeHourStr;
    }
    return HourString;
  }

  $rect <430,390,630,430>
  method string LoadItemMinute( arg int32 aItemNo )
  {
    var string MinuteString;
    if( Enum::VehicleInfoMenuItem.TRIP_TIME == Items[aItemNo] )
    {
      MinuteString = DeviceInterface::VehicleDevice.TripTimeMinuteStr;
    }
    return MinuteString;
  }

  $rect <660,390,910,430>
  object Effects::Int32Effect RowScrollEffect
  {
    preset Exponent = 4.19;
    preset Timing = Effects::Timing.Exp_Out;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset InitialDelay = 50;
    preset Outlet = ^VerticalList.ScrollOffset;
  }

  $rect <940,240,1220,280>
  object Core::SystemEventHandler VehicleDataReceivedEventHandler
  {
    preset OnEvent = OnVehicleDataReceivedSlot;
    preset Event = DeviceInterface::VehicleDevice.VehicleDataReceivedSystemEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <940,290,1180,330>
  slot OnVehicleDataReceivedSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = ( DeviceInterface::VehicleDataClass )VehicleDataReceivedEventHandler.Context;
    if( null != VehicleData )
    {
      switch( VehicleData.RxType )
      {
        /* unit changed (not expect to happen) */
        case Enum::VehicleRxType.TEMPERATURE_UNIT:
        {
          ReloadItem( Enum::VehicleInfoMenuItem.AIR_TEMPERATURE );
          ReloadItem( Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE );
        }
        case Enum::VehicleRxType.FUEL_CONSUMPTION_UNIT:
        {
          ReloadItem( Enum::VehicleInfoMenuItem.AVG_FUEL );
          ReloadItem( Enum::VehicleInfoMenuItem.INST_FUEL );
          ReloadItem( Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION );
        }
        case Enum::VehicleRxType.MILEAGE_UNIT:
        {
          ReloadItem( Enum::VehicleInfoMenuItem.AVG_SPEED );
          ReloadItem( Enum::VehicleInfoMenuItem.RANGE );
          ReloadItem( Enum::VehicleInfoMenuItem.CRUISE );
        }
        case Enum::VehicleRxType.PRESSURE_UNIT,
             Enum::VehicleRxType.TIRE_SENSOR_EQUIPPED:
        {
          ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT );
          ReloadItem( Enum::VehicleInfoMenuItem.TIRE_REAR );
          ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT );
          ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT );
        }

        /* value changed */
        case Enum::VehicleRxType.AVERAGE_SPEED: ReloadItem( Enum::VehicleInfoMenuItem.AVG_SPEED );
        case Enum::VehicleRxType.FUEL_RATE_AVERAGE: ReloadItem( Enum::VehicleInfoMenuItem.AVG_FUEL );
        case Enum::VehicleRxType.FUEL_RATE_INSTANT: ReloadItem( Enum::VehicleInfoMenuItem.INST_FUEL );
        case Enum::VehicleRxType.TRIP_TIME: ReloadItem( Enum::VehicleInfoMenuItem.TRIP_TIME );
        case Enum::VehicleRxType.RANGE_DISTANCE: ReloadItem( Enum::VehicleInfoMenuItem.RANGE );
        case Enum::VehicleRxType.FUEL_CONSUMPTION: ReloadItem( Enum::VehicleInfoMenuItem.FUEL_CONSUMPTION );
        case Enum::VehicleRxType.AIR_TEMPERATURE: ReloadItem( Enum::VehicleInfoMenuItem.AIR_TEMPERATURE );
        case Enum::VehicleRxType.COOLANT_TEMPERATURE: ReloadItem( Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE );
        case Enum::VehicleRxType.BATTERY_VOLTAGE: ReloadItem( Enum::VehicleInfoMenuItem.BATTERY );
        case Enum::VehicleRxType.TIRE_FRONT: ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT );
        case Enum::VehicleRxType.TIRE_REAR: ReloadItem( Enum::VehicleInfoMenuItem.TIRE_REAR );
        case Enum::VehicleRxType.TIRE_FRONT_LEFT: ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT_LEFT );
        case Enum::VehicleRxType.TIRE_FRONT_RIGHT: ReloadItem( Enum::VehicleInfoMenuItem.TIRE_FRONT_RIGHT );
        case Enum::VehicleRxType.CRUISE_SPEED: ReloadItem( Enum::VehicleInfoMenuItem.CRUISE );
        default:;
      }
    }
  }

  $rect <940,340,1140,380>
  method void ReloadItem( arg Enum::VehicleInfoMenuItem aVehicleInfoItem )
  {
    var int32 i;
    for( i = 0; i < VerticalList.NoOfItems; i++ )
    {
      if( i < Items.size && aVehicleInfoItem == Items[i] )
      {
        VerticalList.InvalidateItems( i, i );
        break;
      }
    }
  }

  $rect <210,440,410,480>
  method bool LoadItemValueBlink( arg int32 aItemNo )
  {
    var bool blink = false;
    switch( Items[aItemNo] )
    {
      case Enum::VehicleInfoMenuItem.COOLANT_TEMPERATURE:
      {
        var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.COOLANT_TEMPERATURE );
        if( VehicleData.Valid &&
            Settings::COOLANT_HIGH_TEMPERATURE == VehicleData.DataFloat )
        {
          blink = true;
        }
      }
      default:;
    }
    return blink;
  }
}

$rect <980,220,1180,260>
$output false
class ItemVehicleInfo : Components::BaseComponent
{
  $rect <0,105,190,145>
  inherited property Bounds = <0,0,400,76>;

  $rect <0,160,200,200>
  inherited property PassUpKey = true;

  $rect <0,210,200,250>
  inherited property PassDownKey = true;

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,19,144,52>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium24pt;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image IconUnit
  {
    preset Bounds = <288,15,346,57>;
    preset Bitmap = Resource::IconUnitKM_L;
  }

  $rect <20,20,160,60>
  object Views::Text ValueText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <149,7,281,64>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansMedium40pt;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <232,7,282,64>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansMedium40pt;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text HourText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <147,7,197,64>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansMedium40pt;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image HourIcon
  {
    preset Bounds = <204,15,231,57>;
    preset Bitmap = Resource::IconUnitHour;
    preset Visible = false;
  }

  $rect <240,210,440,250>
  object Core::Timer ValueTextBlinkTimer
  {
    preset OnTrigger = OnValueTextBlinkText;
    preset Period = 500;
  }

  $rect <240,260,440,300>
  slot OnValueTextBlinkText
  {
    ValueText.Visible = !ValueText.Visible;
  }

  $rect <240,100,440,140>
  property bool ValueTextBlink;

  $rect <240,150,440,190>
  onset ValueTextBlink
  {
    if( pure ValueTextBlink != value )
    {
      pure ValueTextBlink = value;
      ValueTextBlinkTimer.Enabled = value;
    }
  }

  $reorder Init 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Enabled 1
  $reorder OnLongHomeKeyActivated 1
  $reorder PassUpKey 1
  $reorder PassDownKey 1
  $reorder PassHomeKey 1
  $reorder PassEnterKey 1
  $reorder OnShortMagicKeyActivated 1
  $reorder PassMagicKey 1
  $reorder DDModeEnabled 1
  $reorder IsDDModeEffected 1
  $reorder OnSetDDModeEnabled 1
  $reorder OnDownKeyReleased 1
  $reorder OnUpKeyReleased 1
  $reorder MagicKeyEnabled 1
  $reorder OnSetMagicKeyEnabled 1
  $reorder Title 1
}

$rect <430,170,630,210>
$output false
class EcoMeterChart : Core::Group
{
  $rect <30,300,230,340>
  inherited property Bounds = <0,0,369,156>;

  $rect <650,20,850,60>
  property float MaxValue;

  $rect <650,60,850,100>
  onset MaxValue
  {
    // Remember the property's new value.
    pure MaxValue = value;
  }

  $rect <410,20,610,60>
  property Resources::Bitmap DotFrame = null;

  $rect <410,60,610,100>
  onset DotFrame
  {
    // Remember the property's new value.
    pure DotFrame = value;

    /* ...and force an update of the component */
    InvalidateArea( Bounds.orect );
  }

  $rect <400,130,600,170>
  property int32 BarSize;

  $rect <400,170,600,210>
  onset BarSize
  {
    /* check for valid values */
    if ( value < 0 )
      value = 0;

    /* check for any news... */
    if ( value == pure BarSize )
      return;

    /* store the new value... */
    pure BarSize = value;

    /* ...and force an update of the component */
    InvalidateArea( Bounds.orect );
  }

  $rect <640,130,840,170>
  property Home::RecordList Records;

  $rect <640,170,840,210>
  onset Records
  {
    pure Records = value;

    if (( Records == null ) || ( Records.NoOfItems < 1 ))
      return;

    if( Record != null )
    {
      if( Record.Value > 2.0 )
      {
        Record.Value = 2.0;
      }

      var int32 dist = (int32)( 5.6*( Record.Value*10 ) ); // 5.6 is the difference between each bar's height. 118(scale's height)/ 21(0.0~2.0) = 5.6

      if (( pure DotFrame != null ) )
      {
        EcoUnit = new Home::EcoMeterComponent;

        EcoUnit.Bounds = rect(BarPos.x1,BarPos.y1 - dist,BarPos.x2,BarPos.y2);
        Add( EcoUnit, 0 );
      }
      signal StartAnimation;
    }


  }

  $rect <890,70,1090,110>
  slot OnAnimate
  {
    var Core::View view = FindNextView( null, Core::ViewState[] );
    while (( view != null))
    {
      if( classof view == classof EcoUnit )
      {
        var Home::EcoMeterComponent bar = (Home::EcoMeterComponent) view;
        bar.Bounds.x1 = bar.Bounds.x1 - 11;
        bar.Bounds.x2 = bar.Bounds.x2 - 11;
      }
      view = view.next;
    }
  }

  $rect <402,230,602,270>
  property Home::Record Record;

  $rect <648,230,848,270>
  property slot StartAnimation;

  $rect <648,270,848,310>
  property slot EndAnimation;

  $rect <400,330,600,370>
  var Home::EcoMeterComponent EcoUnit;

  $rect <890,20,1090,60>
  method void RemoveEcoUnit( arg int32 aIndex )
  {
    if( aIndex >= 0 )
    {
      var Core::View view = GetViewAtIndex( aIndex );
      var Home::EcoMeterComponent EcoBar = (Home::EcoMeterComponent) view;
      if( null != EcoBar )
      {
        Remove( EcoBar );
      }
    }
    else
    {
      trace "Invalid index";
    }
  }

  $rect <890,120,1090,160>
  method void HideEcoUnit( arg int32 aIndex )
  {
    if( aIndex >= 0 )
    {
      var Core::View view = GetViewAtIndex( aIndex );
      var Home::EcoMeterComponent EcoBar = (Home::EcoMeterComponent) view;
      if( null != EcoBar )
      {
        EcoBar.Visible = false;
      }
    }
    else
    {
      trace "Invalid index";
    }
  }

  $rect <650,320,850,360>
  var rect BarPos = <363,133,369,140>;
}

$rect <430,220,630,260>
$output false
class EcoMeterComponent : Core::Group
{
  $rect <0,160,200,200>
  inherited property Bounds = <0,0,6,118>;

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Bounds = <0,3,6,118>;
    preset Color = #719E0DFF;
  }

  $rect <20,20,160,60>
  object Views::Frame Dot
  {
    preset Bounds = <0,0,6,6>;
    preset Bitmap = Resource::EcoDot;
  }
}

$rect <430,320,630,360>
$output false
class RecordList
{
  $rect <500,10,680,50>
  var Home::Record firstRecord = null;

  $rect <500,50,680,90>
  var Home::Record lastRecord = null;

  // The method 'ClearList' is used to clear the list of records.
  $rect <20,30,200,70>
  method void ClearList()
  {
    firstRecord = null;
    lastRecord  = null;

    pure NoOfItems = 0;
  }

  // The method GetRecord returns the record object with the given index.
  $rect <20,80,200,120>
  method Home::Record GetRecord( arg int32 aIndex )
  {
    if (( aIndex < 0 ) || ( aIndex >= NoOfItems ))
      return null;

    var Home::Record record = firstRecord;

    /* iterate through the list of records */
    while (( aIndex > 0 ) && ( record != null ))
    {
      aIndex = aIndex - 1;
      record = record.next;
    }

    return record;
  }

  $rect <20,130,220,170>
  method void AddRecord( arg float aValue )
  {
    var Home::Record record = null;

    /* create a new record object */
    record = new Home::Record;

    /* initialize the record with the given values */
    record.Value = aValue;

    /* check if the new record object is the first one */
    if ( firstRecord == null )
    {
      firstRecord = record;
      lastRecord = record;
      pure NoOfItems = 1;
    }
    /* otherwise add the new record object at the end of the list */
    else if( NoOfItems < MaxValue )
    {
      lastRecord.next = record;
      lastRecord = record;
      pure NoOfItems = pure NoOfItems + 1;
    }
    else
    {
      trace "reach maximum capacity";
    }
  }

  $rect <20,180,220,220>
  method void RemoveRecord()
  {
    if( firstRecord == null )
      return;

    var Home::Record record = firstRecord;
    pure NoOfItems = pure NoOfItems - 1;

    firstRecord = record.next;
    record = null;
  }

  $rect <250,60,450,100>
  var int32 MaxValue = 32;

  $rect <250,20,450,60>
  property int32 NoOfItems = 0;
}

$rect <430,270,630,310>
$output false
class Record
{
  // The variable 'Value' contains the data value to be shown within a chart.
  $rect <10,10,190,50>
  var float Value = 0.0;

  $rect <190,10,370,50>
  var Home::Record next = null;
}

$rect <30,160,230,200>
$output false
class TachoBaseline : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,480,234>;

  $rect <0,310,200,350>
  inherited method UpdateLayout()
  {
    super( aSize );

    var int32 BaselineStartX = 4;
    var int32 BaselineDistanceX;
    var int32 BaselineNum;

    if( Enum::TachoFullScale.RPM10000 == FullScaleType )
    {
      BaselineDistanceX = 21;
      BaselineNum = 21;
    }
    else /* Enum::TachoFullScale.RPM15000 */
    {
      BaselineDistanceX = 14;
      BaselineNum = 31;
    }

    DrawBaselines( BaselineStartX, BaselineDistanceX, BaselineNum );
  }

  $rect <430,260,630,300>
  property int32 RedZoneBeginRPM;

  $rect <430,310,630,350>
  onset RedZoneBeginRPM
  {
    if( pure RedZoneBeginRPM != value )
    {
      pure RedZoneBeginRPM = value;
      InvalidateLayout();
    }
  }

  $rect <210,260,410,300>
  property Enum::TachoFullScale FullScaleType;

  $rect <210,310,410,350>
  onset FullScaleType
  {
    if( pure FullScaleType != value )
    {
      pure FullScaleType = value;
      InvalidateLayout();
    }
  }

  $rect <0,360,200,400>
  method void DrawBaselines( arg int32 BaselineStartX, arg int32 BaselineDistanceX, arg int32 BaselineNum )
  {
    var int32 BaselineIdx = 0;
    var int32 RedZoneStartIdx = RedZoneBeginRPM / 500;

    RemoveAll();

    for( BaselineIdx = 0; BaselineIdx < BaselineNum; BaselineIdx++ )
    {
      var Views::Image BaselineImg = new Views::Image;
      if( 0 == BaselineIdx % 2 )
      {
        BaselineImg.Bitmap = Resource::TachoBaselineA;
      }
      else
      {
        BaselineImg.Bitmap = Resource::TachoBaselineB;
      }

      if( BaselineIdx >= RedZoneStartIdx )
      {
        BaselineImg.FrameNumber = 1;
      }

      var int32 StartX = BaselineStartX + BaselineDistanceX * BaselineIdx;
      var rect BaselineBounds = rect( StartX, 0, StartX + Resource::TachoBaselineA.FrameSize.x, Resource::TachoBaselineA.FrameSize.y );
      BaselineImg.Bounds = BaselineBounds;
      Add( BaselineImg, 0 );
    }
  }
}

$rect <30,210,230,250>
$output false
class TachoColor : Core::Group
{
  $rect <0,250,200,290>
  inherited property Bounds = <0,0,223,234>;

  $rect <20,20,160,60>
  object Views::Image UpColorbaseImg
  {
    preset Bounds = <0,0,223,91>;
    preset Alignment = Views::ImageAlignment[AlignHorzRight, AlignVertBottom];
    preset Bitmap = Resource::ExternTachoUpColorbase;
  }

  $rect <20,20,160,60>
  object Views::Image DownColorbaseImg
  {
    preset Bounds = <0,133,223,234>;
    preset Alignment = Views::ImageAlignment[AlignHorzRight, AlignVertTop];
    preset Bitmap = Resource::ExternTachoDownColorbase;
  }

  $rect <20,20,160,60>
  object Views::Image Front
  {
    preset Bounds = <188,0,234,234>;
    preset Bitmap = Resource::TachoFront;
  }

  $rect <670,250,870,290>
  property int32 ApsAngle;

  $rect <670,300,870,340>
  onset ApsAngle
  {
    if( pure ApsAngle != value )
    {
      pure ApsAngle = value;

      UpdateYMask( value );
    }
  }

  $rect <670,350,870,390>
  method void UpdateYMask( arg int32 aApsAngle )
  {
    /* upper mask y1, y2:
       for aps angle   0: y2 = 88,
       for aps angle 80: y2 = 9
       (88-9)/(80-0) = 1 */
    var float ApsToYspacingScale = 0.9875;

    var int32 UpperMaskY2 = (int32)( Home::TACHO_UPPER_MASK_Y_MAX - ApsToYspacingScale * aApsAngle );
    var int32 UpperMaskY1 = UpperMaskY2 - Home::TACHO_X_MASK_HEIGHT + 1;
    if( UpperMaskY1 < 0 )
    {
      UpperMaskY1 = 0;
    }

    var int32 LowerMaskY1 = (int32)( Home::TACHO_LOWER_MASK_Y_MIN + ApsToYspacingScale * aApsAngle );
    var int32 LowerMaskY2 = LowerMaskY1 + Home::TACHO_X_MASK_HEIGHT - 1;
    if( Bounds.h < LowerMaskY2 )
    {
      LowerMaskY2 = Bounds.h;
    }

    // update reference line for check
    if( ReferenceLineVisible )
    {
      YmaskUpStartLine.Point1.y = UpperMaskY1;
      YmaskUpStartLine.Point2.y = UpperMaskY1;
      YmaskUpEndLine.Point1.y = UpperMaskY2;
      YmaskUpEndLine.Point2.y = UpperMaskY2;

      YmaskDownStartLine.Point1.y = LowerMaskY1;
      YmaskDownStartLine.Point2.y = LowerMaskY1;
      YmaskDownEndLine.Point1.y = LowerMaskY2;
      YmaskDownEndLine.Point2.y = LowerMaskY2;
    }

    DeviceInterface::VehicleDevice.SetTachoYMask( UpperMaskY1, UpperMaskY2, LowerMaskY1, LowerMaskY2 );
  }

  $rect <240,300,440,340>
  method void UpdateColorbase( arg int32 aApsAngle )
  {
    var int32 HorizontalOffset = 8; /* for max bounds.x2 of 457, the max colorbase width is 449 */
    var rect ColorRect = Bounds;
    ColorRect.x1 -= HorizontalOffset;
    ColorRect.x2 -= HorizontalOffset;
    if( ColorRect.x1 < 0 )
    {
      ColorRect.x1 = 0;
    }

    if( Bounds.h < ColorRect.h )
    {
      ColorRect.h = Bounds.h;
    }

    /* for up height, 0 deg: 0px, 80 deg: 91px 
       => 91 / 80 = 1.1375 */
    var int32 UpHalfHeight = (int32)( 1.1375 * aApsAngle );
    ColorRect.y1 = Home::TACHO_UPPER_MASK_Y_MAX - UpHalfHeight - Home::TACHO_X_MASK_HEIGHT;
    if( 0 > ColorRect.y1 )
    {
      ColorRect.y1 = 0;
    }

    /* for down height, 0 deg: 0px, 80 deg: 97px 
       => 97 / 80 = 1.2125 */
    var int32 DownHalfHeight = (int32)( 1.2125 * aApsAngle );
    ColorRect.y2 = Home::TACHO_LOWER_MASK_Y_MIN + DownHalfHeight + Home::TACHO_X_MASK_HEIGHT;
    if( Bounds.h < ColorRect.y2 )
    {
      ColorRect.y2 = Bounds.h;
    }

    ColorbaseUpLine.Point1.y = ColorRect.y1;
    ColorbaseUpLine.Point2.y = ColorRect.y1;

    ColorbaseDownLine.Point1.y = ColorRect.y2;
    ColorbaseDownLine.Point2.y = ColorRect.y2;

    /* divide the colorbase into upper and lower parts */
    var rect UpperColorbase = ColorRect;
    var rect LowerColorbase = ColorRect;
    UpperColorbase.y2 = UpColorbaseImg.Bounds.y2;
    LowerColorbase.y1 = DownColorbaseImg.Bounds.y1;
    DeviceInterface::VehicleDevice.SetTachoColorbaseRect( UpperColorbase, LowerColorbase );
  }

  $rect <20,20,160,60>
  object Views::Line ColorbaseUpLine
  {
    preset Point2 = <223,15>;
    preset Point1 = <3,15>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line ColorbaseDownLine
  {
    preset Point2 = <223,201>;
    preset Point1 = <3,201>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line YmaskUpEndLine
  {
    preset Point2 = <223,93>;
    preset Point1 = <3,93>;
    preset Color = #FEFF64FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line YmaskUpStartLine
  {
    preset Point2 = <223,56>;
    preset Point1 = <3,56>;
    preset Color = #46FF4BFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line YmaskDownStartLine
  {
    preset Point2 = <223,156>;
    preset Point1 = <3,156>;
    preset Color = #FEFF64FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line YmaskDownEndLine
  {
    preset Point2 = <223,185>;
    preset Point1 = <3,185>;
    preset Color = #46FF4BFF;
    preset Visible = false;
  }

  $rect <460,250,660,290>
  property int32 EngineSpeed;

  $rect <460,300,660,340>
  onset EngineSpeed
  {
    if( pure EngineSpeed != value )
    {
      pure EngineSpeed = value;
      UpdateBounds( value );
    }
  }

  $rect <460,350,660,390>
  method void UpdateBounds( arg int32 aEngineSpeed )
  {
    var int32 CircularSectorBoundsX2Max = 457;

    var float EngineSpeedToXPositionFactor;
    if( Enum::TachoFullScale.RPM10000 == FullScaleType )
    {
      EngineSpeedToXPositionFactor = 0.0423; /* (457-34) / 10000 */
    }
    else
    {
      EngineSpeedToXPositionFactor = 0.0282; /* (457-34) / 15000 */
    }

    /* calculate x position */
    var rect CircularSectorBounds = Bounds;
    var int32 CircularSectorBoundsWidth = Bounds.w;
    CircularSectorBounds.x2 = (int32)math_ceil( 34.0 + EngineSpeedToXPositionFactor * (float)aEngineSpeed );
    if( CircularSectorBoundsX2Max < CircularSectorBounds.x2 )
    {
      CircularSectorBounds.x2 = CircularSectorBoundsX2Max;
    }
    CircularSectorBounds.x1 = CircularSectorBounds.x2 - CircularSectorBoundsWidth;

    Bounds = CircularSectorBounds;
  }

  $rect <0,300,200,340>
  property Enum::TachoFullScale FullScaleType;

  $rect <0,350,200,390>
  property bool ReferenceLineVisible;

  $rect <0,400,230,440>
  onset ReferenceLineVisible
  {
    if( pure ReferenceLineVisible != value )
    {
      pure ReferenceLineVisible = value;

      ColorbaseUpLine.Visible = value;
      ColorbaseDownLine.Visible = value;

      YmaskUpStartLine.Visible = value;
      YmaskUpEndLine.Visible = value;

      YmaskDownStartLine.Visible = value;
      YmaskDownEndLine.Visible = value;
    }
  }

  $rect <0,450,200,490>
  property bool DownPartEnabled;

  $rect <240,250,440,290>
  method void SetEngineData( arg int32 aEngineSpeed, arg int32 aApsAngle )
  {
    var bool NeedReloadColorbase = false;

    if( EngineSpeed != aEngineSpeed )
    {
      EngineSpeed = aEngineSpeed;
      NeedReloadColorbase = true;
    }

    if( ApsAngle != aApsAngle )
    {
      ApsAngle = aApsAngle;
      NeedReloadColorbase = true;
    }

    if( NeedReloadColorbase )
    {
      UpdateColorbase( aApsAngle );
      ReloadColorbase();
    }
  }

  $rect <240,350,440,390>
  method void ReloadColorbase()
  {
    $if !$prototyper
      Resource::ExternTachoUpColorbase.Name = Resource::TACHO_COLORBASE_UP;
      Resource::ExternTachoUpColorbase.Reload();

      if( DownPartEnabled )
      {
        Resource::ExternTachoDownColorbase.Name = Resource::TACHO_COLORBASE_DOWN;
        Resource::ExternTachoDownColorbase.Reload();
        DownColorbaseImg.Visible = true;
      }
      else
      {
        DownColorbaseImg.Visible = false;
      }
    $endif
  }
}

$rect <30,260,230,300>
$output false
class TachoScale : Core::Group
{
  $rect <0,80,180,120>
  inherited method Init()
  {
  }

  $rect <0,130,200,170>
  inherited property Bounds = <0,0,480,63>;

  $rect <0,180,200,220>
  inherited method UpdateLayout()
  {
    super( aSize );

    RemoveAll();
    Add( Background, 0 );

    if( Enum::TachoFullScale.RPM10000 == FullScaleType )
    {
      Draw10000rpmScale();
    }
    else
    {
      Draw15000rpmScale();
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,480,63>;
    preset Bitmap = Resource::TachoNumberBG;
  }

  $rect <460,80,660,120>
  property int32 RedZoneBeginRPM;

  $rect <460,130,660,170>
  onset RedZoneBeginRPM
  {
    if( pure RedZoneBeginRPM != value )
    {
      pure RedZoneBeginRPM = value;
      InvalidateLayout();
    }
  }

  $rect <680,80,880,120>
  property Enum::TachoFullScale FullScaleType;

  $rect <680,130,880,170>
  onset FullScaleType
  {
    if( pure FullScaleType != value )
    {
      pure FullScaleType = value;
      InvalidateLayout();
    }
  }

  $rect <900,80,1100,120>
  property uint32 CurrentEngineSpeed;

  $rect <900,130,1130,170>
  onset CurrentEngineSpeed
  {
    if( pure CurrentEngineSpeed != value )
    {
      pure CurrentEngineSpeed = value;
      if( Enum::TachoFullScale.RPM10000 == FullScaleType )
      {
        Highlight1000rpmScale();
      }
      else
      {
        Highlight1500rpmScale();
      }
    }
  }

  $rect <230,80,430,120>
  method void Draw10000rpmScale()
  {
    var int32 i;
    var int32 RedZoneBeginIdx = RedZoneBeginRPM / Home::TACHO_BASELINE_SPACING_RPM;
    var int32 StartX = 13;
    var int32 StartY = 10;
    var int32 SpacingX = 21;

    for( i = 0; i < Home::TACHO_10000RPM_SCALE_NUM; i++ )
    {
      var Views::Image ScaleImage = new Views::Image;
      if( null == HighlightImages[i] )
      {
        HighlightImages[i] = new Views::Image;
      }

      if( i % 2 == 0 ) /* draw number */
      {
        var int32 Number = i / 2;
        if( i < RedZoneBeginIdx ||
            Number < Home::TACHO_BASELINE_REDZONE_BEGIN_MIN )
        {
          /* normal number */
          ScaleImage.Bitmap = Resource::TachoNumberOff;
          ScaleImage.FrameNumber = Number;

          HighlightImages[i].Bitmap = Resource::TachoNumberOn;
          HighlightImages[i].FrameNumber = Number;
        }
        else
        {
          /* red number */
          ScaleImage.Bitmap = Resource::TachoNumberOffRed;
          ScaleImage.FrameNumber = Number - Home::TACHO_BASELINE_REDZONE_BEGIN_MIN; /* TachoNumberOffRed starts from 8 */

          HighlightImages[i].Bitmap = Resource::TachoNumberOnRed;
          HighlightImages[i].FrameNumber = Number - Home::TACHO_BASELINE_REDZONE_BEGIN_MIN;
        }
      }
      else /* draw dot */
      {
        if( i < RedZoneBeginIdx )
        {
          /* normal dot */
          ScaleImage.Bitmap = Resource::TachoNumberDot;
          HighlightImages[i].Bitmap = Resource::TachoNumberDot;
          HighlightImages[i].FrameNumber = 1;
        }
        else
        {
          /* red dot */
          ScaleImage.Bitmap = Resource::TachoNumberDotRed;
          HighlightImages[i].Bitmap = Resource::TachoNumberDotRed;
          HighlightImages[i].FrameNumber = 1;
        }
      }

      ScaleImage.Bounds = rect( StartX, StartY, StartX + ScaleImage.Bitmap.FrameSize.x, StartY + ScaleImage.Bitmap.FrameSize.y );
      ScaleImage.Visible = true;
      Add( ScaleImage, 0 );

      HighlightImages[i].Bounds = ScaleImage.Bounds;
      HighlightImages[i].Visible = false;
      Add( HighlightImages[i], 0 );

      StartX += SpacingX;
    }
  }

  $rect <230,180,430,220>
  array Views::Image HighlightImages[ 21 ];

  $rect <230,130,430,170>
  method void Draw15000rpmScale()
  {
    var int32 i;
    var int32 RedZoneBeginIdx = RedZoneBeginRPM / Home::TACHO_15000RPM_SCALE;
    var int32 StartX = 13;
    var int32 StartY = 10;
    var int32 SpacingX = 28;

    for( i = 0; i < Home::TACHO_15000RPM_SCALE_NUM; i++ )
    {
      var Views::Image ScaleImage = new Views::Image;
      if( null == HighlightImages[i] )
      {
        HighlightImages[i] = new Views::Image;
      }

      if( ( i == 0 ) || ( i % 2 == 1 ) ) /* draw number */
      {
        var int32 Number = i;
        if( i < RedZoneBeginIdx ||
            Number < Home::TACHO_BASELINE_REDZONE_BEGIN_MIN )
        {
          /* normal number */
          ScaleImage.Bitmap = Resource::TachoNumberOff;
          ScaleImage.FrameNumber = Number;

          HighlightImages[i].Bitmap = Resource::TachoNumberOn;
          HighlightImages[i].FrameNumber = Number;
        }
        else
        {
          /* red number */
          ScaleImage.Bitmap = Resource::TachoNumberOffRed;
          ScaleImage.FrameNumber = Number - Home::TACHO_BASELINE_REDZONE_BEGIN_MIN; /* TachoNumberOffRed starts from 8 */

          HighlightImages[i].Bitmap = Resource::TachoNumberOnRed;
          HighlightImages[i].FrameNumber = Number - Home::TACHO_BASELINE_REDZONE_BEGIN_MIN;
        }
      }
      else /* draw dot */
      {
        if( i < RedZoneBeginIdx )
        {
          ScaleImage.Bitmap = Resource::TachoNumberDot;
          HighlightImages[i].Bitmap = Resource::TachoNumberDot;
          HighlightImages[i].FrameNumber = 1;
        }
        else
        {
          ScaleImage.Bitmap = Resource::TachoNumberDotRed;
          HighlightImages[i].Bitmap = Resource::TachoNumberDotRed;
          HighlightImages[i].FrameNumber = 1;
        }
      }

      ScaleImage.Bounds = rect( StartX, StartY, StartX + ScaleImage.Bitmap.FrameSize.x, StartY + ScaleImage.Bitmap.FrameSize.y );
      ScaleImage.Visible = true;
      Add( ScaleImage, 0 );

      HighlightImages[i].Bounds = ScaleImage.Bounds;
      HighlightImages[i].Visible = false;
      Add( HighlightImages[i], 0 );

      StartX += SpacingX;
    }
  }

  $rect <900,180,1120,220>
  method void Highlight1000rpmScale()
  {
    var int32 HighlightStartIdx = (int32)( CurrentEngineSpeed / Home::TACHO_10000RPM_SCALE );
    var int32 i;

    for( i = 0; i < Home::TACHO_10000RPM_SCALE_NUM; i++ )
    {
      if( i <= HighlightStartIdx )
      {
        HighlightImages[i].Visible = true;
      }
      else
      {
        HighlightImages[i].Visible = false;
      }
    }
  }

  $rect <900,230,1120,270>
  method void Highlight1500rpmScale()
  {
    var int32 HighlightStartIdx = (int32)( CurrentEngineSpeed / Home::TACHO_15000RPM_SCALE );
    var int32 i;

    for( i = 0; i < Home::TACHO_15000RPM_SCALE_NUM; i++ )
    {
      if( i <= HighlightStartIdx )
      {
        HighlightImages[i].Visible = true;
      }
      else
      {
        HighlightImages[i].Visible = false;
      }
    }
  }
}

$rect <30,110,250,150>
$output false
class HOM11_TachoVisualizer : Home::BaseHome
{
  $rect <0,280,180,320>
  inherited method Init()
  {
    trace "HOM11";

    $if !$prototyper
      FullScaleType = (Enum::TachoFullScale)DeviceInterface::SystemDevice.GetSystemStatus( Enum::SystemStatus.TACHO_FULLSCALE );
      RedZoneBeginRPM = DeviceInterface::SystemDevice.GetSystemStatus( Enum::SystemStatus.TACHO_REDZONE_BEGIN );
      UpdateVVAIndicator();
    $else
      FullScaleType = Enum::TachoFullScale.RPM15000;
      RedZoneBeginRPM = 10000;
    $endif
  }

  $rect <0,330,230,370>
  inherited method OnLongEnterKeyActivated()
  {
    if( Components::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      PresentDialog( new Info::INF01_MeterDisplaySettingMenu, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <20,20,160,60>
  inherited object BlackBG
  {
    preset Bounds = <0,38,480,272>;
  }

  $rect <20,20,160,60>
  object Home::TachoBaseline TachoBaseline
  {
    preset Bounds = <0,38,480,272>;
  }

  $rect <20,20,160,60>
  object Home::TachoColor CircularSector
  {
    preset Bounds = <-189,38,34,272>;
    preset ReferenceLineVisible = false;
    preset DownPartEnabled = true;
  }

  $rect <510,280,710,320>
  object Core::Timer UpdateTimer
  {
    preset OnTrigger = OnUpdateSlot;
    preset Period = 40;
    preset Enabled = true;
  }

  $rect <510,330,710,370>
  slot OnUpdateSlot
  {
    var uint32 EngineSpeed;
    var uint32 ApsAngle;

    if( IsCurrentDialog() )
    {
      $if !$prototyper
        if( DeviceInterface::VehicleDevice.IsTimeoutError2Detected )
        {
          EngineSpeed = 0;
        }
        else
        {
          var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.ENGINE_SPEED );
          EngineSpeed = VehicleData.DataUInt32; /* 0 - 25600 */

          VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.APS_ANGLE );
          ApsAngle = VehicleData.DataUInt32; /* 0 - 125 */
        }
      $else
        EngineSpeed = GetTestEngineSpeed();
        ApsAngle = GetTestApsAngle();
      $endif

      CircularSector.SetEngineData( (int32)EngineSpeed, (int32)ApsAngle );
      TachoScale.CurrentEngineSpeed = EngineSpeed;
    }
  }

  $rect <260,280,460,320>
  property Enum::TachoFullScale FullScaleType;

  $rect <260,330,460,370>
  onset FullScaleType
  {
    if( pure FullScaleType != value )
    {
      pure FullScaleType = value;
      TachoScale.FullScaleType = value;
      TachoBaseline.FullScaleType = value;
      CircularSector.FullScaleType = value;
    }
  }

  $rect <260,380,460,420>
  property int32 RedZoneBeginRPM;

  $rect <260,430,480,470>
  onset RedZoneBeginRPM
  {
    if( pure RedZoneBeginRPM != value )
    {
      pure RedZoneBeginRPM = value;
      TachoScale.RedZoneBeginRPM = value;
      TachoBaseline.RedZoneBeginRPM = value;
    }
  }

  $rect <20,20,160,60>
  object Home::TachoScale TachoScale
  {
    preset Bounds = <0,119,480,182>;
  }

  $rect <1110,370,1310,410>
  var uint32 TestEngineSpeed;

  $rect <1110,530,1310,570>
  var uint32 TestApsAngle;

  $rect <1110,420,1310,460>
  var uint32 TestEngineSpeedStep = 200;

  $rect <1110,580,1310,620>
  var uint32 TestApsAngleStep = 5;

  // Prototyper
  note group Note3
  {
    attr Bounds = <1080,270,1340,650>;
  }

  $rect <1110,320,1310,360>
  method uint32 GetTestEngineSpeed()
  {
    TestEngineSpeed += TestEngineSpeedStep;

    var int32 MaxScale = 17000;
    if( Enum::TachoFullScale.RPM10000 == FullScaleType )
    {
      MaxScale = 11000;
    }

    if( (int32)TestEngineSpeed > MaxScale )
    {
      TestEngineSpeed = 0;
    }

    return TestEngineSpeed;
  }

  $rect <1110,480,1310,520>
  method uint32 GetTestApsAngle()
  {
    TestApsAngle += TestApsAngleStep;
    if( Home::TACHO_APS_ANGLE_MAX < TestApsAngle )
    {
      TestApsAngle = 0;
    }

    return TestApsAngle;
  }

  $rect <740,280,1020,320>
  object Core::SystemEventHandler VehicleDataReceivedEventHandler
  {
    preset OnEvent = OnVehicleDataReceivedSlot;
    preset Event = DeviceInterface::VehicleDevice.VehicleDataReceivedSystemEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <740,330,980,370>
  slot OnVehicleDataReceivedSlot
  {
    var DeviceInterface::VehicleDataClass VehicleData = (DeviceInterface::VehicleDataClass)VehicleDataReceivedEventHandler.Context;
    if( null != VehicleData )
    {
      switch( VehicleData.RxType )
      {
        case Enum::VehicleRxType.VVA_INDICATOR: UpdateVVAIndicator();
        case Enum::VehicleRxType.TACHO_SETTING:
        {
          FullScaleType = (Enum::TachoFullScale)DeviceInterface::SystemDevice.GetSystemStatus( Enum::SystemStatus.TACHO_FULLSCALE );
          RedZoneBeginRPM = DeviceInterface::SystemDevice.GetSystemStatus( Enum::SystemStatus.TACHO_REDZONE_BEGIN );
        }
        default:;
      }
    }
  }

  $rect <740,380,940,420>
  method void UpdateVVAIndicator()
  {
    var DeviceInterface::VehicleDataClass VehicleData = DeviceInterface::VehicleDevice.GetData( Enum::VehicleRxType.VVA_INDICATOR );
    if( Home::VVA_INDICATOR_VALUE == VehicleData.DataUInt32 )
    {
      VVAIndicatorImage.Visible = true;
    }
    else
    {
      VVAIndicatorImage.Visible = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image RpmImg
  {
    preset Bounds = <323,232,474,265>;
    preset FrameNumber = 0;
    preset Bitmap = Resource::Tacho1000R;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper StatusbarShadow
  {
    preset Bounds = <0,38,480,51>;
    preset Bitmap = Resource::TachoStatusbarShadow;
  }

  $rect <20,20,160,60>
  object Views::Image VVAIndicatorImage
  {
    preset Bounds = <364,38,474,73>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::TachoVVA;
    preset Visible = false;
  }
}

$rect <30,310,360,350>
$output false
const int32 TACHO_BASELINE_SPACING_RPM = 500;

$rect <30,360,360,400>
$output false
const int32 TACHO_BASELINE_REDZONE_BEGIN_MIN = 8;

$rect <30,410,360,450>
$output false
const int32 TACHO_10000RPM_SCALE = 500;

$rect <30,460,360,500>
$output false
const int32 TACHO_15000RPM_SCALE = 1000;

// Tachometer Visualizer
note group Note3
{
  attr Bounds = <10,70,380,870>;
}

$rect <30,510,360,550>
$output false
const int32 TACHO_10000RPM_SCALE_NUM = 21;

$rect <30,560,360,600>
$output false
const int32 TACHO_15000RPM_SCALE_NUM = 16;

$rect <30,610,360,650>
$output false
const int32 TACHO_APS_ANGLE_MAX = 125;

// 126 - 38
$rect <30,660,360,700>
$output false
const int32 TACHO_UPPER_MASK_Y_MAX = 88;

// 175 - 38
$rect <30,710,360,750>
$output false
const int32 TACHO_LOWER_MASK_Y_MIN = 137;

$rect <30,760,360,800>
$output false
const int32 TACHO_X_MASK_HEIGHT = 46;

$rect <30,810,360,850>
$output false
const int32 VVA_INDICATOR_VALUE = 1;

// ECO Visualizer
note group Note4
{
  attr Bounds = <410,70,650,870>;
}

// Speed Visualizer
note group Note5
{
  attr Bounds = <690,70,930,870>;
}

// Vehicle Info
note group Note6
{
  attr Bounds = <960,70,1200,870>;
}

$rect <710,240,910,280>
$output false
const color SV_WITHOUT_SPEED_LIMIT = #444AFFFF;

$rect <710,280,910,320>
$output false
const color SV_WITH_SPEED_LIMIT = #31A68FFF;

$rect <710,320,910,360>
$output false
const color SV_OVER_SPEED_LIMIT = #EA730AFF;

$rect <710,360,910,400>
$output false
const point CIRCLE_CENTER_POS = <243,123>;

$rect <710,400,910,440>
$output false
const int32 SCALE_FACTOR = 280;

$rect <710,440,910,480>
$output false
const float ADJ_FACTOR = 0.0055;

$rect <710,480,910,520>
$output false
const float RELATIVE_VALUE_MAX = 1.286;

$rect <710,180,910,220>
$output false
class SpeedCircle : Core::Group
{
  $rect <0,280,200,320>
  inherited property Bounds = <0,0,480,234>;

  $rect <550,210,750,250>
  slot OnValueChangeSlot
  {
    if( SpeedCircleResizeEffect.Value == 0 )
    {
      SpeedCircleImage.Visible = false;
    }
    else
    {
      SpeedCircleImage.Visible = true;
      var float RelativeValue;
      if( SpeedLimit > 0 )
      {
        RelativeValue = (float)SpeedCircleResizeEffect.Value/(float)SpeedLimit;
        GradientLine.Visible = true;
      }
      else
      {
        RelativeValue = (float)SpeedCircleResizeEffect.Value/100.0;
        GradientLine.Visible = false;
      }

      if( RelativeValue > Home::RELATIVE_VALUE_MAX )
      {
        RelativeValue = Home::RELATIVE_VALUE_MAX;
      }

      var float Scale = RelativeValue*Home::SCALE_FACTOR;
      Scale = Scale.round;
      Scale = Scale*Home::ADJ_FACTOR; // if follow what spec described to multiple 0.01, the circle size will never match the images displayed on the spec. This 0.0055 is a factor to make sure the image shows the same as spec.

      if( GradientLine.Visible )
      {
        if( SpeedCircleResizeEffect.Value > SpeedLimit )
        {
          SpeedCircleImage.Color = Home::SV_OVER_SPEED_LIMIT;
        }
        else
        {
          SpeedCircleImage.Color = Home::SV_WITH_SPEED_LIMIT;
        }
      }
      else
      {
        SpeedCircleImage.Color  = Home::SV_WITHOUT_SPEED_LIMIT;
      }

      SpeedCircleImage.Visible = true;
      SpeedCircleImage.RotateAndScale( Home::CIRCLE_CENTER_POS, 0, Scale, Scale );
    }
  }

  $rect <550,30,750,70>
  property int32 SpeedValue = 0;

  $rect <550,170,750,210>
  object Effects::Int32Effect SpeedCircleResizeEffect
  {
    preset OnFinished = null;
    preset OnAnimate = OnValueChangeSlot;
    preset Elasticity = 0;
    preset NoOfCycles = 1;
    preset CycleDuration = 50;
    preset Value2 = 0;
  }

  $rect <550,70,750,110>
  onset SpeedValue
  {
    // It's possible that speed limit is changed during route guidance and vehicle meter speed is not changed.
    // In this case, new relative value needs to be calculated to adjust the size of circle. Therefore, same speed
    // has to be updated again when speed limit is updated.
    StartAnimation( pure SpeedValue, value );
    pure SpeedValue = value;


  }

  $rect <550,110,750,150>
  method void StartAnimation( arg int32 aCurrentValue, arg int32 aNextValue )
  {
    if( SpeedCircleResizeEffect.Enabled )
    {
      SpeedCircleResizeEffect.Enabled = false;
      SpeedCircleResizeEffect.Value1 = SpeedCircleResizeEffect.Value;
      SpeedCircleResizeEffect.Value2 = aNextValue;
      SpeedCircleResizeEffect.Enabled = true;
    }
    else
    {
      SpeedCircleResizeEffect.Value1 = aCurrentValue;
      SpeedCircleResizeEffect.Value2 = aNextValue;
      SpeedCircleResizeEffect.Enabled = true;
    }

  }

  $rect <780,30,980,70>
  property color Color;

  $rect <780,70,980,110>
  onset Color
  {
    if( pure Color != value )
    {
      // Remember the property's new value.
      pure Color = value;
      SpeedCircleImage.Color = value;
    }
  }

  $rect <20,20,160,60>
  object Views::Image GradientLine
  {
    preset Bounds = <50,0,430,234>;
    preset Bitmap = Resource::GradientCircleWhite;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::WarpImage SpeedCircleImage
  {
    preset StackingPriority = 0;
    preset Point4 = <235,132>;
    preset Point3 = <252,132>;
    preset Point2 = <252,114>;
    preset Point1 = <235,114>;
    preset SourceAnchor = <113,113>;
    preset Visible = false;
    preset Color = #7BA65BFF;
    preset Bitmap = Resource::SpeedLimitCircle;
  }

  $rect <780,160,980,200>
  var int32 SpeedLimit;
}
