$version 10.00

$rect <10,10,250,50>
$output false
class ItemBase : Core::Group
{
  $rect <0,80,190,115>
  inherited property Bounds = <0,0,440,60>;

  $rect <474,115,674,155>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      FocusFrame.FrameNumber = 1;
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      if( Focusable )
      {
      FocusFrame.FrameNumber = 0;
      FocusFrame.Visible = true;
      }
    }
    else
    {
      FocusFrame.Visible = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,440,60>;
    preset Color = #000000FF;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <210,75,430,350>;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <220,115,420,155>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnRelease = OnEnterReleaseSlot;
    preset OnPress = null;
    preset Filter = Core::KeyCode.Ok;
    preset OnHold = OnEnterHoldSlot;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <220,170,420,210>
  slot OnEnterReleaseSlot
  {
    trace "OnEnterRelease, repetition: ", KeyHandler.Repetition;

    if( false == KeyHandler.Repetition && Focusable )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      FocusFrameFlashTimer.Enabled = true;
    }
  }

  // State management
  note group Note4
  {
    attr Bounds = <450,75,700,170>;
  }

  $rect <20,20,160,60>
  object Views::Image ListDivider
  {
    preset Bounds = <0,53,440,63>;
    preset Alignment = Views::ImageAlignment[ScaleToFit];
    preset Bitmap = Resource::ListDivider;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,130,190,170>
  property slot OnActivate = null;

  // Focus frame flash effect
  note group Note3
  {
    attr Bounds = <450,210,700,350>;
  }

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <460,250,690,290>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <460,300,690,340>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  $rect <0,180,190,220>
  method void SetTitle( arg string aTitle )
  {
    if( Title.String != aTitle )
      {
      Title.String = aTitle;
      }
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <20,10,380,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::FontNotoSansCjkJp36;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Frame FocusFrame
  {
    preset Bounds = <0,0,440,60>;
    preset Bitmap = Resource::FocusFrame;
    preset Visible = false;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <220,230,420,270>
  slot OnEnterHoldSlot
  {
    trace "OnEnterHold: ", KeyHandler.RepetitionCount;
    postsignal OnEnterHold, KeyHandler;
  }

  $rect <220,290,420,330>
  property slot OnEnterHold;

  $rect <0,230,190,270>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;
      if( value )
      {
        Title.Color = #FFFFFFFF;
      }
      else
      {
        Title.Color = #646464FF;
      }
    }
  }

  $rect <0,370,200,410>
  property bool Focusable = true;

  $rect <0,410,200,450>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
      FocusFrame.Visible = value;
    }
  }

  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder Init 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Background 2
  $reorder Note2 2
  $reorder KeyHandler 2
  $reorder OnEnterReleaseSlot 2
  $reorder Note4 2
  $reorder ListDivider 2
  $reorder OnActivate 2
  $reorder Note3 2
  $reorder FocusFrameFlashTimer 2
  $reorder OnFocusFrameFlashTimer 2
  $reorder SetTitle 2
  $reorder Title 2
  $reorder FocusFrame 2
  $reorder OnEnterHoldSlot 2
  $reorder OnEnterHold 2
  $reorder Enabled 1
}

$rect <80,60,320,100>
$output false
class ItemRightArrow : Menu::ItemBase
{
  $rect <10,90,200,130>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      super( value );

      if( value )
      {
        IconRight.FrameNumber = 0;
      }
      else
      {
        IconRight.FrameNumber = 1;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image IconRight
  {
    preset Bounds = <396,11,433,48>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter, ScaleToFit];
    preset Bitmap = Resource::ListIconNext;
  }
}

$rect <10,260,250,300>
$output false
class VerticalMenu : Components::BaseComponent
{
  $rect <6,290,206,330>
  inherited property Bounds = <0,0,460,240>;

  $rect <220,410,420,450>
  inherited slot OnLongKeyPressed
  {
    signal PassKeyHold, sender;
  }

  $rect <220,350,420,390>
  inherited method OnShortDownKeyPressed()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 NextItemIdx = MenuList.SelectedItem + 1;
      if( NextItemIdx < MenuList.NoOfItems )
      {
        var Menu::ItemWrapper Item = ( Menu::ItemWrapper )MenuList.GetViewForItem( NextItemIdx );
        if( null != Item && Item.Enabled )
        {
          MenuList.SelectedItem = NextItemIdx;
          MenuList.EnsureVisible( MenuList.SelectedItem, false, null, null );
          Scrollbar.ViewIdx = MenuList.SelectedItem;
        }
      }
    }
  }

  $rect <220,290,420,330>
  inherited method OnShortUpKeyPressed()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 PrevItemIdx = MenuList.SelectedItem - 1;
      if( PrevItemIdx >= 0 )
      {
        MenuList.SelectedItem = PrevItemIdx;
        MenuList.EnsureVisible( MenuList.SelectedItem, false, null, null );
        Scrollbar.ViewIdx = MenuList.SelectedItem;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,480,240>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList MenuList
  {
    preset Bounds = <0,0,440,240>;
    preset Focus = null;
    preset OnLoadItem = OnLoadItemSlot;
    preset SelectedItem = 0;
    preset ItemHeight = 60;
    preset NoOfItems = 1;
    preset ItemClass = Menu::ItemWrapper;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <440,290,640,330>
  slot OnLoadItemSlot
  {
    var int32 ItemNo = MenuList.Item;
    var Menu::ItemWrapper Item = ( Menu::ItemWrapper )MenuList.View;
    if( null != Item )
    {
      var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
      if( null != OwnerMenu )
      {
        Item.ItemClass = OwnerMenu.LoadItemClass( ItemNo );
        Item.Title = OwnerMenu.LoadItemTitle( ItemNo );
        Item.Enabled = OwnerMenu.LoadItemEnabled( ItemNo );
        Item.OnActivate = OnItemActivateSlot;
        Item.OnEnterHold = OnLongKeyPressed;
        Item.Focusable = Focusable;
      }

      if( Menu::ItemCheckbox == Item.ItemClass )
      {
        Item.Checked = OwnerMenu.LoadItemChecked( ItemNo );
      }
      else if( Menu::ItemBtPairedDevice == Item.ItemClass )
      {
        Item.Connected = OwnerMenu.LoadItemConnected( ItemNo );
        Item.Valid = OwnerMenu.LoadItemValid( ItemNo );
      }

      Item.Bounds.size = point( MenuList.Bounds.w, MenuList.ItemHeight );
    }
  }

  $rect <650,290,850,330>
  slot OnItemActivateSlot
  {
    var Menu::ItemBase MenuItem = null;
    var Menu::ItemWrapper WrapperItem = ( Menu::ItemWrapper )sender;
    if( null != WrapperItem )
    {
      var Core::View Menu = WrapperItem.FindNextView( null, Core::ViewState[] );
      if( null != Menu )
      {
        MenuItem = ( Menu::ItemBase )Menu;
      }
    }

    var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
    if( null != OwnerMenu )
    {
      OwnerMenu.OnItemActivate( MenuList.SelectedItem, MenuItem );
    }
  }

  $rect <490,10,690,50>
  property int32 NoOfItems;

  $rect <490,60,690,100>
  onset NoOfItems
  {
    if( pure NoOfItems != value )
    {
      pure NoOfItems = value;
      MenuList.NoOfItems = value;
      Scrollbar.ListItems = value;
    }
  }

  $rect <20,20,160,60>
  object Menu::Scrollbar Scrollbar
  {
    preset Bounds = <450,0,460,240>;
    preset PageItems = 4;
  }

  $rect <0,350,200,390>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    MenuList.InvalidateItems( aFirstItem, aLastItem );
    Scrollbar.ViewIdx = 0;
  }

  $rect <0,410,200,450>
  property bool Focusable = true;
}

$rect <80,110,320,150>
$output false
class ItemCheckbox : Menu::ItemBase
{
  $rect <200,80,400,120>
  inherited slot OnEnterReleaseSlot
  {
    super( sender );
    CheckBoxButton.Checked = !CheckBoxButton.Checked;

  }

  $rect <0,170,190,210>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      super( value );
      CheckBoxButton.Enabled = value;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBoxButton
  {
    preset Bounds = <392,15,422,45>;
    preset Enabled = true;
    preset Checked = false;
    preset IconFrame = 0;
    preset Label = "";
    preset Appearance = UIConfig::ToggleButtonConfig;
  }

  $rect <0,80,200,120>
  property bool Checked;

  $rect <0,120,200,160>
  onset Checked
  {
    // The value doesn't change - nothing to do.
    if ( pure Checked == value )
      return;

    // Remember the property's new value.
    pure Checked = value;
    CheckBoxButton.Checked = value;

  }
}

// This is a GUI component.
$rect <10,210,250,250>
$output false
class ItemWrapper : Core::Group
{
  $rect <0,80,200,120>
  inherited property Bounds = <0,0,400,60>;

  $rect <480,410,660,450>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <480,350,660,390>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      var Menu::ItemRightArrow ItemRight = ( Menu::ItemRightArrow )view;
      if( null != ItemRight )
      {
        ItemRight.Enabled = value;
      }
      else
      {
        var Menu::ItemCheckbox ItemCheck = ( Menu::ItemCheckbox )view;
        if( null != ItemCheck )
        {
          ItemCheck.Enabled = value;
        }
        else
        {
          var Menu::ItemBase Item = ( Menu::ItemBase )view;
          if( null != Item )
          {
            Item.Enabled = value;
          }
        }
      }
    }
  }

  $rect <480,290,660,330>
  inherited property Enabled;

  // This is a property.
  $rect <40,290,240,330>
  property class ItemClass = null;

  $rect <40,350,240,390>
  onset ItemClass
  {
    if( pure ItemClass == value )
      return;

    // Remember the property's new value.
    pure ItemClass = value;

    // Remove the old embedded item, if any ...
    if( CountViews() > 0 )
    {
      Remove( FindNextView( null, Core::ViewState[] ) );
    }

    var Menu::ItemBase Item = ( Menu::ItemBase )new value;
    Item.OnActivate = OnActivateSlot;
    Item.OnEnterHold = OnEnterHoldSlot;
    Add( Item, 0 );
  }

  // This is a property.
  $rect <260,290,460,330>
  property string Title = "Title";

  $rect <260,350,460,390>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase MenuItem = ( Menu::ItemBase )view;
      if( MenuItem != null )
      {
        MenuItem.SetTitle( Title );
      }
    }
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,190,200,230>
  property slot OnActivate = null;

  $rect <0,140,200,180>
  slot OnActivateSlot
  {
    postsignal OnActivate;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <20,250,890,470>;
  }

  // For checkbox menu item
  note group Note7
  {
    attr Bounds = <20,500,530,650>;
  }

  $rect <40,540,240,580>
  property bool Checked;

  $rect <40,590,240,630>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemCheckbox Checkbox = ( Menu::ItemCheckbox )view;
      if( Checkbox != null )
      {
        Checkbox.Checked = value;
      }
    }
  }

  $rect <220,140,420,180>
  slot OnEnterHoldSlot
  {
    postsignal OnEnterHold, sender;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <220,190,420,230>
  property slot OnEnterHold = null;

  // For BT paired device item
  note group Note8
  {
    attr Bounds = <20,680,520,830>;
  }

  $rect <50,720,250,760>
  property bool Connected;

  $rect <50,770,250,810>
  onset Connected
  {
    if( pure Connected != value )
    {
      pure Connected = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBtPairedDevice PairedDevice = ( Menu::ItemBtPairedDevice )view;
      if( null != PairedDevice )
      {
        PairedDevice.Connected = value;
      }
    }
  }

  $rect <670,290,870,330>
  property bool Focusable = true;

  $rect <670,350,870,390>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.Focusable = value;
      }
    }
  }

  $rect <270,720,470,760>
  property bool Valid = true;

  $rect <270,770,470,810>
  onset Valid
  {
    if( pure Valid != value )
    {
      pure Valid = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBtPairedDevice PairedDevice = ( Menu::ItemBtPairedDevice )view;
      if( null != PairedDevice )
      {
        PairedDevice.Valid = value;
      }
    }
  }
}

$rect <350,10,550,50>
$output false
class Scrollbar : Core::Group
{
  $rect <60,160,260,200>
  inherited property Bounds = <0,0,10,240>;

  $rect <60,210,260,250>
  inherited method UpdateViewState()
  {
    super( aState );

    if( PageNum > 0 )
    {
      var int32 CurrentPage = ViewIdx / PageItems;
      var int32 BarHeight = int32( float( Bounds.h ) / float( PageNum ) );
      var int32 BarTopY = int32( float( Bounds.h ) * ( float( CurrentPage ) / float( PageNum ) ) );
      Bar.Bounds = rect( Bar.Bounds.x1, BarTopY, Bar.Bounds.x2, BarTopY + BarHeight );
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,10,240>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Track
  {
    preset Point2 = <5,240>;
    preset Point1 = <5,0>;
    preset Width = 3;
    preset Color = #646464FF;
  }

  $rect <490,60,690,100>
  property int32 ViewIdx;

  $rect <490,100,690,140>
  onset ViewIdx
  {
    if( pure ViewIdx != value )
    {
      pure ViewIdx = value;
      InvalidateViewState();
    }
  }

  $rect <60,60,260,100>
  property int32 PageItems;

  $rect <60,100,260,140>
  onset PageItems
  {
    if( pure PageItems != value )
    {
      pure PageItems = value;
      UpdatePageNum();
    }
  }

  $rect <280,60,480,100>
  property int32 ListItems;

  $rect <280,100,480,140>
  onset ListItems
  {
    if( pure ListItems != value )
    {
      pure ListItems = value;
      UpdatePageNum();
      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Bounds = <0,50,10,80>;
  }

  $rect <710,60,910,100>
  var int32 PageNum;

  $rect <710,100,910,140>
  method void UpdatePageNum()
  {
    if( PageItems >= ListItems )
    {
      Bar.Visible = false;
      Track.Visible = false;
      PageNum = 0;
    }
    else if( PageItems > 0 )
    {
      PageNum = ListItems / PageItems;
      if( ListItems > ( PageNum * PageItems ) )
      {
        PageNum = PageNum + 1;
      }

      Bar.Visible = true;
      Track.Visible = true;
    }
  }
}

$rect <350,60,590,100>
$output false
class BaseMenuView : Components::BaseComponent
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <550,50,750,90>
  method class LoadItemClass( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return null;
  }

  $rect <551,104,751,144>
  method string LoadItemTitle( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <230,290,430,330>
  method void OnItemActivate( arg int32 aItemNo, arg Menu::ItemBase aMenuItem )
  {
    // to suppress warning
    if( null == aMenuItem || aItemNo < 0 )
    {
      // empty body
    }

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,272>;
    preset Color = #000000FF;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <520,0,780,220>;
  }

  // For checkbox menu item
  note group Note7
  {
    attr Bounds = <520,245,780,355>;
  }

  $rect <550,295,750,335>
  method bool LoadItemChecked( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return false;
  }

  $rect <550,160,750,200>
  method bool LoadItemEnabled( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return true;
  }

  // For BT paired device item
  note group Note8
  {
    attr Bounds = <520,380,780,550>;
  }

  $rect <550,430,750,470>
  method bool LoadItemConnected( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return false;
  }

  $rect <550,490,750,530>
  method bool LoadItemValid( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return false;
  }
}

$rect <80,160,320,200>
$output false
class ItemBtPairedDevice : Menu::ItemBase
{
  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <20,10,370,50>;
  }

  $rect <0,80,200,120>
  property bool Connected;

  $rect <0,130,200,170>
  onset Connected
  {
    if( pure Connected != value )
    {
      pure Connected = value;
      CheckBoxButton.Checked = value;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBoxButton
  {
    preset Bounds = <392,15,422,45>;
    preset Enabled = true;
    preset Checked = false;
    preset IconFrame = 0;
    preset Label = "";
    preset Appearance = UIConfig::ToggleButtonConfig;
  }

  $rect <220,80,420,120>
  property bool Valid = true;

  $rect <220,130,420,170>
  onset Valid
  {
    if( pure Valid != value )
    {
      pure Valid = value;
      CheckBoxButton.Visible = value;
    }
  }
}
