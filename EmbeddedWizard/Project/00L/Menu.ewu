$version 10.00

$rect <230,10,430,50>
$output false
class ItemBase : Components::BaseComponent
{
  $rect <0,105,190,145>
  inherited property Bounds = <0,0,480,74>;

  $rect <0,150,190,190>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,9,417,43>;
        HighlightRect.Bounds = <18,0,435,54>;
        ListDivider.Bounds = <0,54,480,56>;
      }
      default:;
    }
  }

  $rect <24,245,224,285>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      HighlightRect.Visible = true;
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      if( Focusable )
      {
        HighlightRect.Visible = false;
      }
    }
    else
    {
      HighlightRect.Visible = false;
    }
  }

  $rect <570,220,760,260>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;
      super( value );

      if( value )
      {
        Title.Color = #FFFFFFFF;
      }
      else
      {
        Title.Color = #646464FF;
      }
    }
  }

  $rect <310,290,540,330>
  inherited method OnShortEnterKeyActivated()
  {
    if( Focusable && Enabled )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <310,140,510,180>
  inherited property PassUpKey = true;

  $rect <310,190,510,230>
  inherited property PassDownKey = true;

  $rect <310,240,510,280>
  inherited property PassHomeKey = true;

  // HardKey Event Handler
  note group Note2
  {
    attr Bounds = <290,100,550,350>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <0,205,250,300>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle HighlightRect
  {
    preset Bounds = <18,0,435,74>;
    preset Color = #FFFFFFFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image ListDivider
  {
    preset Bounds = <0,72,480,74>;
    preset Alignment = Views::ImageAlignment[ScaleToFit];
    preset Bitmap = Resource::ListDivider3;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <790,270,980,310>
  property slot OnActivate = null;

  // Focus frame flash effect
  note group Note3
  {
    attr Bounds = <0,310,250,450>;
  }

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <10,350,240,390>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <10,400,240,440>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  $rect <570,110,760,150>
  method void SetTitle( arg string aTitle )
  {
    if( Title.String != aTitle )
      {
      Title.String = aTitle;
      }
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <37,1,417,69>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium24pt;
    preset Color = #FFFFFFFF;
  }

  $rect <790,110,990,150>
  property bool Focusable = true;

  $rect <790,150,990,190>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
    }
  }

  $rect <790,220,990,260>
  property int32 Height = Menu::ItemHeightTall;

  $reorder Init 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Enabled 1
}

$rect <460,110,660,150>
$output false
class VerticalMenu : Components::BaseComponent
{
  $rect <6,290,206,330>
  inherited property Bounds = <0,0,480,236>;

  $rect <490,220,670,260>
  inherited method UpdateViewState()
  {
    super( aState );

    // set arrow scroll bar
    if( ArrowScrollBarVisible && 0 != ItemNumPerPage )
    {
      var int32 NoOfPages = NoOfItems / ItemNumPerPage;
      if( NoOfItems > ( NoOfPages * ItemNumPerPage ) )
      {
        NoOfPages++;
      }
      ArrowScrollBar.NoOfPages = NoOfPages;
    }
  }

  $rect <220,390,440,430>
  inherited method OnShortDownKeyActivated()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 NextItemIdx = MenuList.SelectedItem + 1;
      if( NextItemIdx < MenuList.NoOfItems )
      {
        var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
        if( null != OwnerMenu )
        {
          MenuList.SelectedItem = NextItemIdx;
          SwitchToPageOfSelectedItem();
          Scrollbar.ViewIdx = MenuList.SelectedItem;
          MoveFocusFrame();
        }
      }
    }
  }

  $rect <220,340,440,380>
  inherited method OnShortUpKeyActivated()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 PrevItemIdx = MenuList.SelectedItem - 1;
      if( PrevItemIdx >= 0 )
      {
        MenuList.SelectedItem = PrevItemIdx;
        SwitchToPageOfSelectedItem();
        Scrollbar.ViewIdx = MenuList.SelectedItem;
        MoveFocusFrame();
      }
    }
  }

  $rect <220,290,440,330>
  inherited property PassHomeKey = true;

  $rect <20,20,160,60>
  object Core::VerticalList MenuList
  {
    preset Bounds = <0,2,435,224>;
    preset Focus = null;
    preset OnLoadItem = OnLoadItemSlot;
    preset SelectedItem = 0;
    preset ItemHeight = Menu::ItemHeightTall;
    preset NoOfItems;
    preset ItemClass = Menu::ItemWrapper;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <460,290,660,330>
  slot OnLoadItemSlot
  {
    var int32 ItemNo = MenuList.Item;
    var Menu::ItemWrapper Item = ( Menu::ItemWrapper )MenuList.View;
    if( null != Item )
    {
      var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
      if( null != OwnerMenu )
      {
        Item.Height = ItemHeight;
        Item.ItemClass = OwnerMenu.LoadItemClass( ItemNo );
        Item.Title = OwnerMenu.LoadItemTitle( ItemNo );
        Item.Enabled = OwnerMenu.LoadItemEnabled( ItemNo );
        Item.OnActivate = OnItemActivateSlot;
        Item.Focusable = Focusable;
        Item.DDModeEnabled = DDModeEnabled;
      }

      if( Menu::ItemCheckbox == Item.ItemClass ||
          Menu::ItemCheckMark == Item.ItemClass )
      {
        Item.Checked = OwnerMenu.LoadItemChecked( ItemNo );
      }

      Item.Bounds.size = point( MenuList.Bounds.w, MenuList.ItemHeight );
    }
  }

  $rect <460,340,660,380>
  slot OnItemActivateSlot
  {
    var Menu::ItemBase MenuItem = null;
    var Menu::ItemWrapper WrapperItem = ( Menu::ItemWrapper )sender;
    if( null != WrapperItem )
    {
      var Core::View Menu = WrapperItem.FindNextView( null, Core::ViewState[] );
      if( null != Menu )
      {
        MenuItem = ( Menu::ItemBase )Menu;
      }
    }

    var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
    if( null != OwnerMenu )
    {
      OwnerMenu.OnItemActivate( MenuList.SelectedItem, MenuItem );
    }
  }

  $rect <490,10,690,50>
  property int32 NoOfItems = 0;

  $rect <490,50,690,90>
  onset NoOfItems
  {
    if( pure NoOfItems != value )
    {
      pure NoOfItems = value;
      MenuList.NoOfItems = value;
      Scrollbar.ListItems = value;

      // set focus frame invisible when there is no item
      if( 0 == value )
      {
        FocusFrame.Visible = false;
      }
      else
      {
        FocusFrame.Visible = true;
      }

      // move focus to the item before the last item when the last item is deleted
      if( MenuList.SelectedItem >= MenuList.NoOfItems )
      {
        MenuList.SelectedItem = MenuList.NoOfItems - 1;
        MoveFocusFrame();
        SwitchToPageOfSelectedItem();
      }

      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Menu::Scrollbar Scrollbar
  {
    preset Bounds = <470,2,480,226>;
    preset Visible = false;
    preset PageItems = 4;
  }

  $rect <0,340,200,380>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    MenuList.InvalidateItems( aFirstItem, aLastItem );
    Scrollbar.ViewIdx = 0;
  }

  $rect <0,390,200,430>
  property bool Focusable = true;

  $rect <0,470,200,510>
  property int32 ItemHeight = Menu::ItemHeightTall;

  $rect <0,510,200,550>
  onset ItemHeight
  {
    if( pure ItemHeight != value )
    {
      pure ItemHeight = value;
      MenuList.ItemHeight = value;
      FocusFrame.Bounds.y2 = 2 + ItemHeight;

      UpdateListHeight();
    }

  }

  $rect <0,570,210,610>
  property int32 ItemNumPerPage = 3;

  $rect <20,20,160,60>
  object Views::Border FocusFrame
  {
    preset Bounds = <18,0,435,76>;
    preset Width = 3;
    preset Color = #0072FFFF;
    preset Visible = false;
  }

  // Note:
  // For the case of 3 rows/page, the height of each row is 74px, and the total height \
  // is 222px.
  // For the case of 4 rows/page, the height of each row is 56px, and the total height \
  // is 224px.
  note group Note2
  {
    attr Bounds = <720,10,1460,110>;
  }

  $rect <230,570,430,610>
  method void MoveFocusFrame()
  {
    var int32 SelectedRow = MenuList.SelectedItem % ItemNumPerPage;
    var rect FocusFrameRect = FocusFrame.Bounds;
    FocusFrameRect.y1 = ItemHeight * SelectedRow;
    FocusFrameRect.y2 = 2 + ItemHeight * ( SelectedRow + 1 );
    FocusFrame.Bounds = FocusFrameRect;
  }

  $rect <0,610,210,650>
  onset ItemNumPerPage
  {
    if( pure ItemNumPerPage != value )
    {
      pure ItemNumPerPage = value;
      UpdateListHeight();
      InvalidateViewState();
    }
  }

  $rect <230,610,430,650>
  method void UpdateListHeight()
  {
    MenuList.Bounds.y2 = MenuList.Bounds.y1 + ItemHeight * ItemNumPerPage;
  }

  $rect <690,290,940,330>
  method void SwitchToPageOfSelectedItem()
  {
    var int32 CurrentPageIdx = ( -1 ) * MenuList.ScrollOffset / MenuList.Bounds.h;
    var int32 PageIdxOfSelectedItem = MenuList.SelectedItem / ItemNumPerPage;

    if( CurrentPageIdx != PageIdxOfSelectedItem )
    {
      FocusFrame.Visible = false;
      PageScrollEffect.Value1 = MenuList.ScrollOffset;
      PageScrollEffect.Value2 = ( -1 ) * PageIdxOfSelectedItem * MenuList.Bounds.h;
      PageScrollEffect.Enabled = true;
    }
  }

  $rect <20,20,160,60>
  object Menu::ArrowScrollBar ArrowScrollBar
  {
    preset Bounds = <441,5,473,221>;
    preset Visible = false;
  }

  $rect <490,120,730,160>
  property bool ArrowScrollBarVisible = false;

  $rect <490,160,730,200>
  onset ArrowScrollBarVisible
  {
    if( pure ArrowScrollBarVisible != value )
    {
      pure ArrowScrollBarVisible = value;
      ArrowScrollBar.Visible = value;
    }
  }

  $rect <690,340,940,380>
  object Effects::Int32Effect PageScrollEffect
  {
    preset OnFinished = OnPageScrolledSlot;
    preset Exponent = 4.19;
    preset Timing = Effects::Timing.Exp_Out;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset InitialDelay = 50;
    preset Outlet = ^MenuList.ScrollOffset;
  }

  $rect <690,390,940,430>
  slot OnPageScrolledSlot
  {
    FocusFrame.Visible = true;

    if( ArrowScrollBarVisible )
    {
      var int32 PageIdxOfSelectedItem = MenuList.SelectedItem / ItemNumPerPage;
      ArrowScrollBar.CurrentPageIdx = PageIdxOfSelectedItem;
    }
  }
}

$rect <230,60,430,100>
$output false
class ItemCheckbox : Menu::ItemBase
{
  $rect <0,230,190,270>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,9,367,43>;
        CheckBoxButton.Bounds = <371,2,421,52>;
      }
      default:;
    }
  }

  $rect <0,170,190,210>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      super( value );
      CheckBoxButton.Enabled = value;
    }
  }

  $rect <220,80,450,120>
  inherited method OnShortEnterKeyActivated()
  {
    super();
    CheckBoxButton.Checked = !CheckBoxButton.Checked;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,386,69>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBoxButton
  {
    preset Bounds = <394,10,444,60>;
    preset Enabled = true;
    preset Checked = false;
    preset IconFrame = 0;
    preset Label = "";
    preset Appearance = UIConfig::CheckBoxConfig;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,120,200,160>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      CheckBoxButton.Checked = value;
    }
  }
}

// This is a GUI component.
$rect <460,60,660,100>
$output false
class ItemWrapper : Core::Group
{
  $rect <0,84,200,124>
  inherited property Bounds = <0,0,480,74>;

  $rect <480,410,660,450>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <480,350,660,390>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      var Menu::ItemBase ItemBase = ( Menu::ItemBase )view;
      if( null != ItemBase )
      {
        ItemBase.Enabled = value;
      }
    }
  }

  $rect <480,290,660,330>
  inherited property Enabled;

  // This is a property.
  $rect <40,290,240,330>
  property class ItemClass = null;

  $rect <40,350,240,390>
  onset ItemClass
  {
    if( pure ItemClass != value )
    {
      // Remember the property's new value.
      pure ItemClass = value;

      // Remove the old embedded item, if any ...
      if( CountViews() > 0 )
      {
        Remove( FindNextView( null, Core::ViewState[] ) );
      }

      var Menu::ItemBase Item = ( Menu::ItemBase )new value;
      Item.Height = Height;
      Item.OnActivate = OnActivateSlot;
      Add( Item, 0 );
    }
  }

  // This is a property.
  $rect <260,290,460,330>
  property string Title = "Title";

  $rect <260,350,460,390>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase MenuItem = ( Menu::ItemBase )view;
      if( MenuItem != null )
      {
        MenuItem.SetTitle( Title );
      }
    }
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,190,200,230>
  property slot OnActivate = null;

  $rect <0,140,200,180>
  slot OnActivateSlot
  {
    postsignal OnActivate;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <20,250,1120,470>;
  }

  // For ItemCheckbox and ItemCheckMark
  note group Note7
  {
    attr Bounds = <20,500,530,650>;
  }

  $rect <40,540,240,580>
  property bool Checked;

  $rect <40,590,240,630>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemCheckbox CheckboxMenuItem = ( Menu::ItemCheckbox )view;
      if( CheckboxMenuItem != null )
      {
        CheckboxMenuItem.Checked = value;
      }
      else
      {
        var Menu::ItemCheckMark CheckMarkMenuItem = ( Menu::ItemCheckMark)view;
        if( null != CheckMarkMenuItem )
        {
          CheckMarkMenuItem.Checked = value;
        }
      }
    }
  }

  $rect <220,140,420,180>
  slot OnEnterHoldSlot
  {
    postsignal OnEnterHold, sender;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <220,190,420,230>
  property slot OnEnterHold = null;

  $rect <670,290,870,330>
  property bool Focusable = true;

  $rect <670,350,870,390>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.Focusable = value;
      }
    }
  }

  $rect <890,290,1090,330>
  property int32 Height;

  $rect <890,350,1090,390>
  property bool DDModeEnabled;

  $rect <890,390,1090,430>
  onset DDModeEnabled
  {
    if( pure DDModeEnabled != value )
    {
      pure DDModeEnabled = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.DDModeEnabled = value;
      }
    }
  }
}

$rect <460,160,660,200>
$output false
class Scrollbar : Core::Group
{
  $rect <60,160,260,200>
  inherited property Bounds = <0,0,10,240>;

  $rect <60,210,260,250>
  inherited method UpdateViewState()
  {
    super( aState );

    if( PageNum > 0 )
    {
      var int32 CurrentPage = ViewIdx / PageItems;
      var int32 BarHeight = int32( float( Bounds.h ) / float( PageNum ) );
      var int32 BarTopY = int32( float( Bounds.h ) * ( float( CurrentPage ) / float( PageNum ) ) );
      Bar.Bounds = rect( Bar.Bounds.x1, BarTopY, Bar.Bounds.x2, BarTopY + BarHeight );
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,10,240>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Track
  {
    preset Point2 = <5,240>;
    preset Point1 = <5,0>;
    preset Width = 3;
    preset Color = #646464FF;
  }

  $rect <490,60,690,100>
  property int32 ViewIdx;

  $rect <490,100,690,140>
  onset ViewIdx
  {
    if( pure ViewIdx != value )
    {
      pure ViewIdx = value;
      InvalidateViewState();
    }
  }

  $rect <60,60,260,100>
  property int32 PageItems;

  $rect <60,100,260,140>
  onset PageItems
  {
    if( pure PageItems != value )
    {
      pure PageItems = value;
      UpdatePageNum();
    }
  }

  $rect <280,60,480,100>
  property int32 ListItems;

  $rect <280,100,480,140>
  onset ListItems
  {
    if( pure ListItems != value )
    {
      pure ListItems = value;
      UpdatePageNum();
      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Bounds = <0,50,10,80>;
  }

  $rect <710,60,910,100>
  var int32 PageNum;

  $rect <710,100,910,140>
  method void UpdatePageNum()
  {
    if( PageItems >= ListItems )
    {
      Bar.Visible = false;
      Track.Visible = false;
      PageNum = 0;
    }
    else if( PageItems > 0 )
    {
      PageNum = ListItems / PageItems;
      if( ListItems > ( PageNum * PageItems ) )
      {
        PageNum = PageNum + 1;
      }

      Bar.Visible = true;
      Track.Visible = true;
    }
  }
}

$rect <460,10,660,50>
$output false
class BaseMenuView : Components::BaseMainBG
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <550,50,750,90>
  method class LoadItemClass( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return null;
  }

  $rect <551,104,751,144>
  method string LoadItemTitle( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <230,290,430,330>
  method void OnItemActivate( arg int32 aItemNo, arg Menu::ItemBase aMenuItem )
  {
    // to suppress warning
    if( null == aMenuItem || aItemNo < 0 )
    {
      // empty body
    }

  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <520,0,780,220>;
  }

  // For checkbox menu item
  note group Note7
  {
    attr Bounds = <520,245,780,355>;
  }

  $rect <550,295,750,335>
  method bool LoadItemChecked( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return false;
  }

  $rect <550,160,750,200>
  method bool LoadItemEnabled( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return true;
  }

  $rect <20,20,160,60>
  object Menu::VerticalMenu Menu
  {
    preset Bounds = <0,36,480,272>;
    preset DDModeEnabled = false;
    preset NoOfItems = 0;
    preset ArrowScrollBarVisible = false;
  }

  $reorder BlackBG 1
  $reorder LoadItemClass 1
  $reorder LoadItemTitle 1
  $reorder OnItemActivate 1
}

$rect <690,10,910,50>
$output false
class PushButton : Components::BaseComponent
{
  $rect <10,60,210,100>
  inherited property Bounds = <0,0,150,40>;

  $rect <520,10,720,50>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      Background.Color = #FFFFFFCD; // 0xCD = 205 : 80% alpha
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      Background.Color = #00000026; // 0x26 = 38 : 15% alpha
      if( Focusable )
      {
        FocusBorder.Color = #0072FFFF;
        FocusBorder.Width = 3;
      }
    }
    else
    {
      Background.Color = #00000026;
      FocusBorder.Color = #727171FF;
      FocusBorder.Width = 2;
    }
  }

  $rect <260,200,490,240>
  inherited method OnShortEnterKeyActivated()
  {
    if( false == KeyHandler.Repetition && Focusable && ButtonEnabled )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      // To avoid sending OnActivate more than once when short pressing enter consecutively within the very short period,
      // disable KeyHandler before blinking the background and enable KeyHandler again after the blink ends.
      KeyHandler.Enabled = false;
      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <260,50,460,90>
  inherited property PassUpKey = true;

  $rect <260,150,460,190>
  inherited property PassDownKey = true;

  $rect <260,100,460,140>
  inherited property PassHomeKey = true;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,40>;
    preset Color = #00000026;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,4,150,38>;
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <10,110,210,150>
  property string Title = "";

  $rect <10,150,210,190>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;
      TitleText.String = value;
    }
  }

  $rect <790,110,990,150>
  slot OnEnterReleaseSlot
  {
    if( false == KeyHandler.Repetition && Focusable && ButtonEnabled )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      // To avoid sending OnActivate more than once when short pressing enter consecutively within the very short period,
      // disable KeyHandler before blinking the background and enable KeyHandler again after the blink ends.
      KeyHandler.Enabled = false;
      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <520,60,720,100>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  $rect <520,110,720,150>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;

    KeyHandler.Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Border FocusBorder
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,40>;
    preset Width = 2;
    preset Color = #0072FFFF;
  }

  $rect <10,210,210,250>
  property bool Focusable = true;

  $rect <10,250,210,290>
  onset Focusable
  {
    trace "OnSetFocusable: ", value;
    if( pure Focusable != value )
    {
      pure Focusable = value;
      if( value )
      {
        FocusBorder.Color = #0072FFFF;
      }
      else
      {
        FocusBorder.Color = #727171FF;
      }
    }
  }

  $rect <10,300,210,340>
  property slot OnActivate;

  $rect <520,170,720,210>
  property bool ButtonEnabled = true;

  $rect <520,210,720,250>
  onset ButtonEnabled
  {
    if( pure ButtonEnabled != value )
    {
      pure ButtonEnabled = value;

      if( value )
      {
        TitleText.Color = #FFFFFFFF;
      }
      else
      {
        TitleText.Color = #646464FF;
      }
    }
  }

  // Key Settings
  note group Note3
  {
    attr Bounds = <240,10,500,260>;
  }
}

$rect <690,60,910,100>
$output false
class UpDownPushButtonSet : Components::BaseComponent
{
  $rect <0,120,200,160>
  inherited property Bounds = <0,0,150,83>;

  $rect <2,210,230,250>
  inherited method OnShortDownKeyActivated()
  {
    Focus = DownButton;
  }

  $rect <0,170,230,210>
  inherited method OnShortUpKeyActivated()
  {
    Focus = UpButton;
  }

  $rect <20,20,160,60>
  object Menu::PushButton UpButton
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz];
    preset Bounds = <0,0,150,40>;
    preset PassMagicKey = true;
    preset Title = "Cancel";
    preset OnActivate = OnActivateSlot;
  }

  $rect <20,20,160,60>
  object Menu::PushButton DownButton
  {
    preset Layout = Core::Layout[AlignToBottom, ResizeHorz];
    preset Bounds = <0,43,150,83>;
    preset PassMagicKey = true;
    preset Title = "OK";
    preset OnActivate = OnActivateSlot;
  }

  $rect <0,370,200,410>
  slot OnActivateSlot
  {
    if( DownButton == sender )
    {
      postsignal OnDownButtonActivated;
    }
    else if( UpButton == sender )
    {
      postsignal OnUpButtonActivated;
    }
    else
    {
      // empty body
    }
  }

  $rect <2,260,220,300>
  property slot OnUpButtonActivated;

  $rect <2,300,220,340>
  property slot OnDownButtonActivated;

  $rect <340,170,540,210>
  property string UpButtonTitle = Strings::GEN_cancel;

  $rect <340,210,540,250>
  onset UpButtonTitle
  {
    if( pure UpButtonTitle != value )
    {
      pure UpButtonTitle = value;
      UpButton.TitleText.String = value;
    }
  }

  $rect <340,260,540,300>
  property string DownButtonTitle = Strings::GEN_ok;

  $rect <340,300,550,340>
  onset DownButtonTitle
  {
    if( pure DownButtonTitle != value )
    {
      pure DownButtonTitle = value;
      DownButton.TitleText.String = value;
    }
  }

  $rect <650,170,850,210>
  property bool UpButtonEnabled = true;

  $rect <650,210,850,250>
  onset UpButtonEnabled
  {
    if( pure UpButtonEnabled != value )
    {
      pure UpButtonEnabled = value;
      UpButton.ButtonEnabled = value;
    }
  }

  $rect <650,280,850,320>
  property bool DownButtonEnabled = true;

  $rect <650,320,850,360>
  onset DownButtonEnabled
  {
    if( pure DownButtonEnabled != value )
    {
      pure DownButtonEnabled = value;
      DownButton.ButtonEnabled = value;
    }
  }
}

$rect <230,110,430,150>
$output false
class ItemCheckMark : Menu::ItemBase
{
  $rect <220,80,410,120>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,9,367,43>;
        CheckMark.Bounds = <371,2,421,52>;
      }
      default:;
    }
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,364,69>;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,120,200,160>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      CheckMark.Visible = value;
    }
  }

  $rect <20,20,160,60>
  object Views::Image CheckMark
  {
    preset Bounds = <371,9,421,59>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::CheckMark;
    preset Visible = false;
  }
}

$rect <10,10,210,50>
$output false
const int32 ItemHeightTall = 74;

$rect <10,60,210,100>
$output false
const int32 ItemHeightSmall = 56;

$rect <460,210,660,250>
$output false
class ArrowScrollBar : Core::Group
{
  $rect <50,10,230,50>
  inherited property Bounds = <0,0,32,216>;

  $rect <50,50,230,90>
  inherited method UpdateViewState()
  {
    super( aState );

    if( 0 == NoOfPages )
    {
      UpArrowIcon.Visible = false;
      DownArrowIcon.Visible = false;
    }
    else
    {
      if( 0 == CurrentPageIdx )
      {
        UpArrowIcon.Visible = false;
      }
      else
      {
        UpArrowIcon.Visible = true;
      }

      if( ( NoOfPages - 1 ) == CurrentPageIdx )
      {
        DownArrowIcon.Visible = false;
      }
      else
      {
        DownArrowIcon.Visible = true;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image UpArrowIcon
  {
    preset Bounds = <0,0,32,32>;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <20,20,160,60>
  object Views::Image DownArrowIcon
  {
    preset Bounds = <0,184,32,216>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <250,10,450,50>
  property int32 CurrentPageIdx;

  $rect <250,50,450,90>
  onset CurrentPageIdx
  {
    if ( pure CurrentPageIdx != value )
    {
      pure CurrentPageIdx = value;
      InvalidateViewState();
    }
  }

  $rect <480,10,680,50>
  property int32 NoOfPages;

  $rect <480,50,680,90>
  onset NoOfPages
  {
    if ( pure NoOfPages != value )
    {
      pure NoOfPages = value;
      InvalidateViewState();
    }
  }
}
