$version 10.00

$rect <10,10,250,50>
$output false
class ItemBase : Core::Group
{
  $rect <0,105,190,145>
  inherited property Bounds = <0,0,480,74>;

  $rect <474,140,674,180>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      HighlightRect.Visible = true;
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      if( Focusable )
      {
        HighlightRect.Visible = false;
      }
    }
    else
    {
      HighlightRect.Visible = false;
    }
  }

  $rect <0,255,190,295>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;
      if( value )
      {
        Title.Color = #FFFFFFFF;
      }
      else
      {
        Title.Color = #646464FF;
      }
    }
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <210,100,430,375>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <450,100,700,195>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle HighlightRect
  {
    preset Bounds = <18,0,435,74>;
    preset Color = #FFFFFFFF;
    preset Visible = false;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <220,140,420,180>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnRelease = OnEnterReleaseSlot;
    preset OnPress = null;
    preset Filter = Core::KeyCode.Ok;
    preset OnHold = OnEnterHoldSlot;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <220,195,420,235>
  slot OnEnterReleaseSlot
  {
    trace "OnEnterRelease, repetition: ", KeyHandler.Repetition;

    if( false == KeyHandler.Repetition && Focusable )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <20,20,160,60>
  object Views::Image ListDivider
  {
    preset Bounds = <0,72,480,74>;
    preset Alignment = Views::ImageAlignment[ScaleToFit];
    preset Bitmap = Resource::ListDivider3;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,155,190,195>
  property slot OnActivate = null;

  // Focus frame flash effect
  note group Note3
  {
    attr Bounds = <450,235,700,375>;
  }

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <460,275,690,315>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <460,325,690,365>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  $rect <0,205,190,245>
  method void SetTitle( arg string aTitle )
  {
    if( Title.String != aTitle )
      {
      Title.String = aTitle;
      }
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <37,1,417,69>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::FontNotoSansCjkJp36;
    preset Color = #FFFFFFFF;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <220,255,420,295>
  slot OnEnterHoldSlot
  {
    trace "OnEnterHold: ", KeyHandler.RepetitionCount;
    postsignal OnEnterHold, KeyHandler;
  }

  $rect <220,315,420,355>
  property slot OnEnterHold;

  $rect <0,395,200,435>
  property bool Focusable = true;

  $rect <0,435,200,475>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
    }
  }

  $reorder Init 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Enabled 1
}

$rect <80,60,320,100>
$output false
class ItemBaseLower : Menu::ItemBase
{
  $rect <10,90,210,130>
  inherited property Bounds = <0,0,480,56>;

  $rect <20,20,160,60>
  inherited object HighlightRect
  {
    preset Bounds = <18,0,435,54>;
  }

  $rect <20,20,160,60>
  inherited object ListDivider
  {
    preset Bounds = <0,54,480,56>;
    preset Bitmap = Resource::ListDivider4;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,9,417,43>;
  }
}

$rect <10,360,250,400>
$output false
class VerticalMenu : Components::BaseComponent
{
  $rect <6,290,206,330>
  inherited property Bounds = <0,0,480,236>;

  $rect <220,390,440,430>
  inherited slot OnLongKeyPressed
  {
    signal PassKeyHold, sender;
  }

  $rect <220,340,440,380>
  inherited method OnShortDownKeyPressed()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 NextItemIdx = MenuList.SelectedItem + 1;
      if( NextItemIdx < MenuList.NoOfItems )
      {
        var Menu::ItemWrapper Item = ( Menu::ItemWrapper )MenuList.GetViewForItem( NextItemIdx );
        if( null != Item && Item.Enabled )
        {
          MenuList.SelectedItem = NextItemIdx;
          SwitchToPageOfSelectedItem();
          Scrollbar.ViewIdx = MenuList.SelectedItem;
          MoveFocusFrame();
        }
      }
    }
  }

  $rect <220,290,440,330>
  inherited method OnShortUpKeyPressed()
  {
    if( Owner.IsCurrentDialog() )
    {
      var int32 PrevItemIdx = MenuList.SelectedItem - 1;
      if( PrevItemIdx >= 0 )
      {
        MenuList.SelectedItem = PrevItemIdx;
        SwitchToPageOfSelectedItem();
        Scrollbar.ViewIdx = MenuList.SelectedItem;
        MoveFocusFrame();
      }
    }
  }

  $rect <20,20,160,60>
  object Core::VerticalList MenuList
  {
    preset Bounds = <0,2,435,224>;
    preset Focus = null;
    preset OnLoadItem = OnLoadItemSlot;
    preset SelectedItem = 0;
    preset ItemHeight = 74;
    preset NoOfItems;
    preset ItemClass = Menu::ItemWrapper;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <460,290,660,330>
  slot OnLoadItemSlot
  {
    var int32 ItemNo = MenuList.Item;
    var Menu::ItemWrapper Item = ( Menu::ItemWrapper )MenuList.View;
    if( null != Item )
    {
      var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
      if( null != OwnerMenu )
      {
        Item.ItemClass = OwnerMenu.LoadItemClass( ItemNo );
        Item.Title = OwnerMenu.LoadItemTitle( ItemNo );
        Item.Enabled = OwnerMenu.LoadItemEnabled( ItemNo );
        Item.OnActivate = OnItemActivateSlot;
        Item.OnEnterHold = OnLongKeyPressed;
        Item.Focusable = Focusable;
      }

      if( Menu::ItemCheckbox == Item.ItemClass ||
          Menu::ItemCheckboxLower == Item.ItemClass ||
          Menu::ItemCheckMark == Item.ItemClass ||
          Menu::ItemCheckMarkLower == Item.ItemClass )
      {
        Item.Checked = OwnerMenu.LoadItemChecked( ItemNo );
      }

      Item.Bounds.size = point( MenuList.Bounds.w, MenuList.ItemHeight );
    }
  }

  $rect <460,340,660,380>
  slot OnItemActivateSlot
  {
    var Menu::ItemBase MenuItem = null;
    var Menu::ItemWrapper WrapperItem = ( Menu::ItemWrapper )sender;
    if( null != WrapperItem )
    {
      var Core::View Menu = WrapperItem.FindNextView( null, Core::ViewState[] );
      if( null != Menu )
      {
        MenuItem = ( Menu::ItemBase )Menu;
      }
    }

    var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
    if( null != OwnerMenu )
    {
      OwnerMenu.OnItemActivate( MenuList.SelectedItem, MenuItem );
    }
  }

  $rect <490,10,690,50>
  property int32 NoOfItems = 0;

  $rect <490,60,690,100>
  onset NoOfItems
  {
    if( pure NoOfItems != value )
    {
      pure NoOfItems = value;
      MenuList.NoOfItems = value;
      Scrollbar.ListItems = value;
      if( 0 == NoOfItems )
      {
        FocusFrame.Visible = false;
      }
      else
      {
        FocusFrame.Visible = true;
      }
    }
  }

  $rect <20,20,160,60>
  object Menu::Scrollbar Scrollbar
  {
    preset Bounds = <470,2,480,226>;
    preset Visible = false;
    preset PageItems = 4;
  }

  $rect <0,340,200,380>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    MenuList.InvalidateItems( aFirstItem, aLastItem );
    Scrollbar.ViewIdx = 0;
  }

  $rect <0,390,200,430>
  property bool Focusable = true;

  $rect <0,470,200,510>
  property int32 ItemHeight = 74;

  $rect <0,510,200,550>
  onset ItemHeight
  {
    if( pure ItemHeight != value )
    {
      pure ItemHeight = value;
      MenuList.ItemHeight = value;
      FocusFrame.Bounds.y2 = 2 + ItemHeight;

      UpdateListHeight();
    }

  }

  $rect <0,570,210,610>
  property int32 ItemNumPerPage = 3;

  $rect <20,20,160,60>
  object Views::Border FocusFrame
  {
    preset Bounds = <18,0,435,76>;
    preset Width = 3;
    preset Color = #0072FFFF;
  }

  // Note:
  //
  // For the case of 3 rows/page, the height of each row is 74px, and the total height \
  // is 222px.
  // For the case of 4 rows/page, the height of each row is 56px, and the total height \
  // is 224px.
  note group Note2
  {
    attr Bounds = <720,10,1460,150>;
  }

  $rect <220,470,420,510>
  method void MoveFocusFrame()
  {
    var int32 SelectedRow = MenuList.SelectedItem % ItemNumPerPage;
    var rect FocusFrameRect = FocusFrame.Bounds;
    FocusFrameRect.y1 = ItemHeight * SelectedRow;
    FocusFrameRect.y2 = 2 + ItemHeight * ( SelectedRow + 1 );
    FocusFrame.Bounds = FocusFrameRect;
  }

  $rect <0,610,210,650>
  onset ItemNumPerPage
  {
    if( pure ItemNumPerPage != value )
    {
      pure ItemNumPerPage = value;
      UpdateListHeight();
    }

  }

  $rect <220,510,420,550>
  method void UpdateListHeight()
  {
    MenuList.Bounds.y2 = MenuList.Bounds.y1 + ItemHeight * ItemNumPerPage;
  }

  $rect <690,290,940,330>
  method void SwitchToPageOfSelectedItem()
  {
    var int32 CurrentPageIdx = MenuList.ScrollOffset / MenuList.Bounds.h;
    var int32 PageIdxOfSelectedItem = MenuList.SelectedItem / ItemNumPerPage;

    if( CurrentPageIdx != PageIdxOfSelectedItem )
    {
      MenuList.ScrollOffset = ( -1 ) * PageIdxOfSelectedItem * MenuList.Bounds.h;
    }
  }
}

$rect <80,110,320,150>
$output false
class ItemCheckbox : Menu::ItemBase
{
  $rect <0,170,190,210>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      super( value );
      CheckBoxButton.Enabled = value;
    }
  }

  $rect <200,80,400,120>
  inherited slot OnEnterReleaseSlot
  {
    super( sender );
    CheckBoxButton.Checked = !CheckBoxButton.Checked;

  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,386,69>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBoxButton
  {
    preset Bounds = <394,10,444,60>;
    preset Enabled = true;
    preset Checked = false;
    preset IconFrame = 0;
    preset Label = "";
    preset Appearance = UIConfig::CheckBoxConfig;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,120,200,160>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      CheckBoxButton.Checked = value;
    }
  }
}

// This is a GUI component.
$rect <10,310,250,350>
$output false
class ItemWrapper : Core::Group
{
  $rect <0,84,200,124>
  inherited property Bounds = <0,0,480,74>;

  $rect <480,410,660,450>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <480,350,660,390>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      var Menu::ItemBaseLower ItemRight = ( Menu::ItemBaseLower )view;
      if( null != ItemRight )
      {
        ItemRight.Enabled = value;
      }
      else
      {
        var Menu::ItemCheckbox ItemCheck = ( Menu::ItemCheckbox )view;
        if( null != ItemCheck )
        {
          ItemCheck.Enabled = value;
        }
        else
        {
          var Menu::ItemBase Item = ( Menu::ItemBase )view;
          if( null != Item )
          {
            Item.Enabled = value;
          }
        }
      }
    }
  }

  $rect <480,290,660,330>
  inherited property Enabled;

  // This is a property.
  $rect <40,290,240,330>
  property class ItemClass = null;

  $rect <40,350,240,390>
  onset ItemClass
  {
    if( pure ItemClass == value )
      return;

    // Remember the property's new value.
    pure ItemClass = value;

    // Remove the old embedded item, if any ...
    if( CountViews() > 0 )
    {
      Remove( FindNextView( null, Core::ViewState[] ) );
    }

    var Menu::ItemBase Item = ( Menu::ItemBase )new value;
    Item.OnActivate = OnActivateSlot;
    Item.OnEnterHold = OnEnterHoldSlot;
    Add( Item, 0 );
  }

  // This is a property.
  $rect <260,290,460,330>
  property string Title = "Title";

  $rect <260,350,460,390>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase MenuItem = ( Menu::ItemBase )view;
      if( MenuItem != null )
      {
        MenuItem.SetTitle( Title );
      }
    }
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,190,200,230>
  property slot OnActivate = null;

  $rect <0,140,200,180>
  slot OnActivateSlot
  {
    postsignal OnActivate;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <20,250,890,470>;
  }

  // For ItemCheckbox and ItemCheckMark
  note group Note7
  {
    attr Bounds = <20,500,530,650>;
  }

  $rect <40,540,240,580>
  property bool Checked;

  $rect <40,590,240,630>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemCheckbox CheckboxMenuItem = ( Menu::ItemCheckbox )view;
      if( CheckboxMenuItem != null )
      {
        CheckboxMenuItem.Checked = value;
      }
      else
      {
        var Menu::ItemCheckMark CheckMarkMenuItem = ( Menu::ItemCheckMark)view;
        if( null != CheckMarkMenuItem )
        {
          CheckMarkMenuItem.Checked = value;
        }
      }
    }
  }

  $rect <220,140,420,180>
  slot OnEnterHoldSlot
  {
    postsignal OnEnterHold, sender;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <220,190,420,230>
  property slot OnEnterHold = null;

  $rect <670,290,870,330>
  property bool Focusable = true;

  $rect <670,350,870,390>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.Focusable = value;
      }
    }
  }
}

$rect <510,10,710,50>
$output false
class Scrollbar : Core::Group
{
  $rect <60,160,260,200>
  inherited property Bounds = <0,0,10,240>;

  $rect <60,210,260,250>
  inherited method UpdateViewState()
  {
    super( aState );

    if( PageNum > 0 )
    {
      var int32 CurrentPage = ViewIdx / PageItems;
      var int32 BarHeight = int32( float( Bounds.h ) / float( PageNum ) );
      var int32 BarTopY = int32( float( Bounds.h ) * ( float( CurrentPage ) / float( PageNum ) ) );
      Bar.Bounds = rect( Bar.Bounds.x1, BarTopY, Bar.Bounds.x2, BarTopY + BarHeight );
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,10,240>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Track
  {
    preset Point2 = <5,240>;
    preset Point1 = <5,0>;
    preset Width = 3;
    preset Color = #646464FF;
  }

  $rect <490,60,690,100>
  property int32 ViewIdx;

  $rect <490,100,690,140>
  onset ViewIdx
  {
    if( pure ViewIdx != value )
    {
      pure ViewIdx = value;
      InvalidateViewState();
    }
  }

  $rect <60,60,260,100>
  property int32 PageItems;

  $rect <60,100,260,140>
  onset PageItems
  {
    if( pure PageItems != value )
    {
      pure PageItems = value;
      UpdatePageNum();
    }
  }

  $rect <280,60,480,100>
  property int32 ListItems;

  $rect <280,100,480,140>
  onset ListItems
  {
    if( pure ListItems != value )
    {
      pure ListItems = value;
      UpdatePageNum();
      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Bounds = <0,50,10,80>;
  }

  $rect <710,60,910,100>
  var int32 PageNum;

  $rect <710,100,910,140>
  method void UpdatePageNum()
  {
    if( PageItems >= ListItems )
    {
      Bar.Visible = false;
      Track.Visible = false;
      PageNum = 0;
    }
    else if( PageItems > 0 )
    {
      PageNum = ListItems / PageItems;
      if( ListItems > ( PageNum * PageItems ) )
      {
        PageNum = PageNum + 1;
      }

      Bar.Visible = true;
      Track.Visible = true;
    }
  }
}

$rect <510,60,750,100>
$output false
class BaseMenuView : Components::BaseComponent
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <550,50,750,90>
  method class LoadItemClass( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return null;
  }

  $rect <551,104,751,144>
  method string LoadItemTitle( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <230,290,430,330>
  method void OnItemActivate( arg int32 aItemNo, arg Menu::ItemBase aMenuItem )
  {
    // to suppress warning
    if( null == aMenuItem || aItemNo < 0 )
    {
      // empty body
    }

  }

  $rect <20,20,160,60>
  object Views::Rectangle BlackBG
  {
    preset Bounds = <0,32,480,182>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image MainBottomBG
  {
    preset Bounds = <0,182,480,272>;
    preset Bitmap = Resource::MainBG;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <520,0,780,220>;
  }

  // For checkbox menu item
  note group Note7
  {
    attr Bounds = <520,245,780,355>;
  }

  $rect <550,295,750,335>
  method bool LoadItemChecked( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return false;
  }

  $rect <550,160,750,200>
  method bool LoadItemEnabled( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return true;
  }
}

$rect <140,260,380,300>
$output false
class ItemCheckMarkLower : Menu::ItemCheckMark
{
  $rect <0,80,200,120>
  inherited property Bounds = <0,0,480,56>;

  $rect <20,20,160,60>
  inherited object HighlightRect
  {
    preset Bounds = <18,0,435,54>;
  }

  $rect <20,20,160,60>
  inherited object ListDivider
  {
    preset Bounds = <0,54,480,56>;
    preset Bitmap = Resource::ListDivider4;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,9,367,43>;
    preset Ellipsis = true;
    preset String = "";
  }

  $rect <20,20,160,60>
  inherited object CheckMark
  {
    preset Bounds = <371,2,421,52>;
    preset Visible = false;
  }
}

$rect <140,160,380,200>
$output false
class ItemCheckboxLower : Menu::ItemCheckbox
{
  $rect <0,70,200,110>
  inherited property Bounds = <0,0,480,56>;

  $rect <20,20,160,60>
  inherited object HighlightRect
  {
    preset Bounds = <18,0,435,54>;
  }

  $rect <20,20,160,60>
  inherited object ListDivider
  {
    preset Bounds = <0,54,480,56>;
    preset Bitmap = Resource::ListDivider4;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,9,367,43>;
    preset WrapText = true;
  }

  $rect <20,20,160,60>
  inherited object CheckBoxButton
  {
    preset Bounds = <371,2,421,52>;
  }

  $reorder Checked 3
  $reorder OnSetChecked 3
}

$rect <860,10,1060,50>
$output false
class PushButton : Core::Group
{
  $rect <10,60,210,100>
  inherited property Bounds = <0,0,150,40>;

  $rect <470,10,670,50>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      Background.Visible = true;
      Background.Color = #FFFFFFCD; // 0xCD = 205 : 80% alpha
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      Background.Visible = false;

      if( Focusable )
      {
        FocusBorder.Color = #0072FFFF;
        FocusBorder.Width = 3;
      }
    }
    else
    {
      Background.Visible = false;
      FocusBorder.Color = #727171FF;
      FocusBorder.Width = 2;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,150,40>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Bounds = <0,4,150,38>;
    preset String = "";
    preset Font = Fonts::FontNotoSansCjkJp32;
  }

  $rect <10,110,210,150>
  property string Title = "";

  $rect <10,150,210,190>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;
      TitleText.String = value;
    }
  }

  $rect <250,60,450,100>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnRelease = OnEnterReleaseSlot;
    preset Filter = Core::KeyCode.Ok;
  }

  $rect <250,110,450,150>
  slot OnEnterReleaseSlot
  {
    trace "OnEnterRelease, repetition: ", KeyHandler.Repetition;

    if( false == KeyHandler.Repetition && Focusable )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <470,60,670,100>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  $rect <470,110,670,150>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  $rect <20,20,160,60>
  object Views::Border FocusBorder
  {
    preset Bounds = <0,0,150,40>;
    preset Width = 3;
    preset Color = #0072FFFF;
  }

  $rect <10,210,210,250>
  property bool Focusable = true;

  $rect <10,250,210,290>
  onset Focusable
  {
    trace "OnSetFocusable: ", value;
    if( pure Focusable != value )
    {
      pure Focusable = value;
      if( value )
      {
        FocusBorder.Color = #0072FFFF;
      }
      else
      {
        FocusBorder.Color = #727171FF;
      }
    }
  }

  $rect <250,170,450,210>
  property slot OnActivate;
}

$rect <860,60,1080,100>
$output false
class UpDownPushButtonSet : Components::BaseComponent
{
  $rect <0,120,200,160>
  inherited property Bounds = <0,0,150,83>;

  $rect <2,210,230,250>
  inherited method OnShortDownKeyPressed()
  {
    Focus = DownButton;
  }

  $rect <0,170,230,210>
  inherited method OnShortUpKeyPressed()
  {
    Focus = UpButton;
  }

  $rect <20,20,160,60>
  object Menu::PushButton UpButton
  {
    preset Bounds = <0,0,150,40>;
    preset Title = "Cancel";
    preset OnActivate = OnActivateSlot;
  }

  $rect <20,20,160,60>
  object Menu::PushButton DownButton
  {
    preset Bounds = <0,43,150,83>;
    preset Title = "OK";
    preset OnActivate = OnActivateSlot;
  }

  $rect <0,370,200,410>
  slot OnActivateSlot
  {
    if( DownButton == sender )
    {
      postsignal OnDownButtonReleased;
    }
    else if( UpButton == sender )
    {
      postsignal OnUpButtonReleased;
    }
    else
    {
      // empty body
    }
  }

  $rect <2,260,220,300>
  property slot OnUpButtonReleased;

  $rect <2,300,220,340>
  property slot OnDownButtonReleased;

  $rect <340,170,540,210>
  property string UpButtonTitle = "Cancel";

  $rect <340,210,540,250>
  onset UpButtonTitle
  {
    if( pure UpButtonTitle != value )
    {
      pure UpButtonTitle = value;
      UpButton.TitleText.String = value;
    }
  }

  $rect <340,260,540,300>
  property string DownButtonTitle = "OK";

  $rect <340,300,550,340>
  onset DownButtonTitle
  {
    if( pure DownButtonTitle != value )
    {
      pure DownButtonTitle = value;
      DownButton.TitleText.String = value;
    }
  }
}

$rect <80,210,320,250>
$output false
class ItemCheckMark : Menu::ItemBase
{
  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,364,69>;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,120,200,160>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      CheckMark.Visible = value;
    }
  }

  $rect <20,20,160,60>
  object Views::Image CheckMark
  {
    preset Bounds = <371,9,421,59>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::CheckMark;
    preset Visible = false;
  }
}
