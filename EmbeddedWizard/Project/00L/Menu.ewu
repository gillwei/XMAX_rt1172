$version 11.00

$rect <230,10,430,50>
$output false
class ItemBase : Components::BaseComponent
{
  $rect <0,105,190,145>
  inherited property Bounds = <0,0,480,74>;

  $rect <570,220,760,260>
  inherited onset Enabled
  {
    super( value );

    if( value )
    {
      Title.Color = Color::WHITE;
    }
    else
    {
      Title.Color = Color::GRAY_FOR_DISABLED;
    }
  }

  $rect <0,150,190,190>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,3,417,45>;
        HighlightRect.Bounds = <18,0,435,54>;
        ListDivider.Bounds = <0,54,480,56>;
      }
      default:;
    }
  }

  $rect <24,245,224,285>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      HighlightRect.Visible = true;
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      if( Focusable )
      {
        HighlightRect.Visible = false;
      }
    }
    else
    {
      HighlightRect.Visible = false;
    }
  }

  $rect <310,290,540,330>
  inherited method OnShortEnterKeyActivated()
  {
    if( Focusable && Enabled )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <310,140,510,180>
  inherited property PassUpKey = true;

  $rect <310,190,510,230>
  inherited property PassDownKey = true;

  $rect <310,240,510,280>
  inherited property PassHomeKey = true;

  // HardKey Event Handler
  note group Note2
  {
    attr Bounds = <290,100,550,400>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <0,205,250,300>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle HighlightRect
  {
    preset Bounds = <18,0,435,74>;
    preset Color = #FFFFFFFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image ListDivider
  {
    preset Bounds = <0,72,480,74>;
    preset Alignment = Views::ImageAlignment[ScaleToFit];
    preset Bitmap = Resource::ListDivider3;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <790,270,980,310>
  property slot OnActivate = null;

  // Focus frame flash effect
  note group Note3
  {
    attr Bounds = <0,310,250,450>;
  }

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <10,350,240,390>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <10,400,240,440>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  $rect <570,110,760,150>
  method void SetTitle( arg string aTitle )
  {
    if( Title.String != aTitle )
      {
      Title.String = aTitle;
      }
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <37,1,417,69>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
    preset Color = #FFFFFFFF;
  }

  $rect <790,110,990,150>
  property bool Focusable = true;

  $rect <790,150,990,190>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
    }
  }

  $rect <790,220,990,260>
  property int32 Height = Menu::ItemHeightTall;

  $rect <310,340,540,380>
  inherited method OnLongEnterKeyActivated()
  {
    if( Components::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      postsignal OnLongEnterKeyActivate;
    }
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <790,320,1010,360>
  property slot OnLongEnterKeyActivate = null;

  $reorder Init 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Enabled 1
  $reorder OnLongHomeKeyActivated 1
  $reorder PassUpKey 1
  $reorder PassDownKey 1
  $reorder PassHomeKey 1
  $reorder PassEnterKey 1
  $reorder OnShortMagicKeyActivated 1
  $reorder PassMagicKey 1
  $reorder DDModeEnabled 1
  $reorder IsDDModeEffected 1
  $reorder OnSetDDModeEnabled 1
  $reorder OnDownKeyReleased 1
  $reorder OnUpKeyReleased 1
  $reorder MagicKeyEnabled 1
  $reorder OnSetMagicKeyEnabled 1
  $reorder Note2 1
  $reorder Note4 1
  $reorder HighlightRect 1
  $reorder ListDivider 1
  $reorder OnActivate 1
  $reorder Note3 1
  $reorder FocusFrameFlashTimer 1
  $reorder OnFocusFrameFlashTimer 1
  $reorder SetTitle 1
  $reorder Title 1
  $reorder Focusable 1
  $reorder OnSetFocusable 1
  $reorder Height 1
}

$rect <460,110,660,150>
$output false
class VerticalMenu : Components::BaseComponent
{
  $rect <6,290,206,330>
  inherited property Bounds = <0,0,480,236>;

  $rect <3,246,183,286>
  inherited method UpdateViewState()
  {
    super( aState );

    // set arrow scroll bar
    if( ArrowScrollBarVisible && 0 != ItemNumPerPage )
    {
      var int32 NoOfPages = NoOfItems / ItemNumPerPage;
      if( NoOfItems > ( NoOfPages * ItemNumPerPage ) )
      {
        NoOfPages++;
      }
      ArrowScrollBar.NoOfPages = NoOfPages;
    }

    if( ScrollbarVisible )
    {
      if( ItemNumPerPage < NoOfItems )
      {
        Scrollbar.Visible = true;
      }
      else
      {
        Scrollbar.Visible = false;
      }
    }
  }

  $rect <220,390,440,430>
  inherited method OnShortDownKeyActivated()
  {
    if( Owner.IsCurrentDialog() )
    {
      SelectedItem = MenuList.SelectedItem + 1;
    }
  }

  $rect <220,340,440,380>
  inherited method OnShortUpKeyActivated()
  {
    if( Owner.IsCurrentDialog() )
    {
      SelectedItem = MenuList.SelectedItem - 1;
    }
  }

  $rect <220,290,440,330>
  inherited property PassHomeKey = true;

  $rect <20,20,160,60>
  object Core::VerticalList MenuList
  {
    preset Bounds = <0,2,444,224>;
    preset Focus = null;
    preset OnLoadItem = OnLoadItemSlot;
    preset SelectedItem = 0;
    preset ItemHeight = Menu::ItemHeightTall;
    preset NoOfItems;
    preset ItemClass = Menu::ItemWrapper;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,290,690,330>
  slot OnLoadItemSlot
  {
    var int32 ItemNo = MenuList.Item;
    var Menu::ItemWrapper Item = (Menu::ItemWrapper)MenuList.View;
    if( null != Item )
    {
      var Menu::BaseMenuView OwnerMenu = (Menu::BaseMenuView)Owner;
      if( null != OwnerMenu )
      {
        Item.Height = ItemHeight;
        Item.ItemClass = OwnerMenu.LoadItemClass( ItemNo );
        Item.Title = OwnerMenu.LoadItemTitle( ItemNo );
        Item.Enabled = OwnerMenu.LoadItemEnabled( ItemNo );
        Item.OnActivate = OnItemActivateSlot;
        Item.OnLongEnterKeyActivate = OnLongEnterKeyActivatedSlot;
        Item.Focusable = Focusable;
        Item.DDModeEnabled = DDModeEnabled;
      }

      if( Menu::ItemCheckbox == Item.ItemClass ||
          Menu::ItemCheckMark == Item.ItemClass ||
          Menu::ItemValueUnitCheckmark == Item.ItemClass )
      {
        Item.Checked = OwnerMenu.LoadItemChecked( ItemNo );
        Item.ToggleEnabled = OwnerMenu.LoadItemToggle( ItemNo );
      }

      if( Menu::ItemBaseValue == Item.ItemClass )
      {
        Item.Value = OwnerMenu.LoadItemBaseValue( ItemNo );
      }
      else if( Menu::ItemNotification == Item.ItemClass )
      {
        Item.Message = OwnerMenu.LoadItemMessage( ItemNo );
        Item.ReceivedTime = OwnerMenu.LoadItemReceivedTime( ItemNo );
        Item.Category = OwnerMenu.LoadItemCategory( ItemNo );
        Item.Uid = OwnerMenu.LoadItemUid( ItemNo );
      }
      else if( Menu::ItemValueUnitCheckmark == Item.ItemClass ||
               Menu::ItemValueUnit == Item.ItemClass ||
               Menu::ItemValueUnit2 == Item.ItemClass )
      {
        Item.Value = OwnerMenu.LoadItemValue( ItemNo );
        Item.Unit = OwnerMenu.LoadItemUnit( ItemNo );
      }
      else if( Menu::ItemTimeHourMinute == Item.ItemClass )
      {
        Item.Hour = OwnerMenu.LoadItemHour( ItemNo );
        Item.Minute = OwnerMenu.LoadItemMinute( ItemNo );
      }
      else
      {
        //empty
      }

      Item.Bounds.size = point( MenuList.Bounds.w, MenuList.ItemHeight );
    }
  }

  $rect <490,340,690,380>
  slot OnItemActivateSlot
  {
    var Menu::ItemBase MenuItem = null;
    var Menu::ItemWrapper WrapperItem = ( Menu::ItemWrapper )sender;
    if( null != WrapperItem )
    {
      var Core::View Menu = WrapperItem.FindNextView( null, Core::ViewState[] );
      if( null != Menu )
      {
        MenuItem = (Menu::ItemBase)Menu;
      }
    }

    var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )Owner;
    if( null != OwnerMenu )
    {
      OwnerMenu.OnItemActivate( MenuList.SelectedItem, MenuItem );
    }
  }

  $rect <490,10,690,50>
  property int32 NoOfItems = 0;

  $rect <490,50,690,90>
  onset NoOfItems
  {
    if( pure NoOfItems != value )
    {
      pure NoOfItems = value;
      MenuList.NoOfItems = value;
      Scrollbar.ListItems = value;

      // set focus frame invisible when there is no item
      if( 0 == value )
      {
        FocusFrame.Visible = false;
      }
      else
      {
        FocusFrame.Visible = true;
      }

      // move focus to the item before the last item when the last item is deleted
      if( 0 < MenuList.NoOfItems &&
          MenuList.SelectedItem >= MenuList.NoOfItems )
      {
        MenuList.SelectedItem = MenuList.NoOfItems - 1;
        MoveFocusFrame();
        SwitchToPageOfSelectedItem();
      }

      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Menu::Scrollbar Scrollbar
  {
    preset Bounds = <453,6,463,214>;
    preset Visible = false;
    preset PageItems = 3;
  }

  $rect <0,340,200,380>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    MenuList.InvalidateItems( aFirstItem, aLastItem );
  }

  $rect <0,390,200,430>
  property bool Focusable = true;

  $rect <0,470,200,510>
  property int32 ItemHeight = Menu::ItemHeightTall;

  $rect <0,510,200,550>
  onset ItemHeight
  {
    if( pure ItemHeight != value )
    {
      pure ItemHeight = value;
      MenuList.ItemHeight = value;
      FocusFrame.Bounds.y2 = 2 + ItemHeight;

      UpdateListHeight();
    }

  }

  $rect <0,570,210,610>
  property int32 ItemNumPerPage = 3;

  $rect <20,20,160,60>
  object Views::Border FocusFrame
  {
    preset Bounds = <18,0,435,76>;
    preset Width = 3;
    preset Color = #0072FFFF;
    preset Visible = false;
  }

  // Note:
  // For the case of 3 rows/page, the height of each row is 74px, and the total height \
  // is 222px.
  // For the case of 4 rows/page, the height of each row is 56px, and the total height \
  // is 224px.
  note group Note2
  {
    attr Bounds = <720,10,1460,110>;
  }

  $rect <240,570,440,610>
  method void MoveFocusFrame()
  {
    var int32 SelectedRow = MenuList.SelectedItem % ItemNumPerPage;
    var rect FocusFrameRect = FocusFrame.Bounds;
    FocusFrameRect.y1 = ItemHeight * SelectedRow;
    FocusFrameRect.y2 = 2 + ItemHeight * ( SelectedRow + 1 );
    FocusFrame.Bounds = FocusFrameRect;
  }

  $rect <0,610,210,650>
  onset ItemNumPerPage
  {
    if( pure ItemNumPerPage != value )
    {
      pure ItemNumPerPage = value;
      Scrollbar.PageItems = value;
      UpdateListHeight();
      InvalidateViewState();
    }
  }

  $rect <240,610,440,650>
  method void UpdateListHeight()
  {
    MenuList.Bounds.y2 = MenuList.Bounds.y1 + ItemHeight * ItemNumPerPage;
  }

  $rect <930,290,1180,330>
  method void SwitchToPageOfSelectedItem()
  {
    var int32 CurrentPageIdx = ( -1 ) * MenuList.ScrollOffset / MenuList.Bounds.h;
    var int32 PageIdxOfSelectedItem = MenuList.SelectedItem / ItemNumPerPage;

    if( CurrentPageIdx != PageIdxOfSelectedItem )
    {
      FocusFrame.Visible = false;
      PageScrollEffect.Value1 = MenuList.ScrollOffset;
      PageScrollEffect.Value2 = ( -1 ) * PageIdxOfSelectedItem * MenuList.Bounds.h;
      PageScrollEffect.Enabled = true;
    }
  }

  $rect <20,20,160,60>
  object Menu::ArrowScrollBar ArrowScrollBar
  {
    preset Bounds = <441,5,473,221>;
    preset Visible = false;
  }

  $rect <490,120,730,160>
  property bool ArrowScrollBarVisible = false;

  $rect <490,160,730,200>
  onset ArrowScrollBarVisible
  {
    if( pure ArrowScrollBarVisible != value )
    {
      pure ArrowScrollBarVisible = value;
      ArrowScrollBar.Visible = value;
    }
  }

  $rect <930,340,1180,380>
  object Effects::Int32Effect PageScrollEffect
  {
    preset OnFinished = OnPageScrolledSlot;
    preset Exponent = 4.19;
    preset Timing = Effects::Timing.Exp_Out;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset InitialDelay = 50;
    preset Outlet = ^MenuList.ScrollOffset;
  }

  $rect <930,390,1180,430>
  slot OnPageScrolledSlot
  {
    FocusFrame.Visible = true;

    if( ArrowScrollBarVisible )
    {
      var int32 PageIdxOfSelectedItem = MenuList.SelectedItem / ItemNumPerPage;
      ArrowScrollBar.CurrentPageIdx = PageIdxOfSelectedItem;
    }
  }

  $rect <490,200,730,240>
  method void HideArrowScrollBar()
  {
    ArrowScrollBar.Visible = false;
  }

  $rect <490,240,730,280>
  method void RestoreArrowScrollBar()
  {
    if( ArrowScrollBarVisible )
    {
      ArrowScrollBar.Visible = true;
    }
  }

  $rect <750,120,950,160>
  property bool ScrollbarVisible = false;

  $rect <750,160,950,200>
  onset ScrollbarVisible
  {
    if( pure ScrollbarVisible != value )
    {
      pure ScrollbarVisible = value;
      Scrollbar.Visible = value;
    }
  }

  $rect <980,120,1180,160>
  property rect FocusFrameBounds;

  $rect <980,160,1180,200>
  onset FocusFrameBounds
  {
    if( pure FocusFrameBounds != value )
    {
      pure FocusFrameBounds = value;
      FocusFrame.Bounds = value;
    }
  }

  $rect <240,470,440,510>
  property int32 SelectedItem = -1;

  $rect <240,510,440,550>
  onset SelectedItem
  {
    if( pure SelectedItem != value )
    {
      pure SelectedItem = value;
      if( 0 <= value &&
          MenuList.NoOfItems > value )
      {
        MenuList.SelectedItem = value;
        postsignal OnSelectedItemChanged;

        Scrollbar.ViewIdx = value;
        SwitchToPageOfSelectedItem();
        MoveFocusFrame();
      }
    }
  }

  $rect <750,200,950,240>
  method void HideScrollbar()
  {
    Scrollbar.Visible = false;
  }

  $rect <750,240,950,280>
  method void RestoreScrollbar()
  {
    if( ScrollbarVisible && Scrollbar.PageNum > 0 )
    {
      Scrollbar.Visible = true;
    }
  }

  $rect <980,240,1180,280>
  method void RestoreFocusFrame()
  {
    if( 0 < NoOfItems )
    {
      FocusFrame.Visible = true;
    }
  }

  $rect <490,390,750,430>
  slot OnLongEnterKeyActivatedSlot
  {
    var Menu::ItemBase MenuItem = null;
    var Menu::ItemWrapper WrapperItem = (Menu::ItemWrapper)sender;
    if( null != WrapperItem )
    {
      var Core::View Menu = WrapperItem.FindNextView( null, Core::ViewState[] );
      if( null != Menu )
      {
        MenuItem = (Menu::ItemBase)Menu;
      }
    }

    var Menu::BaseMenuView OwnerMenu = (Menu::BaseMenuView)Owner;
    if( null != OwnerMenu )
    {
      OwnerMenu.OnItemLongEnterKeyActivate( MenuList.SelectedItem, MenuItem );
    }
  }

  $rect <480,510,700,550>
  property slot OnSelectedItemChanged;
}

$rect <230,60,430,100>
$output false
class ItemCheckbox : Menu::ItemBase
{
  $rect <0,180,190,220>
  inherited onset Enabled
  {
    super( value );

    if( value )
    {
      CheckboxIcon.Bitmap = Resource::CheckboxNormal;
    }
    else
    {
      CheckboxIcon.Bitmap = Resource::CheckboxDisable;
    }
  }

  $rect <0,230,190,270>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,9,367,43>;
        CheckboxIcon.Bounds = <371,2,421,52>;
      }
      default:;
    }
  }

  $rect <220,130,450,170>
  inherited method OnShortEnterKeyActivated()
  {
    super();
    if( ToggleEnabled )
    {
      Checked = !Checked;
    }
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,366,69>;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,130,200,170>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      if( value )
      {
        CheckboxIcon.FrameNumber = 1;
      }
      else
      {
        CheckboxIcon.FrameNumber = 0;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image CheckboxIcon
  {
    preset Bounds = <371,11,421,61>;
    preset Bitmap = Resource::CheckboxNormal;
  }

  $rect <220,80,420,120>
  property bool ToggleEnabled = false;
}

// This is a GUI component.
$rect <460,60,660,100>
$output false
class ItemWrapper : Core::Group
{
  $rect <0,84,200,124>
  inherited property Bounds = <0,0,480,74>;

  $rect <480,410,660,450>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <480,350,660,390>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      pure Enabled = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      var Menu::ItemBase ItemBase = ( Menu::ItemBase )view;
      if( null != ItemBase )
      {
        ItemBase.Enabled = value;
      }
    }
  }

  $rect <480,290,660,330>
  inherited property Enabled;

  // This is a property.
  $rect <40,290,240,330>
  property class ItemClass = null;

  $rect <40,350,240,390>
  onset ItemClass
  {
    if( pure ItemClass != value )
    {
      // Remember the property's new value.
      pure ItemClass = value;

      // Remove the old embedded item, if any ...
      if( CountViews() > 0 )
      {
        Remove( FindNextView( null, Core::ViewState[] ) );
      }

      var Menu::ItemBase Item = ( Menu::ItemBase )new value;
      Item.Height = Height;
      Item.OnActivate = OnActivateSlot;
      Item.OnLongEnterKeyActivate = OnLongEnterKeyActivatedSlot;
      Add( Item, 0 );
    }
  }

  // This is a property.
  $rect <260,290,460,330>
  property string Title = "Title";

  $rect <260,350,460,390>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase MenuItem = ( Menu::ItemBase )view;
      if( MenuItem != null )
      {
        MenuItem.SetTitle( Title );
      }
    }
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <0,190,200,230>
  property slot OnActivate = null;

  $rect <0,140,200,180>
  slot OnActivateSlot
  {
    postsignal OnActivate;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <20,250,1120,470>;
  }

  // For item with checkbox or checkmark
  note group Note7
  {
    attr Bounds = <20,500,530,650>;
  }

  $rect <40,540,240,580>
  property bool Checked;

  $rect <40,590,240,630>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemCheckbox CheckboxMenuItem = ( Menu::ItemCheckbox )view;
      if( CheckboxMenuItem != null )
      {
        CheckboxMenuItem.Checked = value;
      }
      else
      {
        var Menu::ItemCheckMark CheckMarkMenuItem = ( Menu::ItemCheckMark)view;
        if( null != CheckMarkMenuItem )
        {
          CheckMarkMenuItem.Checked = value;
        }
      }

      if( Menu::ItemValueUnitCheckmark == ( classof view ) )
      {
        var Menu::ItemValueUnitCheckmark MenuItem = (Menu::ItemValueUnitCheckmark)view;
        if( MenuItem != null )
        {
          MenuItem.Checked = value;
        }
      }
    }
  }

  $rect <220,140,470,180>
  slot OnLongEnterKeyActivatedSlot
  {
    postsignal OnLongEnterKeyActivate;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <220,190,450,230>
  property slot OnLongEnterKeyActivate = null;

  $rect <670,290,870,330>
  property bool Focusable = true;

  $rect <670,350,870,390>
  onset Focusable
  {
    if( pure Focusable != value )
    {
      pure Focusable = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.Focusable = value;
      }
    }
  }

  $rect <890,290,1090,330>
  property int32 Height;

  $rect <890,350,1090,390>
  property bool DDModeEnabled;

  $rect <890,390,1090,430>
  onset DDModeEnabled
  {
    if( pure DDModeEnabled != value )
    {
      pure DDModeEnabled = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemBase Item = ( Menu::ItemBase )view;
      if( null != Item )
      {
        Item.DDModeEnabled = value;
      }
    }
  }

  // For item with unit/value
  note group Note8
  {
    attr Bounds = <20,670,530,830>;
  }

  $rect <40,720,240,760>
  property string Value;

  $rect <40,760,240,800>
  onset Value
  {
    if( pure Value != value )
    {
      pure Value = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      if( Menu::ItemBaseValue == ( classof view ) )
      {
        var Menu::ItemBaseValue MenuItem = (Menu::ItemBaseValue)view;
        if( MenuItem != null )
        {
          MenuItem.Value = value;
        }
      }
      else if( Menu::ItemValueUnit == ( classof view ) )
      {
        var Menu::ItemValueUnit MenuItem = (Menu::ItemValueUnit)view;
        if( MenuItem != null )
        {
          MenuItem.Value = value;
        }
      }
      else if( Menu::ItemValueUnit2 == ( classof view ) )
      {
        var Menu::ItemValueUnit2 MenuItem = (Menu::ItemValueUnit2)view;
        if( MenuItem != null )
        {
          MenuItem.Value = value;
        }
      }
      else if( Menu::ItemValueUnitCheckmark == ( classof view ) )
      {
        var Menu::ItemValueUnitCheckmark MenuItem = (Menu::ItemValueUnitCheckmark)view;
        if( MenuItem != null )
        {
          MenuItem.Value = value;
        }
      }
      else
      {
        // empty
      }
    }
  }

  // For notification menu item
  note group Note9
  {
    attr Bounds = <20,840,910,990>;
  }

  $rect <40,880,240,920>
  property string Message;

  $rect <40,920,240,960>
  onset Message
  {
    if( pure Message != value )
    {
      pure Message = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemNotification NotificationItem = ( Menu::ItemNotification )view;
      if( NotificationItem != null )
      {
        NotificationItem.Message = value;
      }
    }
  }

  $rect <260,880,460,920>
  property string ReceivedTime;

  $rect <260,920,460,960>
  onset ReceivedTime
  {
    if( pure ReceivedTime != value )
    {
      pure ReceivedTime = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemNotification NotificationItem = ( Menu::ItemNotification )view;
      if( NotificationItem != null )
      {
        NotificationItem.ReceivedTime = value;
      }
    }
  }

  $rect <470,880,670,920>
  property Enum::NotificationCategory Category = Enum::NotificationCategory.TOTAL;

  $rect <470,920,670,960>
  onset Category
  {
    if( pure Category != value )
    {
      pure Category = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemNotification NotificationItem = ( Menu::ItemNotification )view;
      if( NotificationItem != null )
      {
        NotificationItem.Category = value;
      }
    }
  }

  $rect <680,880,880,920>
  property uint32 Uid;

  $rect <680,920,880,960>
  onset Uid
  {
    if( pure Uid != value )
    {
      pure Uid = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemNotification NotificationItem = ( Menu::ItemNotification )view;
      if( NotificationItem != null )
      {
        NotificationItem.Uid = value;
      }
    }
  }

  $rect <260,540,460,580>
  property bool ToggleEnabled;

  $rect <260,590,460,630>
  onset ToggleEnabled
  {
    if( pure ToggleEnabled != value )
    {
      pure ToggleEnabled = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );
      var Menu::ItemCheckbox CheckboxMenuItem = (Menu::ItemCheckbox)view;
      if( null != CheckboxMenuItem )
      {
        CheckboxMenuItem.ToggleEnabled = value;
      }
    }
  }

  $rect <260,720,460,760>
  property string Unit;

  $rect <260,760,460,800>
  onset Unit
  {
    if( pure Unit != value )
    {
      pure Unit = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );

      if( Menu::ItemValueUnit == ( classof view ) )
      {
        var Menu::ItemValueUnit MenuItem = (Menu::ItemValueUnit)view;
        if( MenuItem != null )
        {
          MenuItem.Unit = value;
        }
      }
      else if( Menu::ItemValueUnit2 == ( classof view ) )
      {
        var Menu::ItemValueUnit2 MenuItem = (Menu::ItemValueUnit2)view;
        if( MenuItem != null )
        {
          MenuItem.Unit = value;
        }
      }
      else if( Menu::ItemValueUnitCheckmark == ( classof view ) )
      {
        var Menu::ItemValueUnitCheckmark MenuItem = (Menu::ItemValueUnitCheckmark)view;
        if( MenuItem != null )
        {
          MenuItem.Unit = value;
        }
      }
      else
      {
        // empty
      }
    }
  }

  // For item with unit/value
  note group Note10
  {
    attr Bounds = <550,670,1060,830>;
  }

  $rect <570,720,770,760>
  property string Hour;

  $rect <570,760,770,800>
  onset Hour
  {
    if( pure Value != value )
    {
      pure Value = value;

      var Core::View view = FindNextView( null, Core::ViewState[] );

      if( Menu::ItemTimeHourMinute == ( classof view ) )
      {
        var Menu::ItemTimeHourMinute MenuItem = (Menu::ItemTimeHourMinute)view;
        if( MenuItem != null )
        {
          MenuItem.Hour = value;
        }
      }
      else
      {
        // empty
      }
    }
  }

  $rect <790,720,990,760>
  property string Minute;

  $rect <790,760,990,800>
  onset Minute
  {
    if( pure Unit != value )
    {
      pure Unit = value;
      var Core::View view = FindNextView( null, Core::ViewState[] );

      if( Menu::ItemTimeHourMinute == ( classof view ) )
      {
        var Menu::ItemTimeHourMinute MenuItem = (Menu::ItemTimeHourMinute)view;
        if( MenuItem != null )
        {
          MenuItem.Minute = value;
        }
      }
      else
      {
        // empty
      }
    }
  }
}

$rect <460,160,660,200>
$output false
class Scrollbar : Core::Group
{
  $rect <60,160,260,200>
  inherited property Bounds = <0,0,8,208>;

  $rect <60,210,260,250>
  inherited method UpdateViewState()
  {
    super( aState );

    if( PageNum > 0 )
    {
      var int32 CurrentPage = ViewIdx / PageItems;
      var int32 BarHeight = int32( float( Bounds.h ) / float( PageNum ) );
      var int32 BarTopY = int32( float( Bounds.h ) * ( float( CurrentPage ) / float( PageNum ) ) );

      ScrollEffect.Value1 = Bar.Bounds;
      ScrollEffect.Value2 = rect( Bar.Bounds.x1, BarTopY, Bar.Bounds.x2, BarTopY + BarHeight );
      ScrollEffect.Enabled = true;
    }
  }

  $rect <20,20,160,60>
  object Views::Line Track
  {
    preset Point2 = <4,208>;
    preset Point1 = <4,0>;
    preset Width = 2;
    preset Color = #88878CFF;
  }

  $rect <490,60,690,100>
  property int32 ViewIdx;

  $rect <490,100,690,140>
  onset ViewIdx
  {
    if( pure ViewIdx != value )
    {
      pure ViewIdx = value;
      InvalidateViewState();
    }
  }

  $rect <60,60,260,100>
  property int32 PageItems;

  $rect <60,100,260,140>
  onset PageItems
  {
    if( pure PageItems != value )
    {
      pure PageItems = value;
      UpdatePageNum();
    }
  }

  $rect <280,60,480,100>
  property int32 ListItems;

  $rect <280,100,480,140>
  onset ListItems
  {
    if( pure ListItems != value )
    {
      pure ListItems = value;
      UpdatePageNum();
      InvalidateViewState();
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Bounds = <0,00,10,40>;
  }

  $rect <710,60,910,100>
  var int32 PageNum;

  $rect <710,100,910,140>
  method void UpdatePageNum()
  {
    if( PageItems >= ListItems )
    {
      Bar.Visible = false;
      Track.Visible = false;
      PageNum = 0;
    }
    else if( PageItems > 0 )
    {
      PageNum = ListItems / PageItems;
      if( ListItems > ( PageNum * PageItems ) )
      {
        PageNum = PageNum + 1;
      }

      Bar.Visible = true;
      Track.Visible = true;
    }
    else
    {
      // empty
    }
  }

  $rect <60,310,260,350>
  object Effects::RectEffect ScrollEffect
  {
    preset Exponent = 4.19;
    preset Timing = Effects::Timing.Exp_Out;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Bar.Bounds;
  }
}

$rect <460,10,660,50>
$output false
class BaseMenuView : Components::BaseMainBG
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  // super( value );
  $rect <10,340,210,380>
  inherited onset DDModeEnabled
  {
    super( value );
    Menu.DDModeEnabled = value;
  }

  $rect <550,50,750,90>
  method class LoadItemClass( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return null;
  }

  $rect <551,104,751,144>
  method string LoadItemTitle( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <230,290,430,330>
  method void OnItemActivate( arg int32 aItemNo, arg Menu::ItemBase aMenuItem )
  {
    // suppress warning
    aMenuItem;
    aItemNo;
  }

  // For general menu item
  note group Note6
  {
    attr Bounds = <520,0,780,220>;
  }

  // For checkbox menu item
  note group Note7
  {
    attr Bounds = <520,245,780,400>;
  }

  $rect <550,295,750,335>
  method bool LoadItemChecked( arg int32 aItemNo )
  {
    aItemNo; //suppress warning
    return false;
  }

  $rect <550,160,750,200>
  method bool LoadItemEnabled( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return true;
  }

  $rect <20,20,160,60>
  object Menu::VerticalMenu Menu
  {
    preset Bounds = <0,36,480,272>;
    preset DDModeEnabled = false;
    preset NoOfItems = 0;
    preset ArrowScrollBarVisible = false;
  }

  // For menu item which has value
  note group Note8
  {
    attr Bounds = <520,410,810,510>;
  }

  $rect <540,450,740,490>
  method string LoadItemBaseValue( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return "";
  }

  // For notification item
  note group Note9
  {
    attr Bounds = <800,0,1060,250>;
  }

  $rect <830,40,1030,80>
  method string LoadItemMessage( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <830,90,1050,130>
  method string LoadItemReceivedTime( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return "";
  }

  $rect <830,140,1050,180>
  method Enum::NotificationCategory LoadItemCategory( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return Enum::NotificationCategory.MESSAGE;
  }

  $rect <830,190,1050,230>
  method uint32 LoadItemUid( arg int32 aItemNo )
  {
    if( aItemNo >= 0 )
    {
      // empty body to suppress warning
    }
    return 0;
  }

  $rect <550,340,750,380>
  method bool LoadItemToggle( arg int32 aItemNo )
  {
    aItemNo; //suppress warning
    return true;
  }

  // For value, unit, checkmark menu item
  note group Note10
  {
    attr Bounds = <520,520,860,670>;
  }

  $rect <540,560,740,600>
  method string LoadItemUnit( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return "";
  }

  $rect <540,610,740,650>
  method string LoadItemValue( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return "";
  }

  $rect <230,340,480,380>
  method void OnItemLongEnterKeyActivate( arg int32 aItemNo, arg Menu::ItemBase aMenuItem )
  {
    // suppress warning
    aMenuItem;
    aItemNo;
  }

  // For item with hour and minute
  note group Note11
  {
    attr Bounds = <520,680,860,830>;
  }

  $rect <540,720,740,760>
  method string LoadItemHour( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return "";
  }

  $rect <540,770,740,810>
  method string LoadItemMinute( arg int32 aItemNo )
  {
    aItemNo; // suppress warning
    return "";
  }

  $reorder BlackBG 1
  $reorder LoadItemClass 1
  $reorder LoadItemTitle 1
  $reorder OnItemActivate 1
}

$rect <690,10,910,50>
$output false
class PushButton : Components::BaseComponent
{
  $rect <10,60,210,100>
  inherited property Bounds = <0,0,150,40>;

  $rect <520,10,720,50>
  inherited method UpdateViewState()
  {
    super( aState );

    if( FocusFrameFlashTimer.Enabled )
    {
      Background.Color = #FFFFFFCD; // 0xCD = 205 : 80% alpha
    }
    else if( aState.contains( Core::ViewState[Focused] ) )
    {
      Background.Color = #00000026; // 0x26 = 38 : 15% alpha
      if( Focusable )
      {
        FocusBorder.Color = #0072FFFF;
        FocusBorder.Width = 3;
      }
    }
    else
    {
      Background.Color = #00000026;
      FocusBorder.Color = #727171FF;
      FocusBorder.Width = 2;
    }
  }

  $rect <260,200,490,240>
  inherited method OnShortEnterKeyActivated()
  {
    if( false == KeyHandler.Repetition &&
        Focusable &&
        ButtonEnabled &&
        !IsDDModeEffected() )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      // To avoid sending OnActivate more than once when short pressing enter consecutively within the very short period,
      // disable KeyHandler before blinking the background and enable KeyHandler again after the blink ends.
      KeyHandler.Enabled = false;
      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <260,50,460,90>
  inherited property PassUpKey = true;

  $rect <260,150,460,190>
  inherited property PassDownKey = true;

  $rect <260,100,460,140>
  inherited property PassHomeKey = true;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,40>;
    preset Color = #00000026;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,36>;
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <10,110,210,150>
  property string Title = "";

  $rect <10,150,210,190>
  onset Title
  {
    if( pure Title != value )
    {
      pure Title = value;
      TitleText.String = value;
    }
  }

  $rect <790,110,990,150>
  slot OnEnterReleaseSlot
  {
    if( false == KeyHandler.Repetition && Focusable && ButtonEnabled )
    {
      InvalidateViewState();

      if( FocusFrameFlashTimer.Enabled )
      {
        postsignal OnActivate;
        FocusFrameFlashTimer.Enabled = false;
      }

      // To avoid sending OnActivate more than once when short pressing enter consecutively within the very short period,
      // disable KeyHandler before blinking the background and enable KeyHandler again after the blink ends.
      KeyHandler.Enabled = false;
      FocusFrameFlashTimer.Enabled = true;
    }
  }

  $rect <520,60,720,100>
  object Core::Timer FocusFrameFlashTimer
  {
    preset OnTrigger = OnFocusFrameFlashTimer;
    preset Period = 0;
    preset Begin = 100;
  }

  $rect <520,110,720,150>
  slot OnFocusFrameFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;

    KeyHandler.Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Border FocusBorder
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,40>;
    preset Width = 2;
    preset Color = #0072FFFF;
  }

  $rect <10,210,210,250>
  property bool Focusable = true;

  $rect <10,250,210,290>
  onset Focusable
  {
    trace "OnSetFocusable: ", value;
    if( pure Focusable != value )
    {
      pure Focusable = value;
      if( value )
      {
        FocusBorder.Color = #0072FFFF;
      }
      else
      {
        FocusBorder.Color = #727171FF;
      }
    }
  }

  $rect <10,300,210,340>
  property slot OnActivate;

  $rect <520,170,720,210>
  property bool ButtonEnabled = true;

  $rect <520,210,720,250>
  onset ButtonEnabled
  {
    if( pure ButtonEnabled != value )
    {
      pure ButtonEnabled = value;

      if( value )
      {
        TitleText.Color = #FFFFFFFF;
      }
      else
      {
        TitleText.Color = #646464FF;
      }
    }
  }

  // Key Settings
  note group Note3
  {
    attr Bounds = <240,10,500,260>;
  }
}

$rect <690,60,910,100>
$output false
class UpDownPushButtonSet : Components::BaseComponent
{
  $rect <0,120,200,160>
  inherited property Bounds = <0,0,150,83>;

  $rect <2,210,230,250>
  inherited method OnShortDownKeyActivated()
  {
    Focus = DownButton;
  }

  $rect <0,170,230,210>
  inherited method OnShortUpKeyActivated()
  {
    Focus = UpButton;
  }

  $rect <340,120,540,160>
  inherited onset DDModeEnabled
  {
    if( pure DDModeEnabled != value )
    {
      pure DDModeEnabled = value;
      UpButton.DDModeEnabled = value;
      DownButton.DDModeEnabled = value;
    }
  }

  $rect <20,20,160,60>
  object Menu::PushButton UpButton
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz];
    preset Bounds = <0,0,150,40>;
    preset PassMagicKey = true;
    preset Title = "Cancel";
    preset OnActivate = OnActivateSlot;
  }

  $rect <20,20,160,60>
  object Menu::PushButton DownButton
  {
    preset Layout = Core::Layout[AlignToBottom, ResizeHorz];
    preset Bounds = <0,43,150,83>;
    preset PassMagicKey = true;
    preset Title = "OK";
    preset OnActivate = OnActivateSlot;
  }

  $rect <0,370,200,410>
  slot OnActivateSlot
  {
    if( DownButton == sender )
    {
      postsignal OnDownButtonActivated;
    }
    else if( UpButton == sender )
    {
      postsignal OnUpButtonActivated;
    }
    else
    {
      // empty body
    }
  }

  $rect <2,260,220,300>
  property slot OnUpButtonActivated;

  $rect <2,300,220,340>
  property slot OnDownButtonActivated;

  $rect <340,170,540,210>
  property string UpButtonTitle = Strings::GEN_CANCEL;

  $rect <340,210,540,250>
  onset UpButtonTitle
  {
    if( pure UpButtonTitle != value )
    {
      pure UpButtonTitle = value;
      UpButton.TitleText.String = value;
    }
  }

  $rect <340,260,540,300>
  property string DownButtonTitle = Strings::GEN_OK;

  $rect <340,300,550,340>
  onset DownButtonTitle
  {
    if( pure DownButtonTitle != value )
    {
      pure DownButtonTitle = value;
      DownButton.TitleText.String = value;
    }
  }

  $rect <650,170,850,210>
  property bool UpButtonEnabled = true;

  $rect <650,210,850,250>
  onset UpButtonEnabled
  {
    if( pure UpButtonEnabled != value )
    {
      pure UpButtonEnabled = value;
      UpButton.ButtonEnabled = value;
    }
  }

  $rect <650,280,850,320>
  property bool DownButtonEnabled = true;

  $rect <650,320,850,360>
  onset DownButtonEnabled
  {
    if( pure DownButtonEnabled != value )
    {
      pure DownButtonEnabled = value;
      DownButton.ButtonEnabled = value;
    }
  }

  $reorder IsDDModeEffected 1
  $reorder OnSetDDModeEnabled 1
  $reorder OnDownKeyReleased 1
  $reorder OnUpKeyReleased 1
  $reorder UpButton 1
  $reorder DownButton 1
  $reorder OnActivateSlot 1
  $reorder OnUpButtonActivated 1
  $reorder OnDownButtonActivated 1
  $reorder UpButtonTitle 1
  $reorder OnSetUpButtonTitle 1
  $reorder DownButtonTitle 1
  $reorder OnSetDownButtonTitle 1
  $reorder UpButtonEnabled 1
  $reorder OnSetUpButtonEnabled 1
  $reorder DownButtonEnabled 1
  $reorder OnSetDownButtonEnabled 1
}

$rect <230,110,430,150>
$output false
class ItemCheckMark : Menu::ItemBase
{
  $rect <220,80,410,120>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        Title.Bounds = <37,9,367,43>;
        CheckMark.Bounds = <371,2,421,52>;
      }
      default:;
    }
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <37,1,364,69>;
  }

  $rect <0,80,200,120>
  property bool Checked = false;

  $rect <0,120,200,160>
  onset Checked
  {
    if( pure Checked != value )
    {
      pure Checked = value;
      CheckMark.Visible = value;
    }
  }

  $rect <20,20,160,60>
  object Views::Image CheckMark
  {
    preset Bounds = <371,9,421,59>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::CheckMark;
    preset Visible = false;
  }

  $rect <0,180,200,220>
  property Resources::Font Font;

  $rect <0,220,200,260>
  onset Font
  {
    if( pure Font != value )
    {
      pure Font = value;
      Title.Font = value;
    }
  }
}

$rect <10,10,210,50>
$output false
const int32 ItemHeightTall = 74;

$rect <10,60,210,100>
$output false
const int32 ItemHeightSmall = 56;

$rect <460,210,660,250>
$output false
class ArrowScrollBar : Core::Group
{
  $rect <50,10,230,50>
  inherited property Bounds = <0,0,32,216>;

  $rect <50,50,230,90>
  inherited method UpdateViewState()
  {
    super( aState );

    if( 0 == NoOfPages )
    {
      UpArrowIcon.Visible = false;
      DownArrowIcon.Visible = false;
    }
    else
    {
      if( 0 == CurrentPageIdx )
      {
        UpArrowIcon.Visible = false;
      }
      else
      {
        UpArrowIcon.Visible = true;
      }

      if( ( NoOfPages - 1 ) == CurrentPageIdx )
      {
        DownArrowIcon.Visible = false;
      }
      else
      {
        DownArrowIcon.Visible = true;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image UpArrowIcon
  {
    preset Bounds = <0,0,32,32>;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <20,20,160,60>
  object Views::Image DownArrowIcon
  {
    preset Bounds = <0,184,32,216>;
    preset FrameNumber = 1;
    preset Bitmap = Resource::PageUpDown;
  }

  $rect <250,10,450,50>
  property int32 CurrentPageIdx;

  $rect <250,50,450,90>
  onset CurrentPageIdx
  {
    if ( pure CurrentPageIdx != value )
    {
      pure CurrentPageIdx = value;
      InvalidateViewState();
    }
  }

  $rect <480,10,680,50>
  property int32 NoOfPages;

  $rect <480,50,680,90>
  onset NoOfPages
  {
    if ( pure NoOfPages != value )
    {
      pure NoOfPages = value;
      InvalidateViewState();
    }
  }
}

$rect <230,160,430,200>
$output false
class ItemBaseValue : Menu::ItemBase
{
  $rect <0,110,200,150>
  inherited method UpdateLayout()
  {
    super( aSize );

    switch( Height )
    {
      case Menu::ItemHeightSmall:
      {
        ValueText.Bounds = <290,7,417,43>;
      }
      case Menu::ItemHeightTall:
      {
        Title.Bounds = <37,1,193,69>;
        ValueText.Bounds = <385,1,418,69>;
      }
      default:;
    }
  }

  $rect <220,210,420,250>
  inherited onset Enabled
  {
    if( pure Enabled != value )
    {
      super( value );

      if( value )
      {
        ValueText.Color = #FFFFFFFF;
      }
      else
      {
        ValueText.Color = #646464FF;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Text ValueText
  {
    preset Bounds = <290,9,417,43>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <220,110,420,150>
  property string Value;

  $rect <220,150,420,190>
  onset Value
  {
    if( pure Value != value )
    {
      pure Value = value;
      ValueText.String = value;
    }
  }
}

// Delay time after selecting the menu item of check mark type
$rect <10,110,210,150>
$output false
const int32 DELAY_TIME_CHECKMARK = 450;

$rect <230,210,430,250>
$output false
class ItemNotification : Menu::ItemBase
{
  $rect <20,20,160,60>
  inherited object HighlightRect
  {
    preset Bounds = <10,0,444,74>;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <68,6,367,36>;
    preset Font = Fonts::NotoSansCjkJpMedium24pt;
  }

  $rect <20,20,160,60>
  object Views::Text MessageText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <68,36,439,66>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertTop];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium24pt;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text ReceivedTimeText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <376,8,439,38>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "00:00";
    preset Font = Fonts::NotoSansCjkJpMedium24pt;
    preset Color = #FFFFFFFF;
  }

  $rect <10,120,210,160>
  property string Message;

  $rect <10,160,210,200>
  onset Message
  {
    if( pure Message != value )
    {
      pure Message = value;
      MessageText.String = value;
    }

  }

  $rect <240,120,440,160>
  property string ReceivedTime;

  $rect <240,160,440,200>
  onset ReceivedTime
  {
    if( pure ReceivedTime != value )
    {
      pure ReceivedTime = value;
      ReceivedTimeText.String = value;
    }
  }

  $rect <490,120,690,160>
  property Enum::NotificationCategory Category = Enum::NotificationCategory.TOTAL;

  $rect <490,160,690,200>
  onset Category
  {
    if( pure Category != value )
    {
      pure Category = value;
      if( Enum::NotificationCategory.MESSAGE == value )
      {
        CategoryIcon.FrameNumber = 0;
        CategoryIcon.Visible = true;
      }
      else if( Enum::NotificationCategory.MISSED_CALL == value )
      {
        CategoryIcon.FrameNumber = 1;
        CategoryIcon.Visible = true;
      }
      else
      {
        CategoryIcon.Visible = false;
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Image CategoryIcon
  {
    preset Bounds = <13,11,63,61>;
    preset Bitmap = Resource::NotificationCategory;
    preset Visible = false;
  }

  $rect <740,120,940,160>
  property uint32 Uid;
}

$rect <230,360,450,400>
$output false
class ItemValueUnitCheckmark : Menu::ItemCheckMark
{
  $rect <10,180,200,220>
  inherited onset Enabled
  {
    super( value );

    if( value )
    {
      ValueText.Color = Color::WHITE;
      UnitText.Color = Color::WHITE;
      CheckMark.FrameNumber = 1;
    }
    else
    {
      ValueText.Color = Color::GRAY_FOR_DISABLED;
      UnitText.Color = Color::GRAY_FOR_DISABLED;
      CheckMark.FrameNumber = 0;
    }
  }

  $rect <20,20,160,60>
  object Views::Text ValueText
  {
    preset Bounds = <145,9,300,43>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <306,9,366,43>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <10,90,210,130>
  property string Value;

  $rect <10,130,210,170>
  onset Value
  {
    if( pure Value != value )
    {
      pure Value = value;
      ValueText.String = value;
    }
  }

  $rect <250,90,450,130>
  property string Unit;

  $rect <250,130,450,170>
  onset Unit
  {
    if( pure Unit != value )
    {
      pure Unit = value;
      UnitText.String = value;
    }
  }
}

$rect <230,260,430,300>
$output false
class ItemValueUnit : Menu::ItemBase
{
  $rect <8,202,198,242>
  inherited onset Enabled
  {
    super( value );

    if( value )
    {
      ValueText.Color = Color::WHITE;
      UnitText.Color = Color::WHITE;
    }
    else
    {
      ValueText.Color = Color::GRAY_FOR_DISABLED;
      UnitText.Color = Color::GRAY_FOR_DISABLED;
    }
  }

  $rect <20,20,160,60>
  object Views::Text ValueText
  {
    preset Bounds = <200,1,351,69>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <357,1,417,69>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <10,90,210,130>
  property string Value;

  $rect <10,130,210,170>
  onset Value
  {
    if( pure Value != value )
    {
      pure Value = value;
      ValueText.String = value;
    }
  }

  $rect <250,90,450,130>
  property string Unit;

  $rect <250,130,450,170>
  onset Unit
  {
    if( pure Unit != value )
    {
      pure Unit = value;
      UnitText.String = value;
    }
  }
}

$rect <230,410,430,450>
$output false
class ItemTimeHourMinute : Menu::ItemBase
{
  $rect <20,20,160,60>
  object Views::Text HourValueText
  {
    preset Bounds = <212,0,286,70>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteValueText
  {
    preset Bounds = <325,0,359,70>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <20,20,160,60>
  object Views::Text HourText
  {
    preset Bounds = <290,0,321,70>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::GEN_HOUR_ABBREVIATION;
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteText
  {
    preset Bounds = <363,0,417,70>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = Strings::GEN_MINUTE_ABBREVIATION;
    preset Font = Fonts::NotoSansCjkJpMedium28pt;
  }

  $rect <10,90,210,130>
  property string Hour;

  $rect <10,130,210,170>
  onset Hour
  {
    if( pure Hour != value )
    {
      pure Hour = value;
      HourValueText.String = value;
    }

  }

  $rect <250,90,450,130>
  property string Minute;

  $rect <250,130,450,170>
  onset Minute
  {
    if( pure Minute != value )
    {
      pure Minute = value;
      MinuteValueText.String = value;
    }

  }
}

$rect <10,160,210,200>
$output false
const int32 INVALID_TIME = -1;

$rect <230,310,430,350>
$output false
class ItemValueUnit2 : Menu::ItemValueUnit
{
  $rect <20,20,160,60>
  inherited object ValueText
  {
    preset Bounds = <212,1,286,69>;
  }

  $rect <20,20,160,60>
  inherited object UnitText
  {
    preset Bounds = <290,1,417,69>;
  }
}
