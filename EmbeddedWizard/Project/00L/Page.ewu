$version 9.30

$rect <50,220,250,260>
$output false
class SettingPage : Page::BaseComponent
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */

    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  //
  // - Adjust the visible size of your component (the thick blue border).
  //
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  //
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  //
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  //
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  //
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  //
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  //
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  //
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,300,1000,620>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,272>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <100,0,390,40>;
    preset String = "Setting";
    preset Font = Application::FontNotoSansCjkJp42;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <160,90,310,140>;
    preset Label = "Button 1";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <160,150,310,200>;
    preset Label = "Button 2";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <160,210,310,260>;
    preset Label = "Button 3";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <50,120,250,160>
$output false
class NavigationPage : Page::BaseComponent
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */

    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <580,100,780,140>
  inherited method FocusNext()
  {
    trace "navi FocusNext";
    if( Focus == StopNaviButton )
      {
      Focus = StartNaviButton;
      }
  }

  $rect <580,50,780,90>
  inherited method FocusPrevious()
  {
    trace "navi FocusPrevious";
    if( Focus == StartNaviButton )
      {
      Focus = StopNaviButton;
      }
  }

  $rect <580,150,780,190>
  inherited method FocusEnter()
  {
    trace "navi FocusEnter", Focus;
  }

  // To do:
  //
  // - Adjust the visible size of your component (the thick blue border).
  //
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  //
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  //
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  //
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  //
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  //
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  //
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  //
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,300,1000,620>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,272>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <100,0,390,40>;
    preset String = "Navigation";
    preset Font = Application::FontNotoSansCjkJp42;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StopNaviButton
  {
    preset Bounds = <50,200,230,250>;
    preset Focus = null;
    preset Label = "Stop Navigation";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StartNaviButton
  {
    preset Bounds = <50,140,230,190>;
    preset Label = "Start Navigation";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <50,170,250,210>
$output false
class MediaPage : Page::BaseComponent
{
  $rect <10,290,210,330>
  inherited property Bounds = <0,0,480,272>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */

    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <550,100,750,140>
  inherited slot ProcKeyHoldSlot
  {
    trace "Media ProcKeyHoldSlot, sender: ", sender;
    trace "MediaPage init. Owner: ", Owner;
    trace "KeyPressHandler Continue = true";

    var Core::KeyPressHandler KeyPressHandler = ( Core::KeyPressHandler )sender;
    KeyPressHandler.Continue = true;
    //signal PassKeyHold, sender;
  }

  // To do:
  //
  // - Adjust the visible size of your component (the thick blue border).
  //
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  //
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  //
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  //
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  //
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  //
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  //
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  //
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,300,1000,620>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,272>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <100,0,390,40>;
    preset String = "Media";
    preset Font = Application::FontNotoSansCjkJp42;
  }
}

$rect <280,30,480,70>
$output false
enum Index
{
  $rect <10,10,210,50>
  item Navigation;

  $rect <10,60,210,100>
  item Media;

  $rect <10,110,210,150>
  item Setting;

  $rect <10,160,210,200>
  item Total;
}

$rect <280,90,480,130>
$output false
enum Direction
{
  $rect <10,10,210,50>
  item Previous;

  $rect <220,10,420,50>
  item Next;
}

$rect <50,50,250,90>
$output false
class BaseComponent : Core::Group
{
  $rect <100,90,300,130>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnRelease = OnKeyReleaseSlot;
    preset OnPress = OnKeyPressSlot;
    preset OnHold = OnKeyHoldSlot;
  }

  $rect <100,145,300,185>
  slot OnKeyPressSlot
  {
    trace ComponentName + " base OnKeyPressSlot: ", KeyHandler.Code;

    switch( KeyHandler.Code )
      {
      case Core::KeyCode.Down: FocusNext();
      case Core::KeyCode.Up: FocusPrevious();
      case Core::KeyCode.Ok:;
      default:;
      }

  }

  $rect <100,200,300,240>
  slot OnKeyHoldSlot
  {
    trace ComponentName + " base OnKeyHoldSlot: ", KeyHandler.Code, KeyHandler.RepetitionCount;

    if( 1 == KeyHandler.RepetitionCount )
      {
      //KeyHandler.Continue = true;
      signal ProcKeyHoldSlot, KeyHandler;
      }

  }

  $rect <100,40,300,80>
  property string ComponentName;

  $rect <100,250,300,290>
  slot OnKeyReleaseSlot
  {
    trace ComponentName + " base OnKeyReleaseSlot: ", KeyHandler.Code;
    switch( KeyHandler.Code )
      {
      case Core::KeyCode.Down:;
      case Core::KeyCode.Up:;
      case Core::KeyCode.Ok: FocusEnter();
      default:;
      }
  }

  $rect <530,200,730,240>
  property slot PassKeyHold;

  $rect <320,200,520,240>
  slot ProcKeyHoldSlot
  {
  }

  $rect <530,146,730,186>
  method void FocusNext()
  {
    trace "FocusNext";
  }

  $rect <320,146,520,186>
  method void FocusPrevious()
  {
    trace "FocusPrevious";
  }

  $rect <740,147,940,187>
  method void FocusEnter()
  {
    trace "FocusEnter";
  }
}
