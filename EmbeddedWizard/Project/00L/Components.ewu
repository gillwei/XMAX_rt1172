$version 10.00

$rect <20,20,220,60>
$output false
class BaseComponent : Core::Group
{
  $rect <40,60,220,100>
  inherited method Init()
  {
    DeviceInterface::SystemDevice.SetKeyTriggerMode( Core::KeyCode.Up, UpKeyTriggerMode );
    DeviceInterface::SystemDevice.SetKeyTriggerMode( Core::KeyCode.Down, DownKeyTriggerMode );
    DeviceInterface::SystemDevice.SetKeyTriggerMode( Core::KeyCode.Ok, EnterKeyTriggerMode );
    DeviceInterface::SystemDevice.SetKeyTriggerMode( Core::KeyCode.Home, HomeKeyTriggerMode );
    DeviceInterface::SystemDevice.SetMagicKeyEnabled( MagicKeyEnabled );
  }

  $rect <40,110,240,150>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnRelease = OnKeyReleaseSlot;
    preset OnPress = OnKeyPressSlot;
    preset OnHold = OnKeyHoldSlot;
  }

  $rect <40,160,240,200>
  slot OnKeyPressSlot
  {
    $if $prototyper
      trace "key event to: ", classof this;
    $endif

    switch( KeyHandler.Code )
    {
      case Core::KeyCode.Up:
      {
        if( PassUpKey )
        {
          KeyHandler.Continue = true;
        }
        else
        {
          if( ( Enum::KeyTriggerMode.ON == UpKeyTriggerMode ) && !IsDDModeEffected() )
          {
            OnShortUpKeyActivated();
          }
        }
      }
      case Core::KeyCode.Down:
      {
        if( PassDownKey )
        {
          KeyHandler.Continue = true;
        }
        else
        {
          if( ( Enum::KeyTriggerMode.ON == DownKeyTriggerMode ) && !IsDDModeEffected() )
          {
            OnShortDownKeyActivated();
          }
        }
      }
      case Core::KeyCode.Ok:
      {
        if( PassEnterKey )
        {
          KeyHandler.Continue = true;
        }
        else
        {
          if( ( Enum::KeyTriggerMode.ON == EnterKeyTriggerMode ) && !IsDDModeEffected() )
          {
            OnShortEnterKeyActivated();
          }
        }
      }
      case Core::KeyCode.Home:
      {
        if( PassHomeKey )
        {
          KeyHandler.Continue = true;
        }
        else
        {
          if( Enum::KeyTriggerMode.ON == HomeKeyTriggerMode )
          {
            OnShortHomeKeyActivated();
          }
        }
      }
      case Core::KeyCode.F9:
      {
        if( PassMagicKey )
        {
          KeyHandler.Continue = true;
        }
        else
        {
          OnShortMagicKeyActivated();
        }
      }
      default:;
    }
  }

  $rect <40,210,240,250>
  slot OnKeyHoldSlot
  {
    if( !IsDDModeEffected() )
    {
      switch( KeyHandler.Code )
      {
        case Core::KeyCode.Up: OnLongUpKeyActivated();
        case Core::KeyCode.Down: OnLongDownKeyActivated();
        case Core::KeyCode.Ok: OnLongEnterKeyActivated();
        case Core::KeyCode.Home: OnLongHomeKeyActivated();
        default:;
      }
    }
  }

  $rect <40,260,240,300>
  slot OnKeyReleaseSlot
  {
    if( !KeyHandler.Repetition )
    {
      switch( KeyHandler.Code )
      {
        case Core::KeyCode.Up:
        {
          if( ( Enum::KeyTriggerMode.OFF == UpKeyTriggerMode ) && !IsDDModeEffected() && DeviceInterface::SystemDevice.IsKeyStateValid() )
          {
            OnShortUpKeyActivated();
          }
          else
          {
            OnUpKeyReleased();
          }
        }
        case Core::KeyCode.Down:
        {
          if( ( Enum::KeyTriggerMode.OFF == DownKeyTriggerMode ) && !IsDDModeEffected() && DeviceInterface::SystemDevice.IsKeyStateValid() )
          {
            OnShortDownKeyActivated();
          }
          else
          {
            OnDownKeyReleased();
          }
        }
        case Core::KeyCode.Ok:
        {
          if( ( Enum::KeyTriggerMode.OFF == EnterKeyTriggerMode ) && !IsDDModeEffected() && DeviceInterface::SystemDevice.IsKeyStateValid() )
          {
            OnShortEnterKeyActivated();
          }
        }
        case Core::KeyCode.Home:
        {
          if( Enum::KeyTriggerMode.OFF == HomeKeyTriggerMode && DeviceInterface::SystemDevice.IsKeyStateValid() )
          {
            OnShortHomeKeyActivated();
          }
        }
        default:;
      }
    }
    else
    {
      switch( KeyHandler.Code )
      {
        case Core::KeyCode.Up: OnUpKeyReleased();
        case Core::KeyCode.Down: OnDownKeyReleased();
        default:;
      }
    }
  }

  $rect <255,110,485,150>
  method void OnShortDownKeyActivated()
  {
  }

  $rect <255,60,485,100>
  method void OnShortUpKeyActivated()
  {
  }

  $rect <255,160,485,200>
  method void OnShortEnterKeyActivated()
  {
  }

  // Key Handle
  note group Note5
  {
    attr Bounds = <20,10,1380,320>;
  }

  $rect <255,210,485,250>
  method void OnShortHomeKeyActivated()
  {
  }

  $rect <950,60,1150,100>
  property Enum::KeyTriggerMode UpKeyTriggerMode = Enum::KeyTriggerMode.ON;

  $rect <950,110,1150,150>
  property Enum::KeyTriggerMode DownKeyTriggerMode = Enum::KeyTriggerMode.ON;

  $rect <950,160,1150,200>
  property Enum::KeyTriggerMode EnterKeyTriggerMode = Enum::KeyTriggerMode.OFF;

  $rect <950,210,1150,250>
  property Enum::KeyTriggerMode HomeKeyTriggerMode = Enum::KeyTriggerMode.OFF;

  $rect <495,110,725,150>
  method void OnLongDownKeyActivated()
  {
  }

  $rect <495,60,725,100>
  method void OnLongUpKeyActivated()
  {
  }

  $rect <495,160,725,200>
  method void OnLongEnterKeyActivated()
  {
  }

  $rect <495,210,725,250>
  method void OnLongHomeKeyActivated()
  {
    if( Home::ACTIVATE_LONG_PRESS_REPETITION_COUNT == KeyHandler.RepetitionCount )
    {
      var Application::Application App = ( Application::Application )GetRoot();
      if( null != App )
      {
        App.ReturnToHome();
      }
    }
  }

  $rect <1160,60,1360,100>
  property bool PassUpKey = false;

  $rect <1160,110,1360,150>
  property bool PassDownKey = false;

  $rect <1161,160,1361,200>
  property bool PassHomeKey = false;

  $rect <1160,210,1360,250>
  property bool PassEnterKey = false;

  $rect <255,260,485,300>
  method void OnShortMagicKeyActivated()
  {
  }

  $rect <1160,260,1360,300>
  property bool PassMagicKey = false;

  $rect <40,380,240,420>
  property bool DDModeEnabled = false;

  $rect <40,480,240,520>
  method bool IsDDModeEffected()
  {
    return ( DDModeEnabled && DeviceInterface::VehicleDevice.DDModeActivated );
  }

  // Driver Distraction Mode
  note group Note7
  {
    attr Bounds = <20,330,260,540>;
  }

  $rect <40,430,240,470>
  onset DDModeEnabled
  {
    if( pure DDModeEnabled != value )
    {
      pure DDModeEnabled = value;
    }
  }

  // Callback when down key of on trigger mode is released
  $rect <734,110,944,150>
  method void OnDownKeyReleased()
  {
  }

  // Callback when up key of on trigger mode is released
  $rect <734,160,944,200>
  method void OnUpKeyReleased()
  {
  }

  $rect <950,260,1150,300>
  property bool MagicKeyEnabled = false;
}

$rect <20,70,220,110>
$output false
class BaseMainBG : Components::BaseComponent
{
  $rect <220,280,400,320>
  inherited method Init()
  {
    DDModeStateChangedHandler.Enabled = DDModeEnabled;
    UpdateDDModeMask();
  }

  $rect <0,280,200,320>
  inherited property Bounds = <0,0,480,272>;

  $rect <220,330,450,370>
  inherited method OnShortHomeKeyActivated()
  {
    if( IsDDModeEffected() )
    {
      var Application::Application App = ( Application::Application )GetRoot();
      if( null != App )
      {
        App.ReturnToLauncher();
      }
    }
    else
    {
      DismissThisDialog();
    }
  }

  $rect <540,170,740,210>
  inherited onset DDModeEnabled
  {
    super( value );
    DDModeStateChangedHandler.Enabled = value;
  }

  $rect <20,20,160,60>
  object Views::Image MainBottomBG
  {
    preset Bounds = <0,182,480,272>;
    preset Bitmap = Resource::MainBG;
  }

  $rect <20,20,160,60>
  object Views::Rectangle BlackBG
  {
    preset Bounds = <0,38,480,182>;
    preset Color = #000000FF;
  }

  $rect <540,70,790,110>
  object Core::SystemEventHandler DDModeStateChangedHandler
  {
    preset OnEvent = OnDDModeStateChangedSlot;
    preset Enabled = false;
    preset Event = DeviceInterface::VehicleDevice.DDModeStateChangedSystemEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <540,120,790,160>
  slot OnDDModeStateChangedSlot
  {
    UpdateDDModeMask();
  }

  $rect <20,20,160,60>
  object Components::DDModeMask DDModeMask
  {
    preset StackingPriority = 1;
    preset Bounds = <0,36,480,272>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <540,220,740,260>
  method void UpdateDDModeMask()
  {
    if( DDModeEnabled )
    {
      // always dimiss the DD mode mask even when this dialog is not the top dialog.
      if( !DeviceInterface::VehicleDevice.DDModeActivated )
      {
        DDModeMask.Visible = false;
      }
      else
      {
        if( IsCurrentDialog() )
        {
          DDModeMask.Visible = true;
        }
      }
    }
  }

  // Driver Distraction Mode
  note group Note5
  {
    attr Bounds = <510,30,820,280>;
  }

  $rect <220,380,420,420>
  method void DismissThisDialog()
  {
    if( SlideOutEffectEnabled )
    {
      SlideOutDialog();
    }
    else
    {
      if( Owner != null )
      {
        // Show FocusFrame if Owner is of menu type
        var Menu::BaseMenuView MenuDialog = ( Menu::BaseMenuView )Owner;
        if( null != MenuDialog )
        {
          MenuDialog.Menu.FocusFrame.Visible = true;
        }

        Owner.DismissDialog( this, Effect::NoSlideOut, null, null, null, null, false );
      }
    }
  }

  $rect <360,490,560,530>
  method void SlideInDialog( arg Components::BaseMainBG aChildDialog )
  {
    if( IsCurrentDialog() && null != aChildDialog )
    {
      ChildDialog = aChildDialog;

      // hide the highlight focus frame of the child menu
      var Menu::BaseMenuView ChildMenu = ( Menu::BaseMenuView )aChildDialog;
      if( null != ChildMenu )
      {
        ChildMenu.Menu.FocusFrame.Visible = false;
        ChildMenu.Menu.HideArrowScrollBar();
        ChildMenu.Menu.HideScrollbar();
      }

      // hide the highlight focus frame of this current menu
      var Menu::BaseMenuView CurrentMenu = ( Menu::BaseMenuView )this;
      if( null != CurrentMenu )
      {
        CurrentMenu.Menu.FocusFrame.Visible = false;
        CurrentMenu.Menu.HideArrowScrollBar();
        CurrentMenu.Menu.HideScrollbar();
      }

      SlideDirection = Core::Direction.Left;
      HideFocusFrameTimer.Enabled = true;
    }
  }

  $rect <670,490,870,530>
  object Core::Timer HideFocusFrameTimer
  {
    preset OnTrigger = OnHideFocusFrameTimeoutSlot;
    preset Period = 50;
  }

  $rect <670,590,940,630>
  slot OnHideFocusFrameTimeoutSlot
  {
    HideFocusFrameTimer.Enabled = false;

    if( Core::Direction.Left == SlideDirection )
    {
      PresentDialogWithSlideInEffect( ChildDialog );
    }
    else
    {
      DismissMenuWithSlideOutEffect();
    }
  }

  $rect <360,540,580,580>
  var Components::BaseMainBG ChildDialog;

  // SlideIn Menu Operation
  note group Note8
  {
    attr Bounds = <330,450,630,700>;
  }

  $rect <360,640,620,680>
  slot OnDialogSlideInCompletedSlot
  {
    // show hightlight frame of the child menu after slide-in animation
    var Menu::BaseMenuView ChildMenu = ( Menu::BaseMenuView )ChildDialog;
    if( null != ChildMenu )
    {
      if( ChildMenu.Menu.NoOfItems > 0 )
      {
        ChildMenu.Menu.FocusFrame.Visible = true;
      }
      if( ChildMenu.Menu.ArrowScrollBarVisible )
      {
        ChildMenu.Menu.RestoreArrowScrollBar();
      }
    }

    ChildDialog = null;
  }

  // Timer to hide highlight
  note group Note9
  {
    attr Bounds = <650,450,950,700>;
  }

  $rect <360,590,620,630>
  method void PresentDialogWithSlideInEffect( arg Core::Group aView )
  {
    if( null != aView )
    {
      PresentDialog( aView, Effect::SlideInTransition, null, null, null, null, null, OnDialogSlideInCompletedSlot, null, false );
    }
  }

  $rect <0,380,210,420>
  var bool SlideOutEffectEnabled = false;

  $rect <30,640,290,680>
  slot OnDialogSlideOutCompletedSlot
  {
    // Set the focus frame of the owner menu visible after sliding-out animation
    var Menu::BaseMenuView OwnerMenu = ( Menu::BaseMenuView )OwnerDialog;
    if( null != OwnerMenu )
    {
      OwnerMenu.Menu.RestoreFocusFrame();
      OwnerMenu.Menu.RestoreArrowScrollBar();
      OwnerMenu.Menu.RestoreScrollbar();
    }
  }

  $rect <30,540,250,580>
  var Components::BaseMainBG OwnerDialog;

  $rect <30,490,230,530>
  method void SlideOutDialog()
  {
    if( IsCurrentDialog() )
    {
      OwnerDialog = ( Components::BaseMainBG )Owner;

      // hide the highlight focus frame of this current menu
      var Menu::BaseMenuView CurrentMenu = ( Menu::BaseMenuView )this;
      if( null != CurrentMenu )
      {
        CurrentMenu.Menu.FocusFrame.Visible = false;
        CurrentMenu.Menu.HideArrowScrollBar();
      }

      SlideDirection = Core::Direction.Right;
      HideFocusFrameTimer.Enabled = true;
    }
  }

  $rect <30,590,290,630>
  method void DismissMenuWithSlideOutEffect()
  {
    Owner.DismissDialog( this, Effect::SlideOutTransition, null, null, OnDialogSlideOutCompletedSlot, null, false );
  }

  // SlideOut Menu Operation
  note group Note10
  {
    attr Bounds = <10,450,310,700>;
  }

  $rect <670,540,870,580>
  var Core::Direction SlideDirection;
}

$rect <20,120,220,160>
$output false
class DDModeMask : Core::Group
{
  $rect <10,320,210,360>
  inherited property Bounds = <0,0,480,236>;

  $rect <20,20,160,60>
  object Views::Rectangle DDModeBG
  {
    preset StackingPriority = 0;
    preset Bounds = <0,0,480,236>;
    preset Color = #000000CD;
  }

  $rect <20,20,160,60>
  object Views::Image DDModeIcon
  {
    preset StackingPriority = 0;
    preset Bounds = <195,62,285,152>;
    preset Bitmap = Resource::IconDDActive;
  }
}
